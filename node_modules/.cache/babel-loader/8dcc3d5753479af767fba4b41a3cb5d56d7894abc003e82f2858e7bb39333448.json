{"ast":null,"code":"/*! @azure/msal-common v14.4.0 2023-11-07 */\n'use strict';\n\nimport { Constants, ResponseCodes, RegionDiscoverySources } from '../utils/Constants.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { invokeAsync } from '../utils/FunctionWrappers.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass RegionDiscovery {\n  constructor(networkInterface, logger, performanceClient, correlationId) {\n    this.networkInterface = networkInterface;\n    this.logger = logger;\n    this.performanceClient = performanceClient;\n    this.correlationId = correlationId;\n  }\n  /**\n   * Detect the region from the application's environment.\n   *\n   * @returns Promise<string | null>\n   */\n  async detectRegion(environmentRegion, regionDiscoveryMetadata) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);\n    // Initialize auto detected region with the region from the envrionment\n    let autodetectedRegionName = environmentRegion;\n    // Check if a region was detected from the environment, if not, attempt to get the region from IMDS\n    if (!autodetectedRegionName) {\n      const options = RegionDiscovery.IMDS_OPTIONS;\n      try {\n        const localIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(Constants.IMDS_VERSION, options);\n        if (localIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n          autodetectedRegionName = localIMDSVersionResponse.body;\n          regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n        }\n        // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry.\n        if (localIMDSVersionResponse.status === ResponseCodes.httpBadRequest) {\n          const currentIMDSVersion = await invokeAsync(this.getCurrentVersion.bind(this), PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.logger, this.performanceClient, this.correlationId)(options);\n          if (!currentIMDSVersion) {\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n            return null;\n          }\n          const currentIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(currentIMDSVersion, options);\n          if (currentIMDSVersionResponse.status === ResponseCodes.httpSuccess) {\n            autodetectedRegionName = currentIMDSVersionResponse.body;\n            regionDiscoveryMetadata.region_source = RegionDiscoverySources.IMDS;\n          }\n        }\n      } catch (e) {\n        regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n        return null;\n      }\n    } else {\n      regionDiscoveryMetadata.region_source = RegionDiscoverySources.ENVIRONMENT_VARIABLE;\n    }\n    // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\n    if (!autodetectedRegionName) {\n      regionDiscoveryMetadata.region_source = RegionDiscoverySources.FAILED_AUTO_DETECTION;\n    }\n    return autodetectedRegionName || null;\n  }\n  /**\n   * Make the call to the IMDS endpoint\n   *\n   * @param imdsEndpointUrl\n   * @returns Promise<NetworkResponse<string>>\n   */\n  async getRegionFromIMDS(version, options) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);\n    return this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?api-version=${version}&format=text`, options, Constants.IMDS_TIMEOUT);\n  }\n  /**\n   * Get the most recent version of the IMDS endpoint available\n   *\n   * @returns Promise<string | null>\n   */\n  async getCurrentVersion(options) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);\n    try {\n      const response = await this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?format=json`, options);\n      // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\n      if (response.status === ResponseCodes.httpBadRequest && response.body && response.body[\"newest-versions\"] && response.body[\"newest-versions\"].length > 0) {\n        return response.body[\"newest-versions\"][0];\n      }\n      return null;\n    } catch (e) {\n      return null;\n    }\n  }\n}\n// Options for the IMDS endpoint request\nRegionDiscovery.IMDS_OPTIONS = {\n  headers: {\n    Metadata: \"true\"\n  }\n};\nexport { RegionDiscovery };","map":{"version":3,"names":["RegionDiscovery","constructor","networkInterface","logger","performanceClient","correlationId","autodetectedRegionName","options","IMDS_OPTIONS","ResponseCodes","httpSuccess","localIMDSVersionResponse","body","regionDiscoveryMetadata","region_source"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-common\\src\\authority\\RegionDiscovery.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { INetworkModule } from \"../network/INetworkModule\";\nimport { NetworkResponse } from \"../network/NetworkManager\";\nimport { IMDSBadResponse } from \"../response/IMDSBadResponse\";\nimport {\n    Constants,\n    RegionDiscoverySources,\n    ResponseCodes,\n} from \"../utils/Constants\";\nimport { RegionDiscoveryMetadata } from \"./RegionDiscoveryMetadata\";\nimport { ImdsOptions } from \"./ImdsOptions\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent\";\nimport { invokeAsync } from \"../utils/FunctionWrappers\";\nimport { Logger } from \"../logger/Logger\";\n\nexport class RegionDiscovery {\n    // Network interface to make requests with.\n    protected networkInterface: INetworkModule;\n    // Logger\n    private logger: Logger;\n    // Performance client\n    protected performanceClient: IPerformanceClient | undefined;\n    // CorrelationId\n    protected correlationId: string | undefined;\n    // Options for the IMDS endpoint request\n    protected static IMDS_OPTIONS: ImdsOptions = {\n        headers: {\n            Metadata: \"true\",\n        },\n    };\n\n    constructor(\n        networkInterface: INetworkModule,\n        logger: Logger,\n        performanceClient?: IPerformanceClient,\n        correlationId?: string\n    ) {\n        this.networkInterface = networkInterface;\n        this.logger = logger;\n        this.performanceClient = performanceClient;\n        this.correlationId = correlationId;\n    }\n\n    /**\n     * Detect the region from the application's environment.\n     *\n     * @returns Promise<string | null>\n     */\n    public async detectRegion(\n        environmentRegion: string | undefined,\n        regionDiscoveryMetadata: RegionDiscoveryMetadata\n    ): Promise<string | null> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RegionDiscoveryDetectRegion,\n            this.correlationId\n        );\n\n        // Initialize auto detected region with the region from the envrionment\n        let autodetectedRegionName = environmentRegion;\n\n        // Check if a region was detected from the environment, if not, attempt to get the region from IMDS\n        if (!autodetectedRegionName) {\n            const options = RegionDiscovery.IMDS_OPTIONS;\n\n            try {\n                const localIMDSVersionResponse = await invokeAsync(\n                    this.getRegionFromIMDS.bind(this),\n                    PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,\n                    this.logger,\n                    this.performanceClient,\n                    this.correlationId\n                )(Constants.IMDS_VERSION, options);\n                if (\n                    localIMDSVersionResponse.status ===\n                    ResponseCodes.httpSuccess\n                ) {\n                    autodetectedRegionName = localIMDSVersionResponse.body;\n                    regionDiscoveryMetadata.region_source =\n                        RegionDiscoverySources.IMDS;\n                }\n\n                // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry.\n                if (\n                    localIMDSVersionResponse.status ===\n                    ResponseCodes.httpBadRequest\n                ) {\n                    const currentIMDSVersion = await invokeAsync(\n                        this.getCurrentVersion.bind(this),\n                        PerformanceEvents.RegionDiscoveryGetCurrentVersion,\n                        this.logger,\n                        this.performanceClient,\n                        this.correlationId\n                    )(options);\n                    if (!currentIMDSVersion) {\n                        regionDiscoveryMetadata.region_source =\n                            RegionDiscoverySources.FAILED_AUTO_DETECTION;\n                        return null;\n                    }\n\n                    const currentIMDSVersionResponse = await invokeAsync(\n                        this.getRegionFromIMDS.bind(this),\n                        PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,\n                        this.logger,\n                        this.performanceClient,\n                        this.correlationId\n                    )(currentIMDSVersion, options);\n                    if (\n                        currentIMDSVersionResponse.status ===\n                        ResponseCodes.httpSuccess\n                    ) {\n                        autodetectedRegionName =\n                            currentIMDSVersionResponse.body;\n                        regionDiscoveryMetadata.region_source =\n                            RegionDiscoverySources.IMDS;\n                    }\n                }\n            } catch (e) {\n                regionDiscoveryMetadata.region_source =\n                    RegionDiscoverySources.FAILED_AUTO_DETECTION;\n                return null;\n            }\n        } else {\n            regionDiscoveryMetadata.region_source =\n                RegionDiscoverySources.ENVIRONMENT_VARIABLE;\n        }\n\n        // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION\n        if (!autodetectedRegionName) {\n            regionDiscoveryMetadata.region_source =\n                RegionDiscoverySources.FAILED_AUTO_DETECTION;\n        }\n\n        return autodetectedRegionName || null;\n    }\n\n    /**\n     * Make the call to the IMDS endpoint\n     *\n     * @param imdsEndpointUrl\n     * @returns Promise<NetworkResponse<string>>\n     */\n    private async getRegionFromIMDS(\n        version: string,\n        options: ImdsOptions\n    ): Promise<NetworkResponse<string>> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,\n            this.correlationId\n        );\n        return this.networkInterface.sendGetRequestAsync<string>(\n            `${Constants.IMDS_ENDPOINT}?api-version=${version}&format=text`,\n            options,\n            Constants.IMDS_TIMEOUT\n        );\n    }\n\n    /**\n     * Get the most recent version of the IMDS endpoint available\n     *\n     * @returns Promise<string | null>\n     */\n    private async getCurrentVersion(\n        options: ImdsOptions\n    ): Promise<string | null> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RegionDiscoveryGetCurrentVersion,\n            this.correlationId\n        );\n        try {\n            const response =\n                await this.networkInterface.sendGetRequestAsync<IMDSBadResponse>(\n                    `${Constants.IMDS_ENDPOINT}?format=json`,\n                    options\n                );\n\n            // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.\n            if (\n                response.status === ResponseCodes.httpBadRequest &&\n                response.body &&\n                response.body[\"newest-versions\"] &&\n                response.body[\"newest-versions\"].length > 0\n            ) {\n                return response.body[\"newest-versions\"][0];\n            }\n\n            return null;\n        } catch (e) {\n            return null;\n        }\n    }\n}\n"],"mappings":";;;;;;;AAKA;AAQA;AACA;AACA;AASW,MAAAA,eAAgB;EAEvBC,WAA2BA,CAAAC,gBAAA,EAAoBC,MAAA,EAAAC,iBAAA,EAAAC,aAAa;IAE5D,KAASH,gBAAgB,GAAMA,gBAAa;IAE5C,KAASC,MAAO,GAAaA,MAAA;IAOzB,KAAAC,iBAAA,GAAkBA,iBAClB;IAUJ,KAAAC,aAAA,GAAAA,aAAA;;;;AAIG;AACU;AAuFb;;;;;IAKG;QACW,CAAiBC,sBAAA;MAe/B,MAAAC,OAAA,GAAAP,eAAA,CAAAQ,YAAA;;;gDAIGC,aAAA,CAAAC,WAAA;UAC4BJ,sBAAA,GAAAK,wBAAA,CAAAC,IAAA;UA6BlCC,uBAAA,CAAAC,aAAA,G"},"metadata":{},"sourceType":"module","externalDependencies":[]}