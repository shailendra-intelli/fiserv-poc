{"ast":null,"code":"/*! @azure/msal-browser v3.5.0 2023-11-07 */\n'use strict';\n\nimport { TimeUtils, AuthToken, AuthError, InteractionRequiredAuthError, ServerError, ClientAuthError, ClientAuthErrorCodes } from '@azure/msal-common';\nimport { isBridgeError } from '../BridgeError.mjs';\nimport { BridgeStatusCode } from '../BridgeStatusCode.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass NestedAppAuthAdapter {\n  constructor(clientId, clientCapabilities, crypto, logger) {\n    this.clientId = clientId;\n    this.clientCapabilities = clientCapabilities;\n    this.crypto = crypto;\n    this.logger = logger;\n  }\n  toNaaSilentTokenRequest(request) {\n    let extraParams;\n    if (request.extraQueryParameters === undefined) {\n      extraParams = new Map();\n    } else {\n      extraParams = new Map(Object.entries(request.extraQueryParameters));\n    }\n    /**\n     * Need to get information about the client to populate request correctly\n     * For example: client id, client capabilities\n     */\n    const tokenRequest = {\n      userObjectId: request.account?.homeAccountId,\n      clientId: this.clientId,\n      authority: request.authority,\n      scope: request.scopes.join(\" \"),\n      correlationId: request.correlationId !== undefined ? request.correlationId : this.crypto.createNewGuid(),\n      prompt: request.prompt !== undefined ? request.prompt : \"\",\n      claims: request.claims !== undefined ? request.claims : \"\",\n      authenticationScheme: request.authenticationScheme !== undefined ? request.authenticationScheme : \"\",\n      clientCapabilities: this.clientCapabilities,\n      extraParameters: extraParams\n    };\n    return tokenRequest;\n  }\n  toNaaTokenRequest(request) {\n    let extraParams;\n    if (request.extraQueryParameters === undefined) {\n      extraParams = new Map();\n    } else {\n      extraParams = new Map(Object.entries(request.extraQueryParameters));\n    }\n    const tokenRequest = {\n      userObjectId: request.account?.homeAccountId,\n      clientId: this.clientId,\n      authority: request.authority,\n      scope: request.scopes.join(\" \"),\n      correlationId: request.correlationId !== undefined ? request.correlationId : \"\",\n      prompt: request.prompt !== undefined ? request.prompt : \"\",\n      nonce: request.nonce !== undefined ? request.nonce : \"\",\n      claims: request.claims !== undefined ? request.claims : \"\",\n      state: request.state !== undefined ? request.state : \"\",\n      authenticationScheme: request.authenticationScheme !== undefined ? request.authenticationScheme : \"\",\n      clientCapabilities: undefined,\n      extraParameters: extraParams\n    };\n    return tokenRequest;\n  }\n  fromNaaTokenResponse(request, response) {\n    const expiresOn = new Date(TimeUtils.nowSeconds() + (response.expires_in || 0) * 1000);\n    const account = this.fromNaaAccountInfo(response.account);\n    const authenticationResult = {\n      authority: response.account.environment,\n      uniqueId: response.account.homeAccountId,\n      tenantId: response.account.tenantId,\n      scopes: response.scope.split(\" \"),\n      account: this.fromNaaAccountInfo(response.account),\n      idToken: response.id_token !== undefined ? response.id_token : \"\",\n      idTokenClaims: account.idTokenClaims !== undefined ? account.idTokenClaims : {},\n      accessToken: response.access_token,\n      fromCache: true,\n      expiresOn: expiresOn,\n      tokenType: request.authenticationScheme !== undefined ? request.authenticationScheme : \"Bearer\",\n      correlationId: request.correlationId,\n      requestId: \"\",\n      extExpiresOn: expiresOn,\n      state: response.state\n    };\n    return authenticationResult;\n  }\n  /*\n   *  export type AccountInfo = {\n   *     homeAccountId: string;\n   *     environment: string;\n   *     tenantId: string;\n   *     username: string;\n   *     localAccountId: string;\n   *     name?: string;\n   *     idToken?: string;\n   *     idTokenClaims?: TokenClaims & {\n   *         [key: string]:\n   *             | string\n   *             | number\n   *             | string[]\n   *             | object\n   *             | undefined\n   *             | unknown;\n   *     };\n   *     nativeAccountId?: string;\n   *     authorityType?: string;\n   * };\n   */\n  fromNaaAccountInfo(fromAccount) {\n    let tokenClaims;\n    if (fromAccount.idToken !== undefined) {\n      tokenClaims = AuthToken.extractTokenClaims(fromAccount.idToken, this.crypto.base64Decode);\n    } else {\n      tokenClaims = undefined;\n    }\n    const account = {\n      homeAccountId: fromAccount.homeAccountId,\n      environment: fromAccount.environment,\n      tenantId: fromAccount.tenantId,\n      username: fromAccount.username,\n      localAccountId: fromAccount.localAccountId,\n      name: fromAccount.name,\n      idToken: fromAccount.idToken,\n      idTokenClaims: tokenClaims\n    };\n    return account;\n  }\n  /**\n   *\n   * @param error BridgeError\n   * @returns AuthError, ClientAuthError, ClientConfigurationError, ServerError, InteractionRequiredError\n   */\n  fromBridgeError(error) {\n    if (isBridgeError(error)) {\n      switch (error.status) {\n        case BridgeStatusCode.USER_CANCEL:\n          return new ClientAuthError(ClientAuthErrorCodes.userCanceled);\n        case BridgeStatusCode.NO_NETWORK:\n          return new ClientAuthError(ClientAuthErrorCodes.noNetworkConnectivity);\n        case BridgeStatusCode.ACCOUNT_UNAVAILABLE:\n          return new ClientAuthError(ClientAuthErrorCodes.noAccountFound);\n        case BridgeStatusCode.DISABLED:\n          return new ClientAuthError(ClientAuthErrorCodes.nestedAppAuthBridgeDisabled);\n        case BridgeStatusCode.NESTED_APP_AUTH_UNAVAILABLE:\n          return new ClientAuthError(error.code, error.description);\n        case BridgeStatusCode.TRANSIENT_ERROR:\n        case BridgeStatusCode.PERSISTENT_ERROR:\n          return new ServerError(error.code, error.description);\n        case BridgeStatusCode.USER_INTERACTION_REQUIRED:\n          return new InteractionRequiredAuthError(error.code, error.description);\n        default:\n          return new AuthError(error.code, error.description);\n      }\n    } else {\n      return new AuthError(\"unknown_error\", \"An unknown error occurred\");\n    }\n  }\n}\nexport { NestedAppAuthAdapter };","map":{"version":3,"names":["NestedAppAuthAdapter","constructor","clientId","clientCapabilities","crypto","logger","toNaaSilentTokenRequest","request","extraParams","extraQueryParameters","undefined","Map"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\naa\\mapping\\NestedAppAuthAdapter.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { TokenRequest } from \"../TokenRequest\";\nimport { AccountInfo as NaaAccountInfo } from \"../AccountInfo\";\nimport { RedirectRequest } from \"../../request/RedirectRequest\";\nimport { PopupRequest } from \"../../request/PopupRequest\";\nimport { TokenResponse } from \"../TokenResponse\";\nimport {\n    AccountInfo as MsalAccountInfo,\n    AuthError,\n    ClientAuthError,\n    ClientConfigurationError,\n    InteractionRequiredAuthError,\n    ServerError,\n    TimeUtils,\n    ICrypto,\n    Logger,\n    AuthToken,\n    TokenClaims,\n    ClientAuthErrorCodes,\n} from \"@azure/msal-common\";\nimport { isBridgeError } from \"../BridgeError\";\nimport { BridgeStatusCode } from \"../BridgeStatusCode\";\nimport { SilentRequest } from \"../../request/SilentRequest\";\nimport { AuthenticationResult } from \"../../response/AuthenticationResult\";\nimport {} from \"../../error/BrowserAuthErrorCodes\";\n\nexport class NestedAppAuthAdapter {\n    protected crypto: ICrypto;\n    protected logger: Logger;\n    protected clientId: string;\n    protected clientCapabilities: string[];\n\n    constructor(\n        clientId: string,\n        clientCapabilities: string[],\n        crypto: ICrypto,\n        logger: Logger\n    ) {\n        this.clientId = clientId;\n        this.clientCapabilities = clientCapabilities;\n        this.crypto = crypto;\n        this.logger = logger;\n    }\n\n    public toNaaSilentTokenRequest(request: SilentRequest): TokenRequest {\n        let extraParams: Map<string, string>;\n        if (request.extraQueryParameters === undefined) {\n            extraParams = new Map<string, string>();\n        } else {\n            extraParams = new Map<string, string>(\n                Object.entries(request.extraQueryParameters)\n            );\n        }\n        /**\n         * Need to get information about the client to populate request correctly\n         * For example: client id, client capabilities\n         */\n        const tokenRequest: TokenRequest = {\n            userObjectId: request.account?.homeAccountId,\n            clientId: this.clientId,\n            authority: request.authority,\n            scope: request.scopes.join(\" \"),\n            correlationId:\n                request.correlationId !== undefined\n                    ? request.correlationId\n                    : this.crypto.createNewGuid(),\n            prompt: request.prompt !== undefined ? request.prompt : \"\",\n            claims: request.claims !== undefined ? request.claims : \"\",\n            authenticationScheme:\n                request.authenticationScheme !== undefined\n                    ? request.authenticationScheme\n                    : \"\",\n            clientCapabilities: this.clientCapabilities,\n            extraParameters: extraParams,\n        };\n\n        return tokenRequest;\n    }\n\n    public toNaaTokenRequest(\n        request: PopupRequest | RedirectRequest\n    ): TokenRequest {\n        let extraParams: Map<string, string>;\n        if (request.extraQueryParameters === undefined) {\n            extraParams = new Map<string, string>();\n        } else {\n            extraParams = new Map<string, string>(\n                Object.entries(request.extraQueryParameters)\n            );\n        }\n\n        const tokenRequest: TokenRequest = {\n            userObjectId: request.account?.homeAccountId,\n            clientId: this.clientId,\n            authority: request.authority,\n            scope: request.scopes.join(\" \"),\n            correlationId:\n                request.correlationId !== undefined\n                    ? request.correlationId\n                    : \"\",\n            prompt: request.prompt !== undefined ? request.prompt : \"\",\n            nonce: request.nonce !== undefined ? request.nonce : \"\",\n            claims: request.claims !== undefined ? request.claims : \"\",\n            state: request.state !== undefined ? request.state : \"\",\n            authenticationScheme:\n                request.authenticationScheme !== undefined\n                    ? request.authenticationScheme\n                    : \"\",\n            clientCapabilities: undefined,\n            extraParameters: extraParams,\n        };\n\n        return tokenRequest;\n    }\n\n    public fromNaaTokenResponse(\n        request: TokenRequest,\n        response: TokenResponse\n    ): AuthenticationResult {\n        const expiresOn = new Date(\n            TimeUtils.nowSeconds() + (response.expires_in || 0) * 1000\n        );\n\n        const account = this.fromNaaAccountInfo(response.account);\n\n        const authenticationResult: AuthenticationResult = {\n            authority: response.account.environment,\n            uniqueId: response.account.homeAccountId,\n            tenantId: response.account.tenantId,\n            scopes: response.scope.split(\" \"),\n            account: this.fromNaaAccountInfo(response.account),\n            idToken: response.id_token !== undefined ? response.id_token : \"\",\n            idTokenClaims:\n                account.idTokenClaims !== undefined\n                    ? account.idTokenClaims\n                    : {},\n            accessToken: response.access_token,\n            fromCache: true,\n            expiresOn: expiresOn,\n            tokenType:\n                request.authenticationScheme !== undefined\n                    ? request.authenticationScheme\n                    : \"Bearer\",\n            correlationId: request.correlationId,\n            requestId: \"\",\n            extExpiresOn: expiresOn,\n            state: response.state,\n        };\n\n        return authenticationResult;\n    }\n\n    /*\n     *  export type AccountInfo = {\n     *     homeAccountId: string;\n     *     environment: string;\n     *     tenantId: string;\n     *     username: string;\n     *     localAccountId: string;\n     *     name?: string;\n     *     idToken?: string;\n     *     idTokenClaims?: TokenClaims & {\n     *         [key: string]:\n     *             | string\n     *             | number\n     *             | string[]\n     *             | object\n     *             | undefined\n     *             | unknown;\n     *     };\n     *     nativeAccountId?: string;\n     *     authorityType?: string;\n     * };\n     */\n    public fromNaaAccountInfo(fromAccount: NaaAccountInfo): MsalAccountInfo {\n        let tokenClaims: TokenClaims | undefined;\n        if (fromAccount.idToken !== undefined) {\n            tokenClaims = AuthToken.extractTokenClaims(\n                fromAccount.idToken,\n                this.crypto.base64Decode\n            );\n        } else {\n            tokenClaims = undefined;\n        }\n\n        const account: MsalAccountInfo = {\n            homeAccountId: fromAccount.homeAccountId,\n            environment: fromAccount.environment,\n            tenantId: fromAccount.tenantId,\n            username: fromAccount.username,\n            localAccountId: fromAccount.localAccountId,\n            name: fromAccount.name,\n            idToken: fromAccount.idToken,\n            idTokenClaims: tokenClaims,\n        };\n\n        return account;\n    }\n\n    /**\n     *\n     * @param error BridgeError\n     * @returns AuthError, ClientAuthError, ClientConfigurationError, ServerError, InteractionRequiredError\n     */\n    public fromBridgeError(\n        error: unknown\n    ):\n        | AuthError\n        | ClientAuthError\n        | ClientConfigurationError\n        | ServerError\n        | InteractionRequiredAuthError {\n        if (isBridgeError(error)) {\n            switch (error.status) {\n                case BridgeStatusCode.USER_CANCEL:\n                    return new ClientAuthError(\n                        ClientAuthErrorCodes.userCanceled\n                    );\n                case BridgeStatusCode.NO_NETWORK:\n                    return new ClientAuthError(\n                        ClientAuthErrorCodes.noNetworkConnectivity\n                    );\n                case BridgeStatusCode.ACCOUNT_UNAVAILABLE:\n                    return new ClientAuthError(\n                        ClientAuthErrorCodes.noAccountFound\n                    );\n                case BridgeStatusCode.DISABLED:\n                    return new ClientAuthError(\n                        ClientAuthErrorCodes.nestedAppAuthBridgeDisabled\n                    );\n                case BridgeStatusCode.NESTED_APP_AUTH_UNAVAILABLE:\n                    return new ClientAuthError(error.code, error.description);\n                case BridgeStatusCode.TRANSIENT_ERROR:\n                case BridgeStatusCode.PERSISTENT_ERROR:\n                    return new ServerError(error.code, error.description);\n                case BridgeStatusCode.USER_INTERACTION_REQUIRED:\n                    return new InteractionRequiredAuthError(\n                        error.code,\n                        error.description\n                    );\n                default:\n                    return new AuthError(error.code, error.description);\n            }\n        } else {\n            return new AuthError(\"unknown_error\", \"An unknown error occurred\");\n        }\n    }\n}\n"],"mappings":";;;;;;;AAKA;AACA;AACA;AACA;AAmBO,MAAEA,oBAAsB;EAG/BC,YAAAC,QAAiC,EAAAC,kBAAA,EAAAC,MAAA,EAAAC,MAAA;IAC7B,KAASH,QAAS,GAAAA,QAAQ;IAC1B,KAASC,kBAAgB,GAAAA,kBAAA;IACzB,KAASC,MAAC,GAAQA,MAAE;IACpB,KAASC,MAAC,GAAAA,MAAA;EAGN;EAWGC,uBAAuBA,CAACC,OAAO,EAAE;IAmCjC,IAAAC,WACI;IAmCgB,IAAAD,OAAA,CAAAE,oBACd,KAAAC,SACD;MAyDLF,WAAmB,OAAAG,GAAA,EAAa;IAyBvC,O;;;IAIG;AACI;AA2CV"},"metadata":{},"sourceType":"module","externalDependencies":[]}