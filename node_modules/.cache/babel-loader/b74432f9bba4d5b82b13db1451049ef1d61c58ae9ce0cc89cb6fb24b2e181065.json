{"ast":null,"code":"/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\n\nimport { PerformanceClient, Constants, Logger } from '@azure/msal-common';\nimport { BrowserPerformanceMeasurement } from './BrowserPerformanceMeasurement.mjs';\nimport { name, version } from '../packageMetadata.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass BrowserPerformanceClient extends PerformanceClient {\n  constructor(configuration, intFields) {\n    super(configuration.auth.clientId, configuration.auth.authority || `${Constants.DEFAULT_AUTHORITY}`, new Logger(configuration.system?.loggerOptions || {}, name, version), name, version, configuration.telemetry?.application || {\n      appName: \"\",\n      appVersion: \"\"\n    }, intFields);\n  }\n  startPerformanceMeasurement(measureName, correlationId) {\n    return new BrowserPerformanceMeasurement(measureName, correlationId);\n  }\n  generateId() {\n    return window.crypto.randomUUID();\n  }\n  getPageVisibility() {\n    return document.visibilityState?.toString() || null;\n  }\n  deleteIncompleteSubMeasurements(inProgressEvent) {\n    const rootEvent = this.eventsByCorrelationId.get(inProgressEvent.event.correlationId);\n    const isRootEvent = rootEvent && rootEvent.eventId === inProgressEvent.event.eventId;\n    const incompleteMeasurements = [];\n    if (isRootEvent && rootEvent?.incompleteSubMeasurements) {\n      rootEvent.incompleteSubMeasurements.forEach(subMeasurement => {\n        incompleteMeasurements.push({\n          ...subMeasurement\n        });\n      });\n    }\n    // Clean up remaining marks for incomplete sub-measurements\n    if (incompleteMeasurements.length > 0) {\n      BrowserPerformanceMeasurement.flushMeasurements(inProgressEvent.event.correlationId, incompleteMeasurements);\n    }\n  }\n  supportsBrowserPerformanceNow() {\n    return typeof window !== \"undefined\" && typeof window.performance !== \"undefined\" && typeof window.performance.now === \"function\";\n  }\n  /**\n   * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\n   * Also captures browser page visibilityState.\n   *\n   * @param {PerformanceEvents} measureName\n   * @param {?string} [correlationId]\n   * @returns {((event?: Partial<PerformanceEvent>) => PerformanceEvent| null)}\n   */\n  startMeasurement(measureName, correlationId) {\n    // Capture page visibilityState and then invoke start/end measurement\n    const startPageVisibility = this.getPageVisibility();\n    const inProgressEvent = super.startMeasurement(measureName, correlationId);\n    return {\n      ...inProgressEvent,\n      end: event => {\n        const res = inProgressEvent.end({\n          startPageVisibility,\n          endPageVisibility: this.getPageVisibility(),\n          ...event\n        });\n        this.deleteIncompleteSubMeasurements(inProgressEvent);\n        return res;\n      },\n      discard: () => {\n        inProgressEvent.discard();\n        this.deleteIncompleteSubMeasurements(inProgressEvent);\n        inProgressEvent.measurement.flushMeasurement();\n      }\n    };\n  }\n  /**\n   * Adds pre-queue time to preQueueTimeByCorrelationId map.\n   * @param {PerformanceEvents} eventName\n   * @param {?string} correlationId\n   * @returns\n   */\n  setPreQueueTime(eventName, correlationId) {\n    if (!this.supportsBrowserPerformanceNow()) {\n      this.logger.trace(`BrowserPerformanceClient: window performance API not available, unable to set telemetry queue time for ${eventName}`);\n      return;\n    }\n    if (!correlationId) {\n      this.logger.trace(`BrowserPerformanceClient: correlationId for ${eventName} not provided, unable to set telemetry queue time`);\n      return;\n    }\n    const preQueueEvent = this.preQueueTimeByCorrelationId.get(correlationId);\n    /**\n     * Manually complete queue measurement if there is an incomplete pre-queue event.\n     * Incomplete pre-queue events are instrumentation bugs that should be fixed.\n     */\n    if (preQueueEvent) {\n      this.logger.trace(`BrowserPerformanceClient: Incomplete pre-queue ${preQueueEvent.name} found`, correlationId);\n      this.addQueueMeasurement(preQueueEvent.name, correlationId, undefined, true);\n    }\n    this.preQueueTimeByCorrelationId.set(correlationId, {\n      name: eventName,\n      time: window.performance.now()\n    });\n  }\n  /**\n   * Calculates and adds queue time measurement for given performance event.\n   *\n   * @param {PerformanceEvents} eventName\n   * @param {?string} correlationId\n   * @param {?number} queueTime\n   * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\n   * @returns\n   */\n  addQueueMeasurement(eventName, correlationId, queueTime, manuallyCompleted) {\n    if (!this.supportsBrowserPerformanceNow()) {\n      this.logger.trace(`BrowserPerformanceClient: window performance API not available, unable to add queue measurement for ${eventName}`);\n      return;\n    }\n    if (!correlationId) {\n      this.logger.trace(`BrowserPerformanceClient: correlationId for ${eventName} not provided, unable to add queue measurement`);\n      return;\n    }\n    const preQueueTime = super.getPreQueueTime(eventName, correlationId);\n    if (!preQueueTime) {\n      return;\n    }\n    const currentTime = window.performance.now();\n    const resQueueTime = queueTime || super.calculateQueuedTime(preQueueTime, currentTime);\n    return super.addQueueMeasurement(eventName, correlationId, resQueueTime, manuallyCompleted);\n  }\n}\nexport { BrowserPerformanceClient };","map":{"version":3,"names":["BrowserPerformanceClient","PerformanceClient","constructor","configuration","intFields","auth","clientId","authority","Constants","DEFAULT_AUTHORITY","Logger","system","loggerOptions","name","version","telemetry","application","generateId","window","crypto","randomUUID","deleteIncompleteSubMeasurements","inProgressEvent","rootEvent","eventsByCorrelationId","get","event","correlationId","isRootEvent","eventId","incompleteMeasurements","length","BrowserPerformanceMeasurement","flushMeasurements"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\telemetry\\BrowserPerformanceClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    Logger,\n    PerformanceEvent,\n    PerformanceEvents,\n    IPerformanceClient,\n    PerformanceClient,\n    IPerformanceMeasurement,\n    InProgressPerformanceEvent,\n    SubMeasurement,\n    PreQueueEvent,\n    Constants,\n} from \"@azure/msal-common\";\nimport { BrowserPerformanceMeasurement } from \"./BrowserPerformanceMeasurement\";\nimport { Configuration } from \"../config/Configuration\";\nimport { name, version } from \"../packageMetadata\";\n\nexport class BrowserPerformanceClient\n    extends PerformanceClient\n    implements IPerformanceClient\n{\n    constructor(configuration: Configuration, intFields?: Set<string>) {\n        super(\n            configuration.auth.clientId,\n            configuration.auth.authority || `${Constants.DEFAULT_AUTHORITY}`,\n            new Logger(\n                configuration.system?.loggerOptions || {},\n                name,\n                version\n            ),\n            name,\n            version,\n            configuration.telemetry?.application || {\n                appName: \"\",\n                appVersion: \"\",\n            },\n            intFields\n        );\n    }\n\n    startPerformanceMeasurement(\n        measureName: string,\n        correlationId: string\n    ): IPerformanceMeasurement {\n        return new BrowserPerformanceMeasurement(measureName, correlationId);\n    }\n\n    generateId(): string {\n        return window.crypto.randomUUID();\n    }\n\n    private getPageVisibility(): string | null {\n        return document.visibilityState?.toString() || null;\n    }\n\n    private deleteIncompleteSubMeasurements(\n        inProgressEvent: InProgressPerformanceEvent\n    ): void {\n        const rootEvent = this.eventsByCorrelationId.get(\n            inProgressEvent.event.correlationId\n        );\n        const isRootEvent =\n            rootEvent && rootEvent.eventId === inProgressEvent.event.eventId;\n        const incompleteMeasurements: SubMeasurement[] = [];\n        if (isRootEvent && rootEvent?.incompleteSubMeasurements) {\n            rootEvent.incompleteSubMeasurements.forEach((subMeasurement) => {\n                incompleteMeasurements.push({ ...subMeasurement });\n            });\n        }\n        // Clean up remaining marks for incomplete sub-measurements\n        if (incompleteMeasurements.length > 0) {\n            BrowserPerformanceMeasurement.flushMeasurements(\n                inProgressEvent.event.correlationId,\n                incompleteMeasurements\n            );\n        }\n    }\n\n    supportsBrowserPerformanceNow(): boolean {\n        return (\n            typeof window !== \"undefined\" &&\n            typeof window.performance !== \"undefined\" &&\n            typeof window.performance.now === \"function\"\n        );\n    }\n\n    /**\n     * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\n     * Also captures browser page visibilityState.\n     *\n     * @param {PerformanceEvents} measureName\n     * @param {?string} [correlationId]\n     * @returns {((event?: Partial<PerformanceEvent>) => PerformanceEvent| null)}\n     */\n    startMeasurement(\n        measureName: string,\n        correlationId?: string\n    ): InProgressPerformanceEvent {\n        // Capture page visibilityState and then invoke start/end measurement\n        const startPageVisibility = this.getPageVisibility();\n\n        const inProgressEvent = super.startMeasurement(\n            measureName,\n            correlationId\n        );\n\n        return {\n            ...inProgressEvent,\n            end: (\n                event?: Partial<PerformanceEvent>\n            ): PerformanceEvent | null => {\n                const res = inProgressEvent.end({\n                    startPageVisibility,\n                    endPageVisibility: this.getPageVisibility(),\n                    ...event,\n                });\n                this.deleteIncompleteSubMeasurements(inProgressEvent);\n\n                return res;\n            },\n            discard: () => {\n                inProgressEvent.discard();\n                this.deleteIncompleteSubMeasurements(inProgressEvent);\n                inProgressEvent.measurement.flushMeasurement();\n            },\n        };\n    }\n\n    /**\n     * Adds pre-queue time to preQueueTimeByCorrelationId map.\n     * @param {PerformanceEvents} eventName\n     * @param {?string} correlationId\n     * @returns\n     */\n    setPreQueueTime(\n        eventName: PerformanceEvents,\n        correlationId?: string\n    ): void {\n        if (!this.supportsBrowserPerformanceNow()) {\n            this.logger.trace(\n                `BrowserPerformanceClient: window performance API not available, unable to set telemetry queue time for ${eventName}`\n            );\n            return;\n        }\n\n        if (!correlationId) {\n            this.logger.trace(\n                `BrowserPerformanceClient: correlationId for ${eventName} not provided, unable to set telemetry queue time`\n            );\n            return;\n        }\n\n        const preQueueEvent: PreQueueEvent | undefined =\n            this.preQueueTimeByCorrelationId.get(correlationId);\n        /**\n         * Manually complete queue measurement if there is an incomplete pre-queue event.\n         * Incomplete pre-queue events are instrumentation bugs that should be fixed.\n         */\n        if (preQueueEvent) {\n            this.logger.trace(\n                `BrowserPerformanceClient: Incomplete pre-queue ${preQueueEvent.name} found`,\n                correlationId\n            );\n            this.addQueueMeasurement(\n                preQueueEvent.name,\n                correlationId,\n                undefined,\n                true\n            );\n        }\n        this.preQueueTimeByCorrelationId.set(correlationId, {\n            name: eventName,\n            time: window.performance.now(),\n        });\n    }\n\n    /**\n     * Calculates and adds queue time measurement for given performance event.\n     *\n     * @param {PerformanceEvents} eventName\n     * @param {?string} correlationId\n     * @param {?number} queueTime\n     * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements\n     * @returns\n     */\n    addQueueMeasurement(\n        eventName: string,\n        correlationId?: string,\n        queueTime?: number,\n        manuallyCompleted?: boolean\n    ): void {\n        if (!this.supportsBrowserPerformanceNow()) {\n            this.logger.trace(\n                `BrowserPerformanceClient: window performance API not available, unable to add queue measurement for ${eventName}`\n            );\n            return;\n        }\n\n        if (!correlationId) {\n            this.logger.trace(\n                `BrowserPerformanceClient: correlationId for ${eventName} not provided, unable to add queue measurement`\n            );\n            return;\n        }\n\n        const preQueueTime = super.getPreQueueTime(eventName, correlationId);\n        if (!preQueueTime) {\n            return;\n        }\n\n        const currentTime = window.performance.now();\n        const resQueueTime =\n            queueTime || super.calculateQueuedTime(preQueueTime, currentTime);\n\n        return super.addQueueMeasurement(\n            eventName,\n            correlationId,\n            resQueueTime,\n            manuallyCompleted\n        );\n    }\n}\n"],"mappings":";;;;;;;AAKA;AAaA;AAGA;;AAsCI,MAAuCA,wBAAA,SAAAC,iBAAA;EAuBvCC,YAAAC,aAAA,EAAAC,SAAwC;IAQxC,MAAAD,aAAA,CAAAE,IAAA,CAAAC,QAAA,EAAAH,aAAA,CAAAE,IAAA,CAAAE,SAAA,OAAAC,SAAA,CAAAC,iBAAA,QAAAC,MAAA,CAAAP,aAAA,CAAAQ,MAAA,EAAAC,aAAA,QAAAC,IAAA,EAAAC,OAAA,GAAAD,IAAA,EAAAC,OAAA,EAAAX,aAAA,CAAAY,SAAA,EAAAC,WAAA;;;;;;;EAOG;EACHC,UAAgBA,CAAA;IAkChB,OAAAC,MAAA,CAAAC,MAAA,CAAAC,UAAA;;;;;EAKGC,gCAAAC,eAAA;IACY,MAAAC,SACF,QAAEC,qBAAA,CAAAC,GAAA,CAAAH,eACW,CAAAI,KACnB,CAAAC,aAAA;IAuCP,MAAAC,WAAA,GAAAL,SAAA,IAAAA,SAAA,CAAAM,OAAA,KAAAP,eAAA,CAAAI,KAAA,CAAAG,OAAA;;;;;;;;;;IAQG,IAAAC,sBAAA,CAAAC,MAAA;MACgBC,6BACE,CAAAC,iBACD,CAAMX,eAAA,CACbI,KAAA,CAAAC,aACT,EAAAG,sBACG;IA+BV"},"metadata":{},"sourceType":"module","externalDependencies":[]}