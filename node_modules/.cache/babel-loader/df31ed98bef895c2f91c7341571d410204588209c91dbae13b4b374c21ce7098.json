{"ast":null,"code":"/*! @azure/msal-browser v3.5.0 2023-11-07 */\n'use strict';\n\nimport { PerformanceEvents, invokeAsync, invoke, ServerResponseType } from '@azure/msal-common';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { DEFAULT_IFRAME_TIMEOUT_MS } from '../config/Configuration.mjs';\nimport { emptyNavigateUri, monitorWindowTimeout } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Creates a hidden iframe to given URL using user-requested scopes as an id.\n * @param urlNavigate\n * @param userRequestScopes\n */\nasync function initiateAuthRequest(requestUrl, performanceClient, logger, correlationId, navigateFrameWait) {\n  performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerInitiateAuthRequest, correlationId);\n  if (!requestUrl) {\n    // Throw error if request URL is empty.\n    logger.info(\"Navigate url is empty\");\n    throw createBrowserAuthError(emptyNavigateUri);\n  }\n  if (navigateFrameWait) {\n    return await invokeAsync(loadFrame, PerformanceEvents.SilentHandlerLoadFrame, logger, performanceClient, correlationId)(requestUrl, navigateFrameWait, performanceClient, correlationId);\n  }\n  return invoke(loadFrameSync, PerformanceEvents.SilentHandlerLoadFrameSync, logger, performanceClient, correlationId)(requestUrl);\n}\n/**\n * Monitors an iframe content window until it loads a url with a known hash, or hits a specified timeout.\n * @param iframe\n * @param timeout\n */\nasync function monitorIframeForHash(iframe, timeout, pollIntervalMilliseconds, performanceClient, logger, correlationId, responseType) {\n  performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerMonitorIframeForHash, correlationId);\n  return new Promise((resolve, reject) => {\n    if (timeout < DEFAULT_IFRAME_TIMEOUT_MS) {\n      logger.warning(`system.loadFrameTimeout or system.iframeHashTimeout set to lower (${timeout}ms) than the default (${DEFAULT_IFRAME_TIMEOUT_MS}ms). This may result in timeouts.`);\n    }\n    /*\n     * Polling for iframes can be purely timing based,\n     * since we don't need to account for interaction.\n     */\n    const timeoutId = window.setTimeout(() => {\n      window.clearInterval(intervalId);\n      reject(createBrowserAuthError(monitorWindowTimeout));\n    }, timeout);\n    const intervalId = window.setInterval(() => {\n      let href = \"\";\n      const contentWindow = iframe.contentWindow;\n      try {\n        /*\n         * Will throw if cross origin,\n         * which should be caught and ignored\n         * since we need the interval to keep running while on STS UI.\n         */\n        href = contentWindow ? contentWindow.location.href : \"\";\n      } catch (e) {}\n      if (!href || href === \"about:blank\") {\n        return;\n      }\n      let responseString = \"\";\n      if (contentWindow) {\n        if (responseType === ServerResponseType.QUERY) {\n          responseString = contentWindow.location.search;\n        } else {\n          responseString = contentWindow.location.hash;\n        }\n      }\n      window.clearTimeout(timeoutId);\n      window.clearInterval(intervalId);\n      resolve(responseString);\n    }, pollIntervalMilliseconds);\n  }).finally(() => {\n    invoke(removeHiddenIframe, PerformanceEvents.RemoveHiddenIframe, logger, performanceClient, correlationId)(iframe);\n  });\n}\n/**\n * @hidden\n * Loads iframe with authorization endpoint URL\n * @ignore\n * @deprecated\n */\nfunction loadFrame(urlNavigate, navigateFrameWait, performanceClient, correlationId) {\n  performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerLoadFrame, correlationId);\n  /*\n   * This trick overcomes iframe navigation in IE\n   * IE does not load the page consistently in iframe\n   */\n  return new Promise((resolve, reject) => {\n    const frameHandle = createHiddenIframe();\n    window.setTimeout(() => {\n      if (!frameHandle) {\n        reject(\"Unable to load iframe\");\n        return;\n      }\n      frameHandle.src = urlNavigate;\n      resolve(frameHandle);\n    }, navigateFrameWait);\n  });\n}\n/**\n * @hidden\n * Loads the iframe synchronously when the navigateTimeFrame is set to `0`\n * @param urlNavigate\n * @param frameName\n * @param logger\n */\nfunction loadFrameSync(urlNavigate) {\n  const frameHandle = createHiddenIframe();\n  frameHandle.src = urlNavigate;\n  return frameHandle;\n}\n/**\n * @hidden\n * Creates a new hidden iframe or gets an existing one for silent token renewal.\n * @ignore\n */\nfunction createHiddenIframe() {\n  const authFrame = document.createElement(\"iframe\");\n  authFrame.style.visibility = \"hidden\";\n  authFrame.style.position = \"absolute\";\n  authFrame.style.width = authFrame.style.height = \"0\";\n  authFrame.style.border = \"0\";\n  authFrame.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin allow-forms\");\n  document.getElementsByTagName(\"body\")[0].appendChild(authFrame);\n  return authFrame;\n}\n/**\n * @hidden\n * Removes a hidden iframe from the page.\n * @ignore\n */\nfunction removeHiddenIframe(iframe) {\n  if (document.body === iframe.parentNode) {\n    document.body.removeChild(iframe);\n  }\n}\nexport { initiateAuthRequest, monitorIframeForHash };","map":{"version":3,"names":["initiateAuthRequest","requestUrl","performanceClient","logger","correlationId","navigateFrameWait"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\interaction_handler\\SilentHandler.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    Logger,\n    IPerformanceClient,\n    PerformanceEvents,\n    invokeAsync,\n    invoke,\n    ServerResponseType,\n} from \"@azure/msal-common\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError\";\nimport { DEFAULT_IFRAME_TIMEOUT_MS } from \"../config/Configuration\";\n\n/**\n * Creates a hidden iframe to given URL using user-requested scopes as an id.\n * @param urlNavigate\n * @param userRequestScopes\n */\nexport async function initiateAuthRequest(\n    requestUrl: string,\n    performanceClient: IPerformanceClient,\n    logger: Logger,\n    correlationId: string,\n    navigateFrameWait?: number\n): Promise<HTMLIFrameElement> {\n    performanceClient.addQueueMeasurement(\n        PerformanceEvents.SilentHandlerInitiateAuthRequest,\n        correlationId\n    );\n\n    if (!requestUrl) {\n        // Throw error if request URL is empty.\n        logger.info(\"Navigate url is empty\");\n        throw createBrowserAuthError(BrowserAuthErrorCodes.emptyNavigateUri);\n    }\n    if (navigateFrameWait) {\n        return await invokeAsync(\n            loadFrame,\n            PerformanceEvents.SilentHandlerLoadFrame,\n            logger,\n            performanceClient,\n            correlationId\n        )(requestUrl, navigateFrameWait, performanceClient, correlationId);\n    }\n    return invoke(\n        loadFrameSync,\n        PerformanceEvents.SilentHandlerLoadFrameSync,\n        logger,\n        performanceClient,\n        correlationId\n    )(requestUrl);\n}\n\n/**\n * Monitors an iframe content window until it loads a url with a known hash, or hits a specified timeout.\n * @param iframe\n * @param timeout\n */\nexport async function monitorIframeForHash(\n    iframe: HTMLIFrameElement,\n    timeout: number,\n    pollIntervalMilliseconds: number,\n    performanceClient: IPerformanceClient,\n    logger: Logger,\n    correlationId: string,\n    responseType: ServerResponseType\n): Promise<string> {\n    performanceClient.addQueueMeasurement(\n        PerformanceEvents.SilentHandlerMonitorIframeForHash,\n        correlationId\n    );\n\n    return new Promise<string>((resolve, reject) => {\n        if (timeout < DEFAULT_IFRAME_TIMEOUT_MS) {\n            logger.warning(\n                `system.loadFrameTimeout or system.iframeHashTimeout set to lower (${timeout}ms) than the default (${DEFAULT_IFRAME_TIMEOUT_MS}ms). This may result in timeouts.`\n            );\n        }\n\n        /*\n         * Polling for iframes can be purely timing based,\n         * since we don't need to account for interaction.\n         */\n        const timeoutId = window.setTimeout(() => {\n            window.clearInterval(intervalId);\n            reject(\n                createBrowserAuthError(\n                    BrowserAuthErrorCodes.monitorWindowTimeout\n                )\n            );\n        }, timeout);\n\n        const intervalId = window.setInterval(() => {\n            let href: string = \"\";\n            const contentWindow = iframe.contentWindow;\n            try {\n                /*\n                 * Will throw if cross origin,\n                 * which should be caught and ignored\n                 * since we need the interval to keep running while on STS UI.\n                 */\n                href = contentWindow ? contentWindow.location.href : \"\";\n            } catch (e) {}\n\n            if (!href || href === \"about:blank\") {\n                return;\n            }\n\n            let responseString = \"\";\n            if (contentWindow) {\n                if (responseType === ServerResponseType.QUERY) {\n                    responseString = contentWindow.location.search;\n                } else {\n                    responseString = contentWindow.location.hash;\n                }\n            }\n            window.clearTimeout(timeoutId);\n            window.clearInterval(intervalId);\n            resolve(responseString);\n        }, pollIntervalMilliseconds);\n    }).finally(() => {\n        invoke(\n            removeHiddenIframe,\n            PerformanceEvents.RemoveHiddenIframe,\n            logger,\n            performanceClient,\n            correlationId\n        )(iframe);\n    });\n}\n\n/**\n * @hidden\n * Loads iframe with authorization endpoint URL\n * @ignore\n * @deprecated\n */\nfunction loadFrame(\n    urlNavigate: string,\n    navigateFrameWait: number,\n    performanceClient: IPerformanceClient,\n    correlationId: string\n): Promise<HTMLIFrameElement> {\n    performanceClient.addQueueMeasurement(\n        PerformanceEvents.SilentHandlerLoadFrame,\n        correlationId\n    );\n\n    /*\n     * This trick overcomes iframe navigation in IE\n     * IE does not load the page consistently in iframe\n     */\n\n    return new Promise((resolve, reject) => {\n        const frameHandle = createHiddenIframe();\n\n        window.setTimeout(() => {\n            if (!frameHandle) {\n                reject(\"Unable to load iframe\");\n                return;\n            }\n\n            frameHandle.src = urlNavigate;\n\n            resolve(frameHandle);\n        }, navigateFrameWait);\n    });\n}\n/**\n * @hidden\n * Loads the iframe synchronously when the navigateTimeFrame is set to `0`\n * @param urlNavigate\n * @param frameName\n * @param logger\n */\nfunction loadFrameSync(urlNavigate: string): HTMLIFrameElement {\n    const frameHandle = createHiddenIframe();\n\n    frameHandle.src = urlNavigate;\n\n    return frameHandle;\n}\n\n/**\n * @hidden\n * Creates a new hidden iframe or gets an existing one for silent token renewal.\n * @ignore\n */\nfunction createHiddenIframe(): HTMLIFrameElement {\n    const authFrame = document.createElement(\"iframe\");\n\n    authFrame.style.visibility = \"hidden\";\n    authFrame.style.position = \"absolute\";\n    authFrame.style.width = authFrame.style.height = \"0\";\n    authFrame.style.border = \"0\";\n    authFrame.setAttribute(\n        \"sandbox\",\n        \"allow-scripts allow-same-origin allow-forms\"\n    );\n    document.getElementsByTagName(\"body\")[0].appendChild(authFrame);\n\n    return authFrame;\n}\n\n/**\n * @hidden\n * Removes a hidden iframe from the page.\n * @ignore\n */\nfunction removeHiddenIframe(iframe: HTMLIFrameElement): void {\n    if (document.body === iframe.parentNode) {\n        document.body.removeChild(iframe);\n    }\n}\n"],"mappings":";;;;;;;;AAKA;AAcA;;;AAwCA;;;;AAIG;AACH,eAAAA,mBAA0CA,CAAAC,UAChC,EAAAC,iBACN,EAAAC,MAAO,EAAEC,aACe,EAAAC,iBAAA,EAAE"},"metadata":{},"sourceType":"module","externalDependencies":[]}