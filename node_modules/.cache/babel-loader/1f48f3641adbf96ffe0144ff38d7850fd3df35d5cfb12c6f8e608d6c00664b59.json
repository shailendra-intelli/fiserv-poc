{"ast":null,"code":"/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\n\nimport { PerformanceEvents, Constants, UrlString, AuthorizationCodeClient, Authority, AuthorityFactory, ProtocolUtils } from '@azure/msal-common';\nimport { BaseInteractionClient } from './BaseInteractionClient.mjs';\nimport { BrowserConstants } from '../utils/BrowserConstants.mjs';\nimport { version } from '../packageMetadata.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { BrowserProtocolUtils } from '../utils/BrowserProtocolUtils.mjs';\nimport { BrowserUtils } from '../utils/BrowserUtils.mjs';\nimport { noStateInHash, unableToParseState, stateInteractionTypeMismatch } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Defines the class structure and helper functions used by the \"standard\", non-brokered auth flows (popup, redirect, silent (RT), silent (iframe))\n */\nclass StandardInteractionClient extends BaseInteractionClient {\n  /**\n   * Generates an auth code request tied to the url request.\n   * @param request\n   */\n  async initializeAuthorizationCodeRequest(request) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, request.correlationId);\n    this.logger.verbose(\"initializeAuthorizationRequest called\", request.correlationId);\n    const generatedPkceParams = await this.browserCrypto.generatePkceCodes();\n    const authCodeRequest = {\n      ...request,\n      redirectUri: request.redirectUri,\n      code: Constants.EMPTY_STRING,\n      codeVerifier: generatedPkceParams.verifier\n    };\n    request.codeChallenge = generatedPkceParams.challenge;\n    request.codeChallengeMethod = Constants.S256_CODE_CHALLENGE_METHOD;\n    return authCodeRequest;\n  }\n  /**\n   * Initializer for the logout request.\n   * @param logoutRequest\n   */\n  initializeLogoutRequest(logoutRequest) {\n    this.logger.verbose(\"initializeLogoutRequest called\", logoutRequest?.correlationId);\n    const validLogoutRequest = {\n      correlationId: this.correlationId || this.browserCrypto.createNewGuid(),\n      ...logoutRequest\n    };\n    /**\n     * Set logout_hint to be login_hint from ID Token Claims if present\n     * and logoutHint attribute wasn't manually set in logout request\n     */\n    if (logoutRequest) {\n      // If logoutHint isn't set and an account was passed in, try to extract logoutHint from ID Token Claims\n      if (!logoutRequest.logoutHint) {\n        if (logoutRequest.account) {\n          const logoutHint = this.getLogoutHintFromIdTokenClaims(logoutRequest.account);\n          if (logoutHint) {\n            this.logger.verbose(\"Setting logoutHint to login_hint ID Token Claim value for the account provided\");\n            validLogoutRequest.logoutHint = logoutHint;\n          }\n        } else {\n          this.logger.verbose(\"logoutHint was not set and account was not passed into logout request, logoutHint will not be set\");\n        }\n      } else {\n        this.logger.verbose(\"logoutHint has already been set in logoutRequest\");\n      }\n    } else {\n      this.logger.verbose(\"logoutHint will not be set since no logout request was configured\");\n    }\n    /*\n     * Only set redirect uri if logout request isn't provided or the set uri isn't null.\n     * Otherwise, use passed uri, config, or current page.\n     */\n    if (!logoutRequest || logoutRequest.postLogoutRedirectUri !== null) {\n      if (logoutRequest && logoutRequest.postLogoutRedirectUri) {\n        this.logger.verbose(\"Setting postLogoutRedirectUri to uri set on logout request\", validLogoutRequest.correlationId);\n        validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(logoutRequest.postLogoutRedirectUri, BrowserUtils.getCurrentUri());\n      } else if (this.config.auth.postLogoutRedirectUri === null) {\n        this.logger.verbose(\"postLogoutRedirectUri configured as null and no uri set on request, not passing post logout redirect\", validLogoutRequest.correlationId);\n      } else if (this.config.auth.postLogoutRedirectUri) {\n        this.logger.verbose(\"Setting postLogoutRedirectUri to configured uri\", validLogoutRequest.correlationId);\n        validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(this.config.auth.postLogoutRedirectUri, BrowserUtils.getCurrentUri());\n      } else {\n        this.logger.verbose(\"Setting postLogoutRedirectUri to current page\", validLogoutRequest.correlationId);\n        validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(BrowserUtils.getCurrentUri(), BrowserUtils.getCurrentUri());\n      }\n    } else {\n      this.logger.verbose(\"postLogoutRedirectUri passed as null, not setting post logout redirect uri\", validLogoutRequest.correlationId);\n    }\n    return validLogoutRequest;\n  }\n  /**\n   * Parses login_hint ID Token Claim out of AccountInfo object to be used as\n   * logout_hint in end session request.\n   * @param account\n   */\n  getLogoutHintFromIdTokenClaims(account) {\n    const idTokenClaims = account.idTokenClaims;\n    if (idTokenClaims) {\n      if (idTokenClaims.login_hint) {\n        return idTokenClaims.login_hint;\n      } else {\n        this.logger.verbose(\"The ID Token Claims tied to the provided account do not contain a login_hint claim, logoutHint will not be added to logout request\");\n      }\n    } else {\n      this.logger.verbose(\"The provided account does not contain ID Token Claims, logoutHint will not be added to logout request\");\n    }\n    return null;\n  }\n  /**\n   * Creates an Authorization Code Client with the given authority, or the default authority.\n   * @param serverTelemetryManager\n   * @param authorityUrl\n   */\n  async createAuthCodeClient(serverTelemetryManager, authorityUrl, requestAzureCloudOptions) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.correlationId);\n    // Create auth module.\n    this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.correlationId);\n    const clientConfig = await this.getClientConfiguration(serverTelemetryManager, authorityUrl, requestAzureCloudOptions);\n    return new AuthorizationCodeClient(clientConfig, this.performanceClient);\n  }\n  /**\n   * Creates a Client Configuration object with the given request authority, or the default authority.\n   * @param serverTelemetryManager\n   * @param requestAuthority\n   * @param requestCorrelationId\n   */\n  async getClientConfiguration(serverTelemetryManager, requestAuthority, requestAzureCloudOptions) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientGetClientConfiguration, this.correlationId);\n    this.logger.verbose(\"getClientConfiguration called\", this.correlationId);\n    this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.correlationId);\n    const discoveredAuthority = await this.getDiscoveredAuthority(requestAuthority, requestAzureCloudOptions);\n    const logger = this.config.system.loggerOptions;\n    return {\n      authOptions: {\n        clientId: this.config.auth.clientId,\n        authority: discoveredAuthority,\n        clientCapabilities: this.config.auth.clientCapabilities\n      },\n      systemOptions: {\n        tokenRenewalOffsetSeconds: this.config.system.tokenRenewalOffsetSeconds,\n        preventCorsPreflight: true\n      },\n      loggerOptions: {\n        loggerCallback: logger.loggerCallback,\n        piiLoggingEnabled: logger.piiLoggingEnabled,\n        logLevel: logger.logLevel,\n        correlationId: this.correlationId\n      },\n      cacheOptions: {\n        claimsBasedCachingEnabled: this.config.cache.claimsBasedCachingEnabled\n      },\n      cryptoInterface: this.browserCrypto,\n      networkInterface: this.networkClient,\n      storageInterface: this.browserStorage,\n      serverTelemetryManager: serverTelemetryManager,\n      libraryInfo: {\n        sku: BrowserConstants.MSAL_SKU,\n        version: version,\n        cpu: Constants.EMPTY_STRING,\n        os: Constants.EMPTY_STRING\n      },\n      telemetry: this.config.telemetry\n    };\n  }\n  /**\n   * @param hash\n   * @param interactionType\n   */\n  validateAndExtractStateFromHash(serverParams, interactionType, requestCorrelationId) {\n    this.logger.verbose(\"validateAndExtractStateFromHash called\", requestCorrelationId);\n    if (!serverParams.state) {\n      throw createBrowserAuthError(noStateInHash);\n    }\n    const platformStateObj = BrowserProtocolUtils.extractBrowserRequestState(this.browserCrypto, serverParams.state);\n    if (!platformStateObj) {\n      throw createBrowserAuthError(unableToParseState);\n    }\n    if (platformStateObj.interactionType !== interactionType) {\n      throw createBrowserAuthError(stateInteractionTypeMismatch);\n    }\n    this.logger.verbose(\"Returning state from hash\", requestCorrelationId);\n    return serverParams.state;\n  }\n  /**\n   * Used to get a discovered version of the default authority.\n   * @param requestAuthority\n   * @param requestCorrelationId\n   */\n  async getDiscoveredAuthority(requestAuthority, requestAzureCloudOptions) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.correlationId);\n    this.logger.verbose(\"getDiscoveredAuthority called\", this.correlationId);\n    const getAuthorityMeasurement = this.performanceClient?.startMeasurement(PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority, this.correlationId);\n    const authorityOptions = {\n      protocolMode: this.config.auth.protocolMode,\n      OIDCOptions: this.config.auth.OIDCOptions,\n      knownAuthorities: this.config.auth.knownAuthorities,\n      cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n      authorityMetadata: this.config.auth.authorityMetadata,\n      skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache\n    };\n    // build authority string based on auth params, precedence - azureCloudInstance + tenant >> authority\n    const userAuthority = requestAuthority ? requestAuthority : this.config.auth.authority;\n    // fall back to the authority from config\n    const builtAuthority = Authority.generateAuthority(userAuthority, requestAzureCloudOptions || this.config.auth.azureCloudOptions);\n    this.logger.verbose(\"Creating discovered authority with configured authority\", this.correlationId);\n    this.performanceClient.setPreQueueTime(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, this.correlationId);\n    return await AuthorityFactory.createDiscoveredInstance(builtAuthority, this.config.system.networkClient, this.browserStorage, authorityOptions, this.logger, this.performanceClient, this.correlationId).then(result => {\n      getAuthorityMeasurement.end({\n        success: true\n      });\n      return result;\n    }).catch(error => {\n      getAuthorityMeasurement.end({\n        errorCode: error.errorCode,\n        subErrorCode: error.subError,\n        success: false\n      });\n      throw error;\n    });\n  }\n  /**\n   * Helper to initialize required request parameters for interactive APIs and ssoSilent()\n   * @param request\n   * @param interactionType\n   */\n  async initializeAuthorizationRequest(request, interactionType) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.correlationId);\n    this.logger.verbose(\"initializeAuthorizationRequest called\", this.correlationId);\n    const redirectUri = this.getRedirectUri(request.redirectUri);\n    const browserState = {\n      interactionType: interactionType\n    };\n    const state = ProtocolUtils.setRequestState(this.browserCrypto, request && request.state || Constants.EMPTY_STRING, browserState);\n    this.performanceClient.setPreQueueTime(PerformanceEvents.InitializeBaseRequest, this.correlationId);\n    const validatedRequest = {\n      ...(await this.initializeBaseRequest(request)),\n      redirectUri: redirectUri,\n      state: state,\n      nonce: request.nonce || this.browserCrypto.createNewGuid(),\n      responseMode: this.config.auth.OIDCOptions.serverResponseType\n    };\n    const account = request.account || this.browserStorage.getActiveAccount();\n    if (account) {\n      this.logger.verbose(\"Setting validated request account\", this.correlationId);\n      this.logger.verbosePii(`Setting validated request account: ${account.homeAccountId}`, this.correlationId);\n      validatedRequest.account = account;\n    }\n    // Check for ADAL/MSAL v1 SSO\n    if (!validatedRequest.loginHint && !account) {\n      const legacyLoginHint = this.browserStorage.getLegacyLoginHint();\n      if (legacyLoginHint) {\n        validatedRequest.loginHint = legacyLoginHint;\n      }\n    }\n    return validatedRequest;\n  }\n}\nexport { StandardInteractionClient };","map":{"version":3,"names":["performanceClient","addQueueMeasurement","PerformanceEvents","StandardInteractionClientInitializeAuthorizationCodeRequest","request","correlationId","logger","verbose","generatedPkceParams","browserCrypto","generatePkceCodes","code","Constants","EMPTY_STRING","codeVerifier","verifier","validLogoutRequest","createNewGuid","logoutRequest","account","logoutHint","getLogoutHintFromIdTokenClaims"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\interaction_client\\StandardInteractionClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    ServerTelemetryManager,\n    CommonAuthorizationCodeRequest,\n    Constants,\n    AuthorizationCodeClient,\n    ClientConfiguration,\n    AuthorityOptions,\n    Authority,\n    AuthorityFactory,\n    ServerAuthorizationCodeResponse,\n    UrlString,\n    CommonEndSessionRequest,\n    ProtocolUtils,\n    ResponseMode,\n    IdTokenClaims,\n    AccountInfo,\n    AzureCloudOptions,\n    PerformanceEvents,\n    AuthError,\n} from \"@azure/msal-common\";\nimport { BaseInteractionClient } from \"./BaseInteractionClient\";\nimport { AuthorizationUrlRequest } from \"../request/AuthorizationUrlRequest\";\nimport { BrowserConstants, InteractionType } from \"../utils/BrowserConstants\";\nimport { version } from \"../packageMetadata\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError\";\nimport {\n    BrowserProtocolUtils,\n    BrowserStateObject,\n} from \"../utils/BrowserProtocolUtils\";\nimport { EndSessionRequest } from \"../request/EndSessionRequest\";\nimport { BrowserUtils } from \"../utils/BrowserUtils\";\nimport { RedirectRequest } from \"../request/RedirectRequest\";\nimport { PopupRequest } from \"../request/PopupRequest\";\nimport { SsoSilentRequest } from \"../request/SsoSilentRequest\";\n\n/**\n * Defines the class structure and helper functions used by the \"standard\", non-brokered auth flows (popup, redirect, silent (RT), silent (iframe))\n */\nexport abstract class StandardInteractionClient extends BaseInteractionClient {\n    /**\n     * Generates an auth code request tied to the url request.\n     * @param request\n     */\n    protected async initializeAuthorizationCodeRequest(\n        request: AuthorizationUrlRequest\n    ): Promise<CommonAuthorizationCodeRequest> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest,\n            request.correlationId\n        );\n        this.logger.verbose(\n            \"initializeAuthorizationRequest called\",\n            request.correlationId\n        );\n        const generatedPkceParams =\n            await this.browserCrypto.generatePkceCodes();\n\n        const authCodeRequest: CommonAuthorizationCodeRequest = {\n            ...request,\n            redirectUri: request.redirectUri,\n            code: Constants.EMPTY_STRING,\n            codeVerifier: generatedPkceParams.verifier,\n        };\n\n        request.codeChallenge = generatedPkceParams.challenge;\n        request.codeChallengeMethod = Constants.S256_CODE_CHALLENGE_METHOD;\n\n        return authCodeRequest;\n    }\n\n    /**\n     * Initializer for the logout request.\n     * @param logoutRequest\n     */\n    protected initializeLogoutRequest(\n        logoutRequest?: EndSessionRequest\n    ): CommonEndSessionRequest {\n        this.logger.verbose(\n            \"initializeLogoutRequest called\",\n            logoutRequest?.correlationId\n        );\n\n        const validLogoutRequest: CommonEndSessionRequest = {\n            correlationId:\n                this.correlationId || this.browserCrypto.createNewGuid(),\n            ...logoutRequest,\n        };\n\n        /**\n         * Set logout_hint to be login_hint from ID Token Claims if present\n         * and logoutHint attribute wasn't manually set in logout request\n         */\n        if (logoutRequest) {\n            // If logoutHint isn't set and an account was passed in, try to extract logoutHint from ID Token Claims\n            if (!logoutRequest.logoutHint) {\n                if (logoutRequest.account) {\n                    const logoutHint = this.getLogoutHintFromIdTokenClaims(\n                        logoutRequest.account\n                    );\n                    if (logoutHint) {\n                        this.logger.verbose(\n                            \"Setting logoutHint to login_hint ID Token Claim value for the account provided\"\n                        );\n                        validLogoutRequest.logoutHint = logoutHint;\n                    }\n                } else {\n                    this.logger.verbose(\n                        \"logoutHint was not set and account was not passed into logout request, logoutHint will not be set\"\n                    );\n                }\n            } else {\n                this.logger.verbose(\n                    \"logoutHint has already been set in logoutRequest\"\n                );\n            }\n        } else {\n            this.logger.verbose(\n                \"logoutHint will not be set since no logout request was configured\"\n            );\n        }\n\n        /*\n         * Only set redirect uri if logout request isn't provided or the set uri isn't null.\n         * Otherwise, use passed uri, config, or current page.\n         */\n        if (!logoutRequest || logoutRequest.postLogoutRedirectUri !== null) {\n            if (logoutRequest && logoutRequest.postLogoutRedirectUri) {\n                this.logger.verbose(\n                    \"Setting postLogoutRedirectUri to uri set on logout request\",\n                    validLogoutRequest.correlationId\n                );\n                validLogoutRequest.postLogoutRedirectUri =\n                    UrlString.getAbsoluteUrl(\n                        logoutRequest.postLogoutRedirectUri,\n                        BrowserUtils.getCurrentUri()\n                    );\n            } else if (this.config.auth.postLogoutRedirectUri === null) {\n                this.logger.verbose(\n                    \"postLogoutRedirectUri configured as null and no uri set on request, not passing post logout redirect\",\n                    validLogoutRequest.correlationId\n                );\n            } else if (this.config.auth.postLogoutRedirectUri) {\n                this.logger.verbose(\n                    \"Setting postLogoutRedirectUri to configured uri\",\n                    validLogoutRequest.correlationId\n                );\n                validLogoutRequest.postLogoutRedirectUri =\n                    UrlString.getAbsoluteUrl(\n                        this.config.auth.postLogoutRedirectUri,\n                        BrowserUtils.getCurrentUri()\n                    );\n            } else {\n                this.logger.verbose(\n                    \"Setting postLogoutRedirectUri to current page\",\n                    validLogoutRequest.correlationId\n                );\n                validLogoutRequest.postLogoutRedirectUri =\n                    UrlString.getAbsoluteUrl(\n                        BrowserUtils.getCurrentUri(),\n                        BrowserUtils.getCurrentUri()\n                    );\n            }\n        } else {\n            this.logger.verbose(\n                \"postLogoutRedirectUri passed as null, not setting post logout redirect uri\",\n                validLogoutRequest.correlationId\n            );\n        }\n\n        return validLogoutRequest;\n    }\n\n    /**\n     * Parses login_hint ID Token Claim out of AccountInfo object to be used as\n     * logout_hint in end session request.\n     * @param account\n     */\n    protected getLogoutHintFromIdTokenClaims(\n        account: AccountInfo\n    ): string | null {\n        const idTokenClaims: IdTokenClaims | undefined = account.idTokenClaims;\n        if (idTokenClaims) {\n            if (idTokenClaims.login_hint) {\n                return idTokenClaims.login_hint;\n            } else {\n                this.logger.verbose(\n                    \"The ID Token Claims tied to the provided account do not contain a login_hint claim, logoutHint will not be added to logout request\"\n                );\n            }\n        } else {\n            this.logger.verbose(\n                \"The provided account does not contain ID Token Claims, logoutHint will not be added to logout request\"\n            );\n        }\n\n        return null;\n    }\n\n    /**\n     * Creates an Authorization Code Client with the given authority, or the default authority.\n     * @param serverTelemetryManager\n     * @param authorityUrl\n     */\n    protected async createAuthCodeClient(\n        serverTelemetryManager: ServerTelemetryManager,\n        authorityUrl?: string,\n        requestAzureCloudOptions?: AzureCloudOptions\n    ): Promise<AuthorizationCodeClient> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,\n            this.correlationId\n        );\n        // Create auth module.\n        this.performanceClient.setPreQueueTime(\n            PerformanceEvents.StandardInteractionClientGetClientConfiguration,\n            this.correlationId\n        );\n        const clientConfig = await this.getClientConfiguration(\n            serverTelemetryManager,\n            authorityUrl,\n            requestAzureCloudOptions\n        );\n        return new AuthorizationCodeClient(\n            clientConfig,\n            this.performanceClient\n        );\n    }\n\n    /**\n     * Creates a Client Configuration object with the given request authority, or the default authority.\n     * @param serverTelemetryManager\n     * @param requestAuthority\n     * @param requestCorrelationId\n     */\n    protected async getClientConfiguration(\n        serverTelemetryManager: ServerTelemetryManager,\n        requestAuthority?: string,\n        requestAzureCloudOptions?: AzureCloudOptions\n    ): Promise<ClientConfiguration> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.StandardInteractionClientGetClientConfiguration,\n            this.correlationId\n        );\n        this.logger.verbose(\n            \"getClientConfiguration called\",\n            this.correlationId\n        );\n        this.performanceClient.setPreQueueTime(\n            PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority,\n            this.correlationId\n        );\n        const discoveredAuthority = await this.getDiscoveredAuthority(\n            requestAuthority,\n            requestAzureCloudOptions\n        );\n        const logger = this.config.system.loggerOptions;\n\n        return {\n            authOptions: {\n                clientId: this.config.auth.clientId,\n                authority: discoveredAuthority,\n                clientCapabilities: this.config.auth.clientCapabilities,\n            },\n            systemOptions: {\n                tokenRenewalOffsetSeconds:\n                    this.config.system.tokenRenewalOffsetSeconds,\n                preventCorsPreflight: true,\n            },\n            loggerOptions: {\n                loggerCallback: logger.loggerCallback,\n                piiLoggingEnabled: logger.piiLoggingEnabled,\n                logLevel: logger.logLevel,\n                correlationId: this.correlationId,\n            },\n            cacheOptions: {\n                claimsBasedCachingEnabled:\n                    this.config.cache.claimsBasedCachingEnabled,\n            },\n            cryptoInterface: this.browserCrypto,\n            networkInterface: this.networkClient,\n            storageInterface: this.browserStorage,\n            serverTelemetryManager: serverTelemetryManager,\n            libraryInfo: {\n                sku: BrowserConstants.MSAL_SKU,\n                version: version,\n                cpu: Constants.EMPTY_STRING,\n                os: Constants.EMPTY_STRING,\n            },\n            telemetry: this.config.telemetry,\n        };\n    }\n\n    /**\n     * @param hash\n     * @param interactionType\n     */\n    protected validateAndExtractStateFromHash(\n        serverParams: ServerAuthorizationCodeResponse,\n        interactionType: InteractionType,\n        requestCorrelationId?: string\n    ): string {\n        this.logger.verbose(\n            \"validateAndExtractStateFromHash called\",\n            requestCorrelationId\n        );\n        if (!serverParams.state) {\n            throw createBrowserAuthError(BrowserAuthErrorCodes.noStateInHash);\n        }\n\n        const platformStateObj =\n            BrowserProtocolUtils.extractBrowserRequestState(\n                this.browserCrypto,\n                serverParams.state\n            );\n        if (!platformStateObj) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.unableToParseState\n            );\n        }\n\n        if (platformStateObj.interactionType !== interactionType) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.stateInteractionTypeMismatch\n            );\n        }\n\n        this.logger.verbose(\"Returning state from hash\", requestCorrelationId);\n        return serverParams.state;\n    }\n\n    /**\n     * Used to get a discovered version of the default authority.\n     * @param requestAuthority\n     * @param requestCorrelationId\n     */\n    protected async getDiscoveredAuthority(\n        requestAuthority?: string,\n        requestAzureCloudOptions?: AzureCloudOptions\n    ): Promise<Authority> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority,\n            this.correlationId\n        );\n        this.logger.verbose(\n            \"getDiscoveredAuthority called\",\n            this.correlationId\n        );\n        const getAuthorityMeasurement =\n            this.performanceClient?.startMeasurement(\n                PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority,\n                this.correlationId\n            );\n        const authorityOptions: AuthorityOptions = {\n            protocolMode: this.config.auth.protocolMode,\n            OIDCOptions: this.config.auth.OIDCOptions,\n            knownAuthorities: this.config.auth.knownAuthorities,\n            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n            authorityMetadata: this.config.auth.authorityMetadata,\n            skipAuthorityMetadataCache:\n                this.config.auth.skipAuthorityMetadataCache,\n        };\n\n        // build authority string based on auth params, precedence - azureCloudInstance + tenant >> authority\n        const userAuthority = requestAuthority\n            ? requestAuthority\n            : this.config.auth.authority;\n\n        // fall back to the authority from config\n        const builtAuthority = Authority.generateAuthority(\n            userAuthority,\n            requestAzureCloudOptions || this.config.auth.azureCloudOptions\n        );\n        this.logger.verbose(\n            \"Creating discovered authority with configured authority\",\n            this.correlationId\n        );\n        this.performanceClient.setPreQueueTime(\n            PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance,\n            this.correlationId\n        );\n        return await AuthorityFactory.createDiscoveredInstance(\n            builtAuthority,\n            this.config.system.networkClient,\n            this.browserStorage,\n            authorityOptions,\n            this.logger,\n            this.performanceClient,\n            this.correlationId\n        )\n            .then((result: Authority) => {\n                getAuthorityMeasurement.end({\n                    success: true,\n                });\n\n                return result;\n            })\n            .catch((error: AuthError) => {\n                getAuthorityMeasurement.end({\n                    errorCode: error.errorCode,\n                    subErrorCode: error.subError,\n                    success: false,\n                });\n\n                throw error;\n            });\n    }\n\n    /**\n     * Helper to initialize required request parameters for interactive APIs and ssoSilent()\n     * @param request\n     * @param interactionType\n     */\n    protected async initializeAuthorizationRequest(\n        request: RedirectRequest | PopupRequest | SsoSilentRequest,\n        interactionType: InteractionType\n    ): Promise<AuthorizationUrlRequest> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest,\n            this.correlationId\n        );\n        this.logger.verbose(\n            \"initializeAuthorizationRequest called\",\n            this.correlationId\n        );\n        const redirectUri = this.getRedirectUri(request.redirectUri);\n        const browserState: BrowserStateObject = {\n            interactionType: interactionType,\n        };\n        const state = ProtocolUtils.setRequestState(\n            this.browserCrypto,\n            (request && request.state) || Constants.EMPTY_STRING,\n            browserState\n        );\n\n        this.performanceClient.setPreQueueTime(\n            PerformanceEvents.InitializeBaseRequest,\n            this.correlationId\n        );\n\n        const validatedRequest: AuthorizationUrlRequest = {\n            ...(await this.initializeBaseRequest(request)),\n            redirectUri: redirectUri,\n            state: state,\n            nonce: request.nonce || this.browserCrypto.createNewGuid(),\n            responseMode: this.config.auth.OIDCOptions\n                .serverResponseType as ResponseMode,\n        };\n\n        const account =\n            request.account || this.browserStorage.getActiveAccount();\n        if (account) {\n            this.logger.verbose(\n                \"Setting validated request account\",\n                this.correlationId\n            );\n            this.logger.verbosePii(\n                `Setting validated request account: ${account.homeAccountId}`,\n                this.correlationId\n            );\n            validatedRequest.account = account;\n        }\n\n        // Check for ADAL/MSAL v1 SSO\n        if (!validatedRequest.loginHint && !account) {\n            const legacyLoginHint = this.browserStorage.getLegacyLoginHint();\n            if (legacyLoginHint) {\n                validatedRequest.loginHint = legacyLoginHint;\n            }\n        }\n\n        return validatedRequest;\n    }\n}\n"],"mappings":";;;;;;;;;;;;AAKA;AAoBA;AACA;AACA;AAmBA;AACI;;;EAGG;;AA4BH;;;IAGG,KAAAA,iBAAA,CAAAC,mBAAA,CAAAC,iBAAA,CAAAC,2DAAA,EAAAC,OAAA,CAAAC,aAAA;IACM,KAAAC,MAAA,CAAAC,OAAA,wCACW,EAAAH,OACM,CAAAC,aAAA;IAgG1B,MAAAG,mBAAA,cAAAC,aAAA,CAAAC,iBAAA;;;;MAIGC,IAAA,EAAAC,SAAA,CAAAC,YAAA;MACMC,YAAA,EAAAN,mBACL,CAAAO;IAoBJ;;;;EAIG;EACa;AAyBhB;;;;;IAKG,MAAAC,kBAAA;MACaX,aAAA,OAAAA,aACU,SAAAI,aAAA,CAAAQ,aAAA,EAAwB;MAyDlD,GAAAC;;;AAGG;AACH;AAkCA;;;;QAIG,IAAAA,aAAA,CAAAC,OAAA;UACa,MAAAC,UAAsB,GAClC,KAAAC,8BACA,CAAAH,aAAwB,CAACC,OAAmB;UAsEhD,IAAAC,UAAA;;;;QAIG,OACa;UA4DnB,KAAAd,MAAA,CAAAC,OAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}