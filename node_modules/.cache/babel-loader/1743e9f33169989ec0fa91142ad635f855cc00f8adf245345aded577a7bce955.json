{"ast":null,"code":"/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\n\nimport { ClientAuthError, ServerError } from '@azure/msal-common';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { TemporaryCacheKeys, ApiId } from '../utils/BrowserConstants.mjs';\nimport { InteractionHandler } from './InteractionHandler.mjs';\nimport { emptyNavigateUri, hashEmptyError, userCancelled } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass RedirectHandler extends InteractionHandler {\n  constructor(authCodeModule, storageImpl, authCodeRequest, logger, browserCrypto, performanceClient) {\n    super(authCodeModule, storageImpl, authCodeRequest, logger, performanceClient);\n    this.browserCrypto = browserCrypto;\n  }\n  /**\n   * Redirects window to given URL.\n   * @param urlNavigate\n   */\n  async initiateAuthRequest(requestUrl, params) {\n    this.logger.verbose(\"RedirectHandler.initiateAuthRequest called\");\n    // Navigate if valid URL\n    if (requestUrl) {\n      // Cache start page, returns to this page after redirectUri if navigateToLoginRequestUrl is true\n      if (params.redirectStartPage) {\n        this.logger.verbose(\"RedirectHandler.initiateAuthRequest: redirectStartPage set, caching start page\");\n        this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, params.redirectStartPage, true);\n      }\n      // Set interaction status in the library.\n      this.browserStorage.setTemporaryCache(TemporaryCacheKeys.CORRELATION_ID, this.authCodeRequest.correlationId, true);\n      this.browserStorage.cacheCodeRequest(this.authCodeRequest);\n      this.logger.infoPii(`RedirectHandler.initiateAuthRequest: Navigate to: ${requestUrl}`);\n      const navigationOptions = {\n        apiId: ApiId.acquireTokenRedirect,\n        timeout: params.redirectTimeout,\n        noHistory: false\n      };\n      // If onRedirectNavigate is implemented, invoke it and provide requestUrl\n      if (typeof params.onRedirectNavigate === \"function\") {\n        this.logger.verbose(\"RedirectHandler.initiateAuthRequest: Invoking onRedirectNavigate callback\");\n        const navigate = params.onRedirectNavigate(requestUrl);\n        // Returning false from onRedirectNavigate will stop navigation\n        if (navigate !== false) {\n          this.logger.verbose(\"RedirectHandler.initiateAuthRequest: onRedirectNavigate did not return false, navigating\");\n          await params.navigationClient.navigateExternal(requestUrl, navigationOptions);\n          return;\n        } else {\n          this.logger.verbose(\"RedirectHandler.initiateAuthRequest: onRedirectNavigate returned false, stopping navigation\");\n          return;\n        }\n      } else {\n        // Navigate window to request URL\n        this.logger.verbose(\"RedirectHandler.initiateAuthRequest: Navigating window to navigate url\");\n        await params.navigationClient.navigateExternal(requestUrl, navigationOptions);\n        return;\n      }\n    } else {\n      // Throw error if request URL is empty.\n      this.logger.info(\"RedirectHandler.initiateAuthRequest: Navigate url is empty\");\n      throw createBrowserAuthError(emptyNavigateUri);\n    }\n  }\n  /**\n   * Handle authorization code response in the window.\n   * @param hash\n   */\n  async handleCodeResponseFromHash(locationHash, state, authority, networkModule) {\n    this.logger.verbose(\"RedirectHandler.handleCodeResponse called\");\n    // Check that location hash isn't empty.\n    if (!locationHash) {\n      throw createBrowserAuthError(hashEmptyError);\n    }\n    // Interaction is completed - remove interaction status.\n    this.browserStorage.setInteractionInProgress(false);\n    // Handle code response.\n    const stateKey = this.browserStorage.generateStateKey(state);\n    const requestState = this.browserStorage.getTemporaryCache(stateKey);\n    if (!requestState) {\n      throw ClientAuthError.createStateNotFoundError(\"Cached State\");\n    }\n    let authCodeResponse;\n    try {\n      authCodeResponse = this.authModule.handleFragmentResponse(locationHash, requestState);\n    } catch (e) {\n      if (e instanceof ServerError && e.subError === userCancelled) {\n        // Translate server error caused by user closing native prompt to corresponding first class MSAL error\n        throw createBrowserAuthError(userCancelled);\n      } else {\n        throw e;\n      }\n    }\n    // Get cached items\n    const nonceKey = this.browserStorage.generateNonceKey(requestState);\n    const cachedNonce = this.browserStorage.getTemporaryCache(nonceKey);\n    // Assign code to request\n    this.authCodeRequest.code = authCodeResponse.code;\n    // Check for new cloud instance\n    if (authCodeResponse.cloud_instance_host_name) {\n      await this.updateTokenEndpointAuthority(authCodeResponse.cloud_instance_host_name, authority, networkModule);\n    }\n    authCodeResponse.nonce = cachedNonce || undefined;\n    authCodeResponse.state = requestState;\n    // Add CCS parameters if available\n    if (authCodeResponse.client_info) {\n      this.authCodeRequest.clientInfo = authCodeResponse.client_info;\n    } else {\n      const cachedCcsCred = this.checkCcsCredentials();\n      if (cachedCcsCred) {\n        this.authCodeRequest.ccsCredential = cachedCcsCred;\n      }\n    }\n    // Acquire token with retrieved code.\n    const tokenResponse = await this.authModule.acquireToken(this.authCodeRequest, authCodeResponse);\n    this.browserStorage.cleanRequestByState(state);\n    return tokenResponse;\n  }\n}\nexport { RedirectHandler };","map":{"version":3,"names":["RedirectHandler","InteractionHandler","constructor","authCodeModule","storageImpl","authCodeRequest","logger","browserCrypto","performanceClient","initiateAuthRequest","requestUrl","params","verbose","redirectStartPage","browserStorage","setTemporaryCache","TemporaryCacheKeys","ORIGIN_URI"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\interaction_handler\\RedirectHandler.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AuthorizationCodeClient,\n    CommonAuthorizationCodeRequest,\n    ICrypto,\n    Authority,\n    INetworkModule,\n    ClientAuthError,\n    Logger,\n    ServerError,\n    IPerformanceClient,\n} from \"@azure/msal-common\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError\";\nimport { ApiId, TemporaryCacheKeys } from \"../utils/BrowserConstants\";\nimport { BrowserCacheManager } from \"../cache/BrowserCacheManager\";\nimport { InteractionHandler, InteractionParams } from \"./InteractionHandler\";\nimport { INavigationClient } from \"../navigation/INavigationClient\";\nimport { NavigationOptions } from \"../navigation/NavigationOptions\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\n\nexport type RedirectParams = InteractionParams & {\n    navigationClient: INavigationClient;\n    redirectTimeout: number;\n    redirectStartPage: string;\n    onRedirectNavigate?: (url: string) => void | boolean;\n};\n\nexport class RedirectHandler extends InteractionHandler {\n    private browserCrypto: ICrypto;\n\n    constructor(\n        authCodeModule: AuthorizationCodeClient,\n        storageImpl: BrowserCacheManager,\n        authCodeRequest: CommonAuthorizationCodeRequest,\n        logger: Logger,\n        browserCrypto: ICrypto,\n        performanceClient: IPerformanceClient\n    ) {\n        super(\n            authCodeModule,\n            storageImpl,\n            authCodeRequest,\n            logger,\n            performanceClient\n        );\n        this.browserCrypto = browserCrypto;\n    }\n\n    /**\n     * Redirects window to given URL.\n     * @param urlNavigate\n     */\n    async initiateAuthRequest(\n        requestUrl: string,\n        params: RedirectParams\n    ): Promise<void> {\n        this.logger.verbose(\"RedirectHandler.initiateAuthRequest called\");\n        // Navigate if valid URL\n        if (requestUrl) {\n            // Cache start page, returns to this page after redirectUri if navigateToLoginRequestUrl is true\n            if (params.redirectStartPage) {\n                this.logger.verbose(\n                    \"RedirectHandler.initiateAuthRequest: redirectStartPage set, caching start page\"\n                );\n                this.browserStorage.setTemporaryCache(\n                    TemporaryCacheKeys.ORIGIN_URI,\n                    params.redirectStartPage,\n                    true\n                );\n            }\n\n            // Set interaction status in the library.\n            this.browserStorage.setTemporaryCache(\n                TemporaryCacheKeys.CORRELATION_ID,\n                this.authCodeRequest.correlationId,\n                true\n            );\n            this.browserStorage.cacheCodeRequest(this.authCodeRequest);\n            this.logger.infoPii(\n                `RedirectHandler.initiateAuthRequest: Navigate to: ${requestUrl}`\n            );\n            const navigationOptions: NavigationOptions = {\n                apiId: ApiId.acquireTokenRedirect,\n                timeout: params.redirectTimeout,\n                noHistory: false,\n            };\n\n            // If onRedirectNavigate is implemented, invoke it and provide requestUrl\n            if (typeof params.onRedirectNavigate === \"function\") {\n                this.logger.verbose(\n                    \"RedirectHandler.initiateAuthRequest: Invoking onRedirectNavigate callback\"\n                );\n                const navigate = params.onRedirectNavigate(requestUrl);\n\n                // Returning false from onRedirectNavigate will stop navigation\n                if (navigate !== false) {\n                    this.logger.verbose(\n                        \"RedirectHandler.initiateAuthRequest: onRedirectNavigate did not return false, navigating\"\n                    );\n                    await params.navigationClient.navigateExternal(\n                        requestUrl,\n                        navigationOptions\n                    );\n                    return;\n                } else {\n                    this.logger.verbose(\n                        \"RedirectHandler.initiateAuthRequest: onRedirectNavigate returned false, stopping navigation\"\n                    );\n                    return;\n                }\n            } else {\n                // Navigate window to request URL\n                this.logger.verbose(\n                    \"RedirectHandler.initiateAuthRequest: Navigating window to navigate url\"\n                );\n                await params.navigationClient.navigateExternal(\n                    requestUrl,\n                    navigationOptions\n                );\n                return;\n            }\n        } else {\n            // Throw error if request URL is empty.\n            this.logger.info(\n                \"RedirectHandler.initiateAuthRequest: Navigate url is empty\"\n            );\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.emptyNavigateUri\n            );\n        }\n    }\n\n    /**\n     * Handle authorization code response in the window.\n     * @param hash\n     */\n    async handleCodeResponseFromHash(\n        locationHash: string,\n        state: string,\n        authority: Authority,\n        networkModule: INetworkModule\n    ): Promise<AuthenticationResult> {\n        this.logger.verbose(\"RedirectHandler.handleCodeResponse called\");\n\n        // Check that location hash isn't empty.\n        if (!locationHash) {\n            throw createBrowserAuthError(BrowserAuthErrorCodes.hashEmptyError);\n        }\n\n        // Interaction is completed - remove interaction status.\n        this.browserStorage.setInteractionInProgress(false);\n\n        // Handle code response.\n        const stateKey = this.browserStorage.generateStateKey(state);\n        const requestState = this.browserStorage.getTemporaryCache(stateKey);\n        if (!requestState) {\n            throw ClientAuthError.createStateNotFoundError(\"Cached State\");\n        }\n\n        let authCodeResponse;\n        try {\n            authCodeResponse = this.authModule.handleFragmentResponse(\n                locationHash,\n                requestState\n            );\n        } catch (e) {\n            if (\n                e instanceof ServerError &&\n                e.subError === BrowserAuthErrorCodes.userCancelled\n            ) {\n                // Translate server error caused by user closing native prompt to corresponding first class MSAL error\n                throw createBrowserAuthError(\n                    BrowserAuthErrorCodes.userCancelled\n                );\n            } else {\n                throw e;\n            }\n        }\n\n        // Get cached items\n        const nonceKey = this.browserStorage.generateNonceKey(requestState);\n        const cachedNonce = this.browserStorage.getTemporaryCache(nonceKey);\n\n        // Assign code to request\n        this.authCodeRequest.code = authCodeResponse.code;\n\n        // Check for new cloud instance\n        if (authCodeResponse.cloud_instance_host_name) {\n            await this.updateTokenEndpointAuthority(\n                authCodeResponse.cloud_instance_host_name,\n                authority,\n                networkModule\n            );\n        }\n\n        authCodeResponse.nonce = cachedNonce || undefined;\n        authCodeResponse.state = requestState;\n\n        // Add CCS parameters if available\n        if (authCodeResponse.client_info) {\n            this.authCodeRequest.clientInfo = authCodeResponse.client_info;\n        } else {\n            const cachedCcsCred = this.checkCcsCredentials();\n            if (cachedCcsCred) {\n                this.authCodeRequest.ccsCredential = cachedCcsCred;\n            }\n        }\n\n        // Acquire token with retrieved code.\n        const tokenResponse = (await this.authModule.acquireToken(\n            this.authCodeRequest,\n            authCodeResponse\n        )) as AuthenticationResult;\n\n        this.browserStorage.cleanRequestByState(state);\n        return tokenResponse;\n    }\n}\n"],"mappings":";;;;;;;;;AAKA;AAgBA;AACA;AACA;AAOqB,MAAAA,eAAA,SAASC,kBAAA;EAC1BC,WAAkBA,CAAAC,cAAO,EAAAC,WAAa,EAAAC,eAAe,EAAAC,MAAA,EAAAC,aAAA,EAAAC,iBAAA;IACvD,MAAAL,cAAA,EAAAC,WAAA,EAAAC,eAAA,EAAAC,MAAA,EAAAE,iBAAA;IAEW,KAAAD,aAAA,GAAAA,aAAA;;;AAqBT;;;EAGG,MAAAE,oBAAAC,UAAA,EAAAC,MAAA;IACG,KAAAL,MAAA,CAAAM,OACF,6CAED;IA6EH;;;MAGG,IAAAD,MAAA,CAAAE,iBAAA;QAC6B,KAAAP,MAAA,CAAAM,OAAA,iFAIb;QA6EtB,KAAAE,cAAA,CAAAC,iBAAA,CAAAC,kBAAA,CAAAC,UAAA,EAAAN,MAAA,CAAAE,iBAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}