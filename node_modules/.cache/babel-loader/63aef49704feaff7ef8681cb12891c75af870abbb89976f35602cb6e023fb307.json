{"ast":null,"code":"/*! @azure/msal-common v14.0.3 2023-09-05 */\n'use strict';\n\nimport { buildClientInfo } from '../account/ClientInfo.mjs';\nimport { ClientAuthError } from '../error/ClientAuthError.mjs';\nimport { ServerError } from '../error/ServerError.mjs';\nimport { ScopeSet } from '../request/ScopeSet.mjs';\nimport { AccountEntity } from '../cache/entities/AccountEntity.mjs';\nimport { IdTokenEntity } from '../cache/entities/IdTokenEntity.mjs';\nimport { AccessTokenEntity } from '../cache/entities/AccessTokenEntity.mjs';\nimport { RefreshTokenEntity } from '../cache/entities/RefreshTokenEntity.mjs';\nimport { InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.mjs';\nimport { CacheRecord } from '../cache/entities/CacheRecord.mjs';\nimport { ProtocolUtils } from '../utils/ProtocolUtils.mjs';\nimport { Constants, HttpStatus, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.mjs';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.mjs';\nimport { AppMetadataEntity } from '../cache/entities/AppMetadataEntity.mjs';\nimport { TokenCacheContext } from '../cache/persistence/TokenCacheContext.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { extractTokenClaims, checkMaxAge } from '../account/AuthToken.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Class that handles response parsing.\n * @internal\n */\nclass ResponseHandler {\n  constructor(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {\n    this.clientId = clientId;\n    this.cacheStorage = cacheStorage;\n    this.cryptoObj = cryptoObj;\n    this.logger = logger;\n    this.serializableCache = serializableCache;\n    this.persistencePlugin = persistencePlugin;\n    this.performanceClient = performanceClient;\n  }\n  /**\n   * Function which validates server authorization code response.\n   * @param serverResponseHash\n   * @param cachedState\n   * @param cryptoObj\n   */\n  validateServerAuthorizationCodeResponse(serverResponseHash, cachedState, cryptoObj) {\n    if (!serverResponseHash.state || !cachedState) {\n      throw serverResponseHash.state ? ClientAuthError.createStateNotFoundError(\"Cached State\") : ClientAuthError.createStateNotFoundError(\"Server State\");\n    }\n    let decodedServerResponseHash;\n    let decodedCachedState;\n    try {\n      decodedServerResponseHash = decodeURIComponent(serverResponseHash.state);\n    } catch (e) {\n      throw ClientAuthError.createInvalidStateError(serverResponseHash.state, `Server response hash URI could not be decoded`);\n    }\n    try {\n      decodedCachedState = decodeURIComponent(cachedState);\n    } catch (e) {\n      throw ClientAuthError.createInvalidStateError(serverResponseHash.state, `Cached state URI could not be decoded`);\n    }\n    if (decodedServerResponseHash !== decodedCachedState) {\n      throw ClientAuthError.createStateMismatchError();\n    }\n    // Check for error\n    if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror, serverResponseHash.timestamp || Constants.EMPTY_STRING, serverResponseHash.trace_id || Constants.EMPTY_STRING, serverResponseHash.correlation_id || Constants.EMPTY_STRING, serverResponseHash.claims || Constants.EMPTY_STRING);\n      }\n      throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\n    }\n    if (serverResponseHash.client_info) {\n      buildClientInfo(serverResponseHash.client_info, cryptoObj);\n    }\n  }\n  /**\n   * Function which validates server authorization token response.\n   * @param serverResponse\n   * @param refreshAccessToken\n   */\n  validateTokenResponse(serverResponse, refreshAccessToken) {\n    // Check for error\n    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\n      const errString = `${serverResponse.error_codes} - [${serverResponse.timestamp}]: ${serverResponse.error_description} - Correlation ID: ${serverResponse.correlation_id} - Trace ID: ${serverResponse.trace_id}`;\n      const serverError = new ServerError(serverResponse.error, errString, serverResponse.suberror);\n      // check if 500 error\n      if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START && serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END) {\n        this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.\\n${serverError}`);\n        // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\n        return;\n        // check if 400 error\n      } else if (refreshAccessToken && serverResponse.status && serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START && serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END) {\n        this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.\\n${serverError}`);\n        // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\n        return;\n      }\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING);\n      }\n      throw serverError;\n    }\n  }\n  /**\n   * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\n   * @param serverTokenResponse\n   * @param authority\n   */\n  async handleServerTokenResponse(serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);\n    // create an idToken object (not entity)\n    let idTokenClaims;\n    if (serverTokenResponse.id_token) {\n      idTokenClaims = extractTokenClaims(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj.base64Decode);\n      // token nonce check (TODO: Add a warning if no nonce is given?)\n      if (authCodePayload && authCodePayload.nonce) {\n        if (idTokenClaims.nonce !== authCodePayload.nonce) {\n          throw ClientAuthError.createNonceMismatchError();\n        }\n      }\n      // token max_age check\n      if (request.maxAge || request.maxAge === 0) {\n        const authTime = idTokenClaims.auth_time;\n        if (!authTime) {\n          throw ClientAuthError.createAuthTimeNotFoundError();\n        }\n        checkMaxAge(authTime, request.maxAge);\n      }\n    }\n    // generate homeAccountId\n    this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);\n    // save the response tokens\n    let requestStateObj;\n    if (!!authCodePayload && !!authCodePayload.state) {\n      requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\n    }\n    // Add keyId from request to serverTokenResponse if defined\n    serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;\n    const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload);\n    let cacheContext;\n    try {\n      if (this.persistencePlugin && this.serializableCache) {\n        this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\n        cacheContext = new TokenCacheContext(this.serializableCache, true);\n        await this.persistencePlugin.beforeCacheAccess(cacheContext);\n      }\n      /*\n       * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\n       * If not present, we should return null, as it's the case that another application called removeAccount in between\n       * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\n       * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\n       */\n      if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {\n        const key = cacheRecord.account.generateAccountKey();\n        const account = this.cacheStorage.getAccount(key);\n        if (!account) {\n          this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\n          return ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, undefined, serverRequestId);\n        }\n      }\n      await this.cacheStorage.saveCacheRecord(cacheRecord, request.storeInCache);\n    } finally {\n      if (this.persistencePlugin && this.serializableCache && cacheContext) {\n        this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\n        await this.persistencePlugin.afterCacheAccess(cacheContext);\n      }\n    }\n    return ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, serverTokenResponse, serverRequestId);\n  }\n  /**\n   * Generates CacheRecord\n   * @param serverTokenResponse\n   * @param idTokenObj\n   * @param authority\n   */\n  generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload) {\n    const env = authority.getPreferredCache();\n    if (!env) {\n      throw ClientAuthError.createInvalidCacheEnvironmentError();\n    }\n    // IdToken: non AAD scenarios can have empty realm\n    let cachedIdToken;\n    let cachedAccount;\n    if (serverTokenResponse.id_token && !!idTokenClaims) {\n      cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token, this.clientId, idTokenClaims.tid || \"\");\n      cachedAccount = AccountEntity.createAccount({\n        homeAccountId: this.homeAccountIdentifier,\n        idTokenClaims: idTokenClaims,\n        clientInfo: serverTokenResponse.client_info,\n        cloudGraphHostName: authCodePayload?.cloud_graph_host_name,\n        msGraphHost: authCodePayload?.msgraph_host\n      }, authority);\n    }\n    // AccessToken\n    let cachedAccessToken = null;\n    if (serverTokenResponse.access_token) {\n      // If scopes not returned in server response, use request scopes\n      const responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);\n      /*\n       * Use timestamp calculated before request\n       * Server may return timestamps as strings, parse to numbers if so.\n       */\n      const expiresIn = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\n      const extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\n      const refreshIn = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\n      const tokenExpirationSeconds = reqTimestamp + expiresIn;\n      const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\n      const refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;\n      // non AAD scenarios can have empty realm\n      cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenClaims?.tid || authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);\n    }\n    // refreshToken\n    let cachedRefreshToken = null;\n    if (serverTokenResponse.refresh_token) {\n      cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);\n    }\n    // appMetadata\n    let cachedAppMetadata = null;\n    if (serverTokenResponse.foci) {\n      cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\n    }\n    return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\n  }\n  /**\n   * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\n   *\n   * Optionally takes a state string that is set as-is in the response.\n   *\n   * @param cacheRecord\n   * @param idTokenObj\n   * @param fromTokenCache\n   * @param stateString\n   */\n  static async generateAuthenticationResult(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenClaims, requestState, serverTokenResponse, requestId) {\n    let accessToken = Constants.EMPTY_STRING;\n    let responseScopes = [];\n    let expiresOn = null;\n    let extExpiresOn;\n    let refreshOn;\n    let familyId = Constants.EMPTY_STRING;\n    if (cacheRecord.accessToken) {\n      if (cacheRecord.accessToken.tokenType === AuthenticationScheme.POP) {\n        const popTokenGenerator = new PopTokenGenerator(cryptoObj);\n        const {\n          secret,\n          keyId\n        } = cacheRecord.accessToken;\n        if (!keyId) {\n          throw ClientAuthError.createKeyIdMissingError();\n        }\n        accessToken = await popTokenGenerator.signPopToken(secret, keyId, request);\n      } else {\n        accessToken = cacheRecord.accessToken.secret;\n      }\n      responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\n      expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\n      extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\n      if (cacheRecord.accessToken.refreshOn) {\n        refreshOn = new Date(Number(cacheRecord.accessToken.refreshOn) * 1000);\n      }\n    }\n    if (cacheRecord.appMetadata) {\n      familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : \"\";\n    }\n    const uid = idTokenClaims?.oid || idTokenClaims?.sub || \"\";\n    const tid = idTokenClaims?.tid || \"\";\n    // for hybrid + native bridge enablement, send back the native account Id\n    if (serverTokenResponse?.spa_accountid && !!cacheRecord.account) {\n      cacheRecord.account.nativeAccountId = serverTokenResponse?.spa_accountid;\n    }\n    return {\n      authority: authority.canonicalAuthority,\n      uniqueId: uid,\n      tenantId: tid,\n      scopes: responseScopes,\n      account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\n      idToken: cacheRecord?.idToken?.secret || \"\",\n      idTokenClaims: idTokenClaims || {},\n      accessToken: accessToken,\n      fromCache: fromTokenCache,\n      expiresOn: expiresOn,\n      extExpiresOn: extExpiresOn,\n      refreshOn: refreshOn,\n      correlationId: request.correlationId,\n      requestId: requestId || Constants.EMPTY_STRING,\n      familyId: familyId,\n      tokenType: cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,\n      state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\n      cloudGraphHostName: cacheRecord.account?.cloudGraphHostName || Constants.EMPTY_STRING,\n      msGraphHost: cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING,\n      code: serverTokenResponse?.spa_code,\n      fromNativeBroker: false\n    };\n  }\n}\nexport { ResponseHandler };","map":{"version":3,"names":["ResponseHandler","constructor","clientId","cacheStorage","cryptoObj","logger","serializableCache","persistencePlugin","performanceClient","validateServerAuthorizationCodeResponse","serverResponseHash","cachedState","state","decodedServerResponseHash","decodedCachedState","ClientAuthError","createInvalidStateError","error","error_description"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-common\\src\\response\\ResponseHandler.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ServerAuthorizationTokenResponse } from \"./ServerAuthorizationTokenResponse\";\nimport { buildClientInfo } from \"../account/ClientInfo\";\nimport { ICrypto } from \"../crypto/ICrypto\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\nimport { ServerAuthorizationCodeResponse } from \"./ServerAuthorizationCodeResponse\";\nimport { Logger } from \"../logger/Logger\";\nimport { ServerError } from \"../error/ServerError\";\nimport { ScopeSet } from \"../request/ScopeSet\";\nimport { AuthenticationResult } from \"./AuthenticationResult\";\nimport { AccountEntity } from \"../cache/entities/AccountEntity\";\nimport { Authority } from \"../authority/Authority\";\nimport { IdTokenEntity } from \"../cache/entities/IdTokenEntity\";\nimport { AccessTokenEntity } from \"../cache/entities/AccessTokenEntity\";\nimport { RefreshTokenEntity } from \"../cache/entities/RefreshTokenEntity\";\nimport { InteractionRequiredAuthError } from \"../error/InteractionRequiredAuthError\";\nimport { CacheRecord } from \"../cache/entities/CacheRecord\";\nimport { CacheManager } from \"../cache/CacheManager\";\nimport { ProtocolUtils, RequestStateObject } from \"../utils/ProtocolUtils\";\nimport {\n    AuthenticationScheme,\n    Constants,\n    THE_FAMILY_ID,\n    HttpStatus,\n} from \"../utils/Constants\";\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator\";\nimport { AppMetadataEntity } from \"../cache/entities/AppMetadataEntity\";\nimport { ICachePlugin } from \"../cache/interface/ICachePlugin\";\nimport { TokenCacheContext } from \"../cache/persistence/TokenCacheContext\";\nimport { ISerializableTokenCache } from \"../cache/interface/ISerializableTokenCache\";\nimport { AuthorizationCodePayload } from \"./AuthorizationCodePayload\";\nimport { BaseAuthRequest } from \"../request/BaseAuthRequest\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent\";\nimport { checkMaxAge, extractTokenClaims } from \"../account/AuthToken\";\nimport { TokenClaims } from \"../account/TokenClaims\";\n\n/**\n * Class that handles response parsing.\n * @internal\n */\nexport class ResponseHandler {\n    private clientId: string;\n    private cacheStorage: CacheManager;\n    private cryptoObj: ICrypto;\n    private logger: Logger;\n    private homeAccountIdentifier: string;\n    private serializableCache: ISerializableTokenCache | null;\n    private persistencePlugin: ICachePlugin | null;\n    private performanceClient?: IPerformanceClient;\n\n    constructor(\n        clientId: string,\n        cacheStorage: CacheManager,\n        cryptoObj: ICrypto,\n        logger: Logger,\n        serializableCache: ISerializableTokenCache | null,\n        persistencePlugin: ICachePlugin | null,\n        performanceClient?: IPerformanceClient\n    ) {\n        this.clientId = clientId;\n        this.cacheStorage = cacheStorage;\n        this.cryptoObj = cryptoObj;\n        this.logger = logger;\n        this.serializableCache = serializableCache;\n        this.persistencePlugin = persistencePlugin;\n        this.performanceClient = performanceClient;\n    }\n\n    /**\n     * Function which validates server authorization code response.\n     * @param serverResponseHash\n     * @param cachedState\n     * @param cryptoObj\n     */\n    validateServerAuthorizationCodeResponse(\n        serverResponseHash: ServerAuthorizationCodeResponse,\n        cachedState: string,\n        cryptoObj: ICrypto\n    ): void {\n        if (!serverResponseHash.state || !cachedState) {\n            throw serverResponseHash.state\n                ? ClientAuthError.createStateNotFoundError(\"Cached State\")\n                : ClientAuthError.createStateNotFoundError(\"Server State\");\n        }\n\n        let decodedServerResponseHash: string;\n        let decodedCachedState: string;\n\n        try {\n            decodedServerResponseHash = decodeURIComponent(\n                serverResponseHash.state\n            );\n        } catch (e) {\n            throw ClientAuthError.createInvalidStateError(\n                serverResponseHash.state,\n                `Server response hash URI could not be decoded`\n            );\n        }\n\n        try {\n            decodedCachedState = decodeURIComponent(cachedState);\n        } catch (e) {\n            throw ClientAuthError.createInvalidStateError(\n                serverResponseHash.state,\n                `Cached state URI could not be decoded`\n            );\n        }\n\n        if (decodedServerResponseHash !== decodedCachedState) {\n            throw ClientAuthError.createStateMismatchError();\n        }\n\n        // Check for error\n        if (\n            serverResponseHash.error ||\n            serverResponseHash.error_description ||\n            serverResponseHash.suberror\n        ) {\n            if (\n                InteractionRequiredAuthError.isInteractionRequiredError(\n                    serverResponseHash.error,\n                    serverResponseHash.error_description,\n                    serverResponseHash.suberror\n                )\n            ) {\n                throw new InteractionRequiredAuthError(\n                    serverResponseHash.error || Constants.EMPTY_STRING,\n                    serverResponseHash.error_description,\n                    serverResponseHash.suberror,\n                    serverResponseHash.timestamp || Constants.EMPTY_STRING,\n                    serverResponseHash.trace_id || Constants.EMPTY_STRING,\n                    serverResponseHash.correlation_id || Constants.EMPTY_STRING,\n                    serverResponseHash.claims || Constants.EMPTY_STRING\n                );\n            }\n\n            throw new ServerError(\n                serverResponseHash.error || Constants.EMPTY_STRING,\n                serverResponseHash.error_description,\n                serverResponseHash.suberror\n            );\n        }\n\n        if (serverResponseHash.client_info) {\n            buildClientInfo(serverResponseHash.client_info, cryptoObj);\n        }\n    }\n\n    /**\n     * Function which validates server authorization token response.\n     * @param serverResponse\n     * @param refreshAccessToken\n     */\n    validateTokenResponse(\n        serverResponse: ServerAuthorizationTokenResponse,\n        refreshAccessToken?: boolean\n    ): void {\n        // Check for error\n        if (\n            serverResponse.error ||\n            serverResponse.error_description ||\n            serverResponse.suberror\n        ) {\n            const errString = `${serverResponse.error_codes} - [${serverResponse.timestamp}]: ${serverResponse.error_description} - Correlation ID: ${serverResponse.correlation_id} - Trace ID: ${serverResponse.trace_id}`;\n            const serverError = new ServerError(\n                serverResponse.error,\n                errString,\n                serverResponse.suberror\n            );\n\n            // check if 500 error\n            if (\n                refreshAccessToken &&\n                serverResponse.status &&\n                serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START &&\n                serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END\n            ) {\n                this.logger.warning(\n                    `executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.\\n${serverError}`\n                );\n\n                // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\n                return;\n                // check if 400 error\n            } else if (\n                refreshAccessToken &&\n                serverResponse.status &&\n                serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START &&\n                serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END\n            ) {\n                this.logger.warning(\n                    `executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.\\n${serverError}`\n                );\n\n                // don't throw an exception, but alert the user via a log that the token was unable to be refreshed\n                return;\n            }\n\n            if (\n                InteractionRequiredAuthError.isInteractionRequiredError(\n                    serverResponse.error,\n                    serverResponse.error_description,\n                    serverResponse.suberror\n                )\n            ) {\n                throw new InteractionRequiredAuthError(\n                    serverResponse.error,\n                    serverResponse.error_description,\n                    serverResponse.suberror,\n                    serverResponse.timestamp || Constants.EMPTY_STRING,\n                    serverResponse.trace_id || Constants.EMPTY_STRING,\n                    serverResponse.correlation_id || Constants.EMPTY_STRING,\n                    serverResponse.claims || Constants.EMPTY_STRING\n                );\n            }\n\n            throw serverError;\n        }\n    }\n\n    /**\n     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\n     * @param serverTokenResponse\n     * @param authority\n     */\n    async handleServerTokenResponse(\n        serverTokenResponse: ServerAuthorizationTokenResponse,\n        authority: Authority,\n        reqTimestamp: number,\n        request: BaseAuthRequest,\n        authCodePayload?: AuthorizationCodePayload,\n        userAssertionHash?: string,\n        handlingRefreshTokenResponse?: boolean,\n        forceCacheRefreshTokenResponse?: boolean,\n        serverRequestId?: string\n    ): Promise<AuthenticationResult> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.HandleServerTokenResponse,\n            serverTokenResponse.correlation_id\n        );\n\n        // create an idToken object (not entity)\n        let idTokenClaims: TokenClaims | undefined;\n        if (serverTokenResponse.id_token) {\n            idTokenClaims = extractTokenClaims(\n                serverTokenResponse.id_token || Constants.EMPTY_STRING,\n                this.cryptoObj.base64Decode\n            );\n\n            // token nonce check (TODO: Add a warning if no nonce is given?)\n            if (authCodePayload && authCodePayload.nonce) {\n                if (idTokenClaims.nonce !== authCodePayload.nonce) {\n                    throw ClientAuthError.createNonceMismatchError();\n                }\n            }\n\n            // token max_age check\n            if (request.maxAge || request.maxAge === 0) {\n                const authTime = idTokenClaims.auth_time;\n                if (!authTime) {\n                    throw ClientAuthError.createAuthTimeNotFoundError();\n                }\n\n                checkMaxAge(authTime, request.maxAge);\n            }\n        }\n\n        // generate homeAccountId\n        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(\n            serverTokenResponse.client_info || Constants.EMPTY_STRING,\n            authority.authorityType,\n            this.logger,\n            this.cryptoObj,\n            idTokenClaims\n        );\n\n        // save the response tokens\n        let requestStateObj: RequestStateObject | undefined;\n        if (!!authCodePayload && !!authCodePayload.state) {\n            requestStateObj = ProtocolUtils.parseRequestState(\n                this.cryptoObj,\n                authCodePayload.state\n            );\n        }\n\n        // Add keyId from request to serverTokenResponse if defined\n        serverTokenResponse.key_id =\n            serverTokenResponse.key_id || request.sshKid || undefined;\n\n        const cacheRecord = this.generateCacheRecord(\n            serverTokenResponse,\n            authority,\n            reqTimestamp,\n            request,\n            idTokenClaims,\n            userAssertionHash,\n            authCodePayload\n        );\n        let cacheContext;\n        try {\n            if (this.persistencePlugin && this.serializableCache) {\n                this.logger.verbose(\n                    \"Persistence enabled, calling beforeCacheAccess\"\n                );\n                cacheContext = new TokenCacheContext(\n                    this.serializableCache,\n                    true\n                );\n                await this.persistencePlugin.beforeCacheAccess(cacheContext);\n            }\n            /*\n             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\n             * If not present, we should return null, as it's the case that another application called removeAccount in between\n             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\n             * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\n             */\n            if (\n                handlingRefreshTokenResponse &&\n                !forceCacheRefreshTokenResponse &&\n                cacheRecord.account\n            ) {\n                const key = cacheRecord.account.generateAccountKey();\n                const account = this.cacheStorage.getAccount(key);\n                if (!account) {\n                    this.logger.warning(\n                        \"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\"\n                    );\n                    return ResponseHandler.generateAuthenticationResult(\n                        this.cryptoObj,\n                        authority,\n                        cacheRecord,\n                        false,\n                        request,\n                        idTokenClaims,\n                        requestStateObj,\n                        undefined,\n                        serverRequestId\n                    );\n                }\n            }\n            await this.cacheStorage.saveCacheRecord(\n                cacheRecord,\n                request.storeInCache\n            );\n        } finally {\n            if (\n                this.persistencePlugin &&\n                this.serializableCache &&\n                cacheContext\n            ) {\n                this.logger.verbose(\n                    \"Persistence enabled, calling afterCacheAccess\"\n                );\n                await this.persistencePlugin.afterCacheAccess(cacheContext);\n            }\n        }\n        return ResponseHandler.generateAuthenticationResult(\n            this.cryptoObj,\n            authority,\n            cacheRecord,\n            false,\n            request,\n            idTokenClaims,\n            requestStateObj,\n            serverTokenResponse,\n            serverRequestId\n        );\n    }\n\n    /**\n     * Generates CacheRecord\n     * @param serverTokenResponse\n     * @param idTokenObj\n     * @param authority\n     */\n    private generateCacheRecord(\n        serverTokenResponse: ServerAuthorizationTokenResponse,\n        authority: Authority,\n        reqTimestamp: number,\n        request: BaseAuthRequest,\n        idTokenClaims?: TokenClaims,\n        userAssertionHash?: string,\n        authCodePayload?: AuthorizationCodePayload\n    ): CacheRecord {\n        const env = authority.getPreferredCache();\n        if (!env) {\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\n        }\n\n        // IdToken: non AAD scenarios can have empty realm\n        let cachedIdToken: IdTokenEntity | undefined;\n        let cachedAccount: AccountEntity | undefined;\n        if (serverTokenResponse.id_token && !!idTokenClaims) {\n            cachedIdToken = IdTokenEntity.createIdTokenEntity(\n                this.homeAccountIdentifier,\n                env,\n                serverTokenResponse.id_token,\n                this.clientId,\n                idTokenClaims.tid || \"\"\n            );\n\n            cachedAccount = AccountEntity.createAccount(\n                {\n                    homeAccountId: this.homeAccountIdentifier,\n                    idTokenClaims: idTokenClaims,\n                    clientInfo: serverTokenResponse.client_info,\n                    cloudGraphHostName: authCodePayload?.cloud_graph_host_name,\n                    msGraphHost: authCodePayload?.msgraph_host,\n                },\n                authority\n            );\n        }\n\n        // AccessToken\n        let cachedAccessToken: AccessTokenEntity | null = null;\n        if (serverTokenResponse.access_token) {\n            // If scopes not returned in server response, use request scopes\n            const responseScopes = serverTokenResponse.scope\n                ? ScopeSet.fromString(serverTokenResponse.scope)\n                : new ScopeSet(request.scopes || []);\n\n            /*\n             * Use timestamp calculated before request\n             * Server may return timestamps as strings, parse to numbers if so.\n             */\n            const expiresIn: number =\n                (typeof serverTokenResponse.expires_in === \"string\"\n                    ? parseInt(serverTokenResponse.expires_in, 10)\n                    : serverTokenResponse.expires_in) || 0;\n            const extExpiresIn: number =\n                (typeof serverTokenResponse.ext_expires_in === \"string\"\n                    ? parseInt(serverTokenResponse.ext_expires_in, 10)\n                    : serverTokenResponse.ext_expires_in) || 0;\n            const refreshIn: number | undefined =\n                (typeof serverTokenResponse.refresh_in === \"string\"\n                    ? parseInt(serverTokenResponse.refresh_in, 10)\n                    : serverTokenResponse.refresh_in) || undefined;\n            const tokenExpirationSeconds = reqTimestamp + expiresIn;\n            const extendedTokenExpirationSeconds =\n                tokenExpirationSeconds + extExpiresIn;\n            const refreshOnSeconds =\n                refreshIn && refreshIn > 0\n                    ? reqTimestamp + refreshIn\n                    : undefined;\n\n            // non AAD scenarios can have empty realm\n            cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(\n                this.homeAccountIdentifier,\n                env,\n                serverTokenResponse.access_token || Constants.EMPTY_STRING,\n                this.clientId,\n                idTokenClaims?.tid || authority.tenant,\n                responseScopes.printScopes(),\n                tokenExpirationSeconds,\n                extendedTokenExpirationSeconds,\n                this.cryptoObj,\n                refreshOnSeconds,\n                serverTokenResponse.token_type,\n                userAssertionHash,\n                serverTokenResponse.key_id,\n                request.claims,\n                request.requestedClaimsHash\n            );\n        }\n\n        // refreshToken\n        let cachedRefreshToken: RefreshTokenEntity | null = null;\n        if (serverTokenResponse.refresh_token) {\n            cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(\n                this.homeAccountIdentifier,\n                env,\n                serverTokenResponse.refresh_token || Constants.EMPTY_STRING,\n                this.clientId,\n                serverTokenResponse.foci,\n                userAssertionHash\n            );\n        }\n\n        // appMetadata\n        let cachedAppMetadata: AppMetadataEntity | null = null;\n        if (serverTokenResponse.foci) {\n            cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(\n                this.clientId,\n                env,\n                serverTokenResponse.foci\n            );\n        }\n\n        return new CacheRecord(\n            cachedAccount,\n            cachedIdToken,\n            cachedAccessToken,\n            cachedRefreshToken,\n            cachedAppMetadata\n        );\n    }\n\n    /**\n     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\n     *\n     * Optionally takes a state string that is set as-is in the response.\n     *\n     * @param cacheRecord\n     * @param idTokenObj\n     * @param fromTokenCache\n     * @param stateString\n     */\n    static async generateAuthenticationResult(\n        cryptoObj: ICrypto,\n        authority: Authority,\n        cacheRecord: CacheRecord,\n        fromTokenCache: boolean,\n        request: BaseAuthRequest,\n        idTokenClaims?: TokenClaims,\n        requestState?: RequestStateObject,\n        serverTokenResponse?: ServerAuthorizationTokenResponse,\n        requestId?: string\n    ): Promise<AuthenticationResult> {\n        let accessToken: string = Constants.EMPTY_STRING;\n        let responseScopes: Array<string> = [];\n        let expiresOn: Date | null = null;\n        let extExpiresOn: Date | undefined;\n        let refreshOn: Date | undefined;\n        let familyId: string = Constants.EMPTY_STRING;\n\n        if (cacheRecord.accessToken) {\n            if (\n                cacheRecord.accessToken.tokenType === AuthenticationScheme.POP\n            ) {\n                const popTokenGenerator: PopTokenGenerator =\n                    new PopTokenGenerator(cryptoObj);\n                const { secret, keyId } = cacheRecord.accessToken;\n\n                if (!keyId) {\n                    throw ClientAuthError.createKeyIdMissingError();\n                }\n\n                accessToken = await popTokenGenerator.signPopToken(\n                    secret,\n                    keyId,\n                    request\n                );\n            } else {\n                accessToken = cacheRecord.accessToken.secret;\n            }\n            responseScopes = ScopeSet.fromString(\n                cacheRecord.accessToken.target\n            ).asArray();\n            expiresOn = new Date(\n                Number(cacheRecord.accessToken.expiresOn) * 1000\n            );\n            extExpiresOn = new Date(\n                Number(cacheRecord.accessToken.extendedExpiresOn) * 1000\n            );\n            if (cacheRecord.accessToken.refreshOn) {\n                refreshOn = new Date(\n                    Number(cacheRecord.accessToken.refreshOn) * 1000\n                );\n            }\n        }\n\n        if (cacheRecord.appMetadata) {\n            familyId =\n                cacheRecord.appMetadata.familyId === THE_FAMILY_ID\n                    ? THE_FAMILY_ID\n                    : \"\";\n        }\n        const uid = idTokenClaims?.oid || idTokenClaims?.sub || \"\";\n        const tid = idTokenClaims?.tid || \"\";\n\n        // for hybrid + native bridge enablement, send back the native account Id\n        if (serverTokenResponse?.spa_accountid && !!cacheRecord.account) {\n            cacheRecord.account.nativeAccountId =\n                serverTokenResponse?.spa_accountid;\n        }\n\n        return {\n            authority: authority.canonicalAuthority,\n            uniqueId: uid,\n            tenantId: tid,\n            scopes: responseScopes,\n            account: cacheRecord.account\n                ? cacheRecord.account.getAccountInfo()\n                : null,\n            idToken: cacheRecord?.idToken?.secret || \"\",\n            idTokenClaims: idTokenClaims || {},\n            accessToken: accessToken,\n            fromCache: fromTokenCache,\n            expiresOn: expiresOn,\n            extExpiresOn: extExpiresOn,\n            refreshOn: refreshOn,\n            correlationId: request.correlationId,\n            requestId: requestId || Constants.EMPTY_STRING,\n            familyId: familyId,\n            tokenType:\n                cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,\n            state: requestState\n                ? requestState.userRequestState\n                : Constants.EMPTY_STRING,\n            cloudGraphHostName:\n                cacheRecord.account?.cloudGraphHostName ||\n                Constants.EMPTY_STRING,\n            msGraphHost:\n                cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING,\n            code: serverTokenResponse?.spa_code,\n            fromNativeBroker: false,\n        };\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAKA;AAEA;AAEA;AACA;;;;;AAyCW,MAAAA,eAAA,CAAkB;EACzBC,YAAAC,QAAA,EAAAC,YAA+C,EAAAC,SAAA,EAAAC,MAAA,EAAAC,iBAAA,EAAAC,iBAAA,EAAAC,iBAAA;IACxC,IAAC,CAAiBN,QAAA,GAAAA,QAAsB;IAG3C,KAAAC,YAAU,GAAAA,YACV;IAgBJ,KAAAC,SAAA,GAAAA,SAAA;;;;;EAKG;EACH;AA0EA;;;;AAIG;EACHK,uCACoDA,CAAAC,kBAAA,EAAAC,WAAA,EAAAP,SAAA;IAkEpD,KAAAM,kBAAA,CAAAE,KAAA,KAAAD,WAAA;;IAIG;IAC4B,IAAAE,yBAAA;IAgJ/B,IAAAC,kBAAA;;;;MAKG,MAAAC,eAAA,CAAAC,uBAAA,CAAAN,kBAAA,CAAAE,KAAA;IACH;IA0HA;;;;;;;;IASG;QACsCF,kBAAA,CAAAO,KAAA,IAqG5CP,kBAAA,CAAAQ,iBAAA,I"},"metadata":{},"sourceType":"module","externalDependencies":[]}