{"ast":null,"code":"/*! @azure/msal-browser v3.9.0 2024-02-07 */\n'use strict';\n\nimport { PerformanceEvents, invokeAsync, invoke, ServerResponseType } from '@azure/msal-common';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { DEFAULT_IFRAME_TIMEOUT_MS } from '../config/Configuration.mjs';\nimport { emptyNavigateUri, monitorWindowTimeout } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Creates a hidden iframe to given URL using user-requested scopes as an id.\n * @param urlNavigate\n * @param userRequestScopes\n */\nasync function initiateAuthRequest(requestUrl, performanceClient, logger, correlationId, navigateFrameWait) {\n  performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerInitiateAuthRequest, correlationId);\n  if (!requestUrl) {\n    // Throw error if request URL is empty.\n    logger.info(\"Navigate url is empty\");\n    throw createBrowserAuthError(emptyNavigateUri);\n  }\n  if (navigateFrameWait) {\n    return invokeAsync(loadFrame, PerformanceEvents.SilentHandlerLoadFrame, logger, performanceClient, correlationId)(requestUrl, navigateFrameWait, performanceClient, correlationId);\n  }\n  return invoke(loadFrameSync, PerformanceEvents.SilentHandlerLoadFrameSync, logger, performanceClient, correlationId)(requestUrl);\n}\n/**\n * Monitors an iframe content window until it loads a url with a known hash, or hits a specified timeout.\n * @param iframe\n * @param timeout\n */\nasync function monitorIframeForHash(iframe, timeout, pollIntervalMilliseconds, performanceClient, logger, correlationId, responseType) {\n  performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerMonitorIframeForHash, correlationId);\n  return new Promise((resolve, reject) => {\n    if (timeout < DEFAULT_IFRAME_TIMEOUT_MS) {\n      logger.warning(`system.loadFrameTimeout or system.iframeHashTimeout set to lower (${timeout}ms) than the default (${DEFAULT_IFRAME_TIMEOUT_MS}ms). This may result in timeouts.`);\n    }\n    /*\n     * Polling for iframes can be purely timing based,\n     * since we don't need to account for interaction.\n     */\n    const timeoutId = window.setTimeout(() => {\n      window.clearInterval(intervalId);\n      reject(createBrowserAuthError(monitorWindowTimeout));\n    }, timeout);\n    const intervalId = window.setInterval(() => {\n      let href = \"\";\n      const contentWindow = iframe.contentWindow;\n      try {\n        /*\n         * Will throw if cross origin,\n         * which should be caught and ignored\n         * since we need the interval to keep running while on STS UI.\n         */\n        href = contentWindow ? contentWindow.location.href : \"\";\n      } catch (e) {}\n      if (!href || href === \"about:blank\") {\n        return;\n      }\n      let responseString = \"\";\n      if (contentWindow) {\n        if (responseType === ServerResponseType.QUERY) {\n          responseString = contentWindow.location.search;\n        } else {\n          responseString = contentWindow.location.hash;\n        }\n      }\n      window.clearTimeout(timeoutId);\n      window.clearInterval(intervalId);\n      resolve(responseString);\n    }, pollIntervalMilliseconds);\n  }).finally(() => {\n    invoke(removeHiddenIframe, PerformanceEvents.RemoveHiddenIframe, logger, performanceClient, correlationId)(iframe);\n  });\n}\n/**\n * @hidden\n * Loads iframe with authorization endpoint URL\n * @ignore\n * @deprecated\n */\nfunction loadFrame(urlNavigate, navigateFrameWait, performanceClient, correlationId) {\n  performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerLoadFrame, correlationId);\n  /*\n   * This trick overcomes iframe navigation in IE\n   * IE does not load the page consistently in iframe\n   */\n  return new Promise((resolve, reject) => {\n    const frameHandle = createHiddenIframe();\n    window.setTimeout(() => {\n      if (!frameHandle) {\n        reject(\"Unable to load iframe\");\n        return;\n      }\n      frameHandle.src = urlNavigate;\n      resolve(frameHandle);\n    }, navigateFrameWait);\n  });\n}\n/**\n * @hidden\n * Loads the iframe synchronously when the navigateTimeFrame is set to `0`\n * @param urlNavigate\n * @param frameName\n * @param logger\n */\nfunction loadFrameSync(urlNavigate) {\n  const frameHandle = createHiddenIframe();\n  frameHandle.src = urlNavigate;\n  return frameHandle;\n}\n/**\n * @hidden\n * Creates a new hidden iframe or gets an existing one for silent token renewal.\n * @ignore\n */\nfunction createHiddenIframe() {\n  const authFrame = document.createElement(\"iframe\");\n  authFrame.style.visibility = \"hidden\";\n  authFrame.style.position = \"absolute\";\n  authFrame.style.width = authFrame.style.height = \"0\";\n  authFrame.style.border = \"0\";\n  authFrame.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin allow-forms\");\n  document.body.appendChild(authFrame);\n  return authFrame;\n}\n/**\n * @hidden\n * Removes a hidden iframe from the page.\n * @ignore\n */\nfunction removeHiddenIframe(iframe) {\n  if (document.body === iframe.parentNode) {\n    document.body.removeChild(iframe);\n  }\n}\nexport { initiateAuthRequest, monitorIframeForHash };","map":{"version":3,"names":["initiateAuthRequest","requestUrl","performanceClient","logger","correlationId","navigateFrameWait","addQueueMeasurement","PerformanceEvents","SilentHandlerInitiateAuthRequest","info","createBrowserAuthError","emptyNavigateUri","invokeAsync","loadFrame","SilentHandlerLoadFrame","invoke","loadFrameSync","SilentHandlerLoadFrameSync","monitorIframeForHash","iframe","timeout","pollIntervalMilliseconds","responseType","SilentHandlerMonitorIframeForHash","Promise","resolve","reject","DEFAULT_IFRAME_TIMEOUT_MS","warning","timeoutId","window","setTimeout","clearInterval","intervalId","monitorWindowTimeout","setInterval","href","contentWindow","location","e","responseString","ServerResponseType","QUERY","search","hash","clearTimeout","finally","removeHiddenIframe","RemoveHiddenIframe","urlNavigate","frameHandle","createHiddenIframe","src","authFrame","document","createElement","style","visibility","position","width","height","border","setAttribute","body","appendChild","parentNode","removeChild"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\interaction_handler\\SilentHandler.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    Logger,\n    IPerformanceClient,\n    PerformanceEvents,\n    invokeAsync,\n    invoke,\n    ServerResponseType,\n} from \"@azure/msal-common\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError\";\nimport { DEFAULT_IFRAME_TIMEOUT_MS } from \"../config/Configuration\";\n\n/**\n * Creates a hidden iframe to given URL using user-requested scopes as an id.\n * @param urlNavigate\n * @param userRequestScopes\n */\nexport async function initiateAuthRequest(\n    requestUrl: string,\n    performanceClient: IPerformanceClient,\n    logger: Logger,\n    correlationId: string,\n    navigateFrameWait?: number\n): Promise<HTMLIFrameElement> {\n    performanceClient.addQueueMeasurement(\n        PerformanceEvents.SilentHandlerInitiateAuthRequest,\n        correlationId\n    );\n\n    if (!requestUrl) {\n        // Throw error if request URL is empty.\n        logger.info(\"Navigate url is empty\");\n        throw createBrowserAuthError(BrowserAuthErrorCodes.emptyNavigateUri);\n    }\n    if (navigateFrameWait) {\n        return invokeAsync(\n            loadFrame,\n            PerformanceEvents.SilentHandlerLoadFrame,\n            logger,\n            performanceClient,\n            correlationId\n        )(requestUrl, navigateFrameWait, performanceClient, correlationId);\n    }\n    return invoke(\n        loadFrameSync,\n        PerformanceEvents.SilentHandlerLoadFrameSync,\n        logger,\n        performanceClient,\n        correlationId\n    )(requestUrl);\n}\n\n/**\n * Monitors an iframe content window until it loads a url with a known hash, or hits a specified timeout.\n * @param iframe\n * @param timeout\n */\nexport async function monitorIframeForHash(\n    iframe: HTMLIFrameElement,\n    timeout: number,\n    pollIntervalMilliseconds: number,\n    performanceClient: IPerformanceClient,\n    logger: Logger,\n    correlationId: string,\n    responseType: ServerResponseType\n): Promise<string> {\n    performanceClient.addQueueMeasurement(\n        PerformanceEvents.SilentHandlerMonitorIframeForHash,\n        correlationId\n    );\n\n    return new Promise<string>((resolve, reject) => {\n        if (timeout < DEFAULT_IFRAME_TIMEOUT_MS) {\n            logger.warning(\n                `system.loadFrameTimeout or system.iframeHashTimeout set to lower (${timeout}ms) than the default (${DEFAULT_IFRAME_TIMEOUT_MS}ms). This may result in timeouts.`\n            );\n        }\n\n        /*\n         * Polling for iframes can be purely timing based,\n         * since we don't need to account for interaction.\n         */\n        const timeoutId = window.setTimeout(() => {\n            window.clearInterval(intervalId);\n            reject(\n                createBrowserAuthError(\n                    BrowserAuthErrorCodes.monitorWindowTimeout\n                )\n            );\n        }, timeout);\n\n        const intervalId = window.setInterval(() => {\n            let href: string = \"\";\n            const contentWindow = iframe.contentWindow;\n            try {\n                /*\n                 * Will throw if cross origin,\n                 * which should be caught and ignored\n                 * since we need the interval to keep running while on STS UI.\n                 */\n                href = contentWindow ? contentWindow.location.href : \"\";\n            } catch (e) {}\n\n            if (!href || href === \"about:blank\") {\n                return;\n            }\n\n            let responseString = \"\";\n            if (contentWindow) {\n                if (responseType === ServerResponseType.QUERY) {\n                    responseString = contentWindow.location.search;\n                } else {\n                    responseString = contentWindow.location.hash;\n                }\n            }\n            window.clearTimeout(timeoutId);\n            window.clearInterval(intervalId);\n            resolve(responseString);\n        }, pollIntervalMilliseconds);\n    }).finally(() => {\n        invoke(\n            removeHiddenIframe,\n            PerformanceEvents.RemoveHiddenIframe,\n            logger,\n            performanceClient,\n            correlationId\n        )(iframe);\n    });\n}\n\n/**\n * @hidden\n * Loads iframe with authorization endpoint URL\n * @ignore\n * @deprecated\n */\nfunction loadFrame(\n    urlNavigate: string,\n    navigateFrameWait: number,\n    performanceClient: IPerformanceClient,\n    correlationId: string\n): Promise<HTMLIFrameElement> {\n    performanceClient.addQueueMeasurement(\n        PerformanceEvents.SilentHandlerLoadFrame,\n        correlationId\n    );\n\n    /*\n     * This trick overcomes iframe navigation in IE\n     * IE does not load the page consistently in iframe\n     */\n\n    return new Promise((resolve, reject) => {\n        const frameHandle = createHiddenIframe();\n\n        window.setTimeout(() => {\n            if (!frameHandle) {\n                reject(\"Unable to load iframe\");\n                return;\n            }\n\n            frameHandle.src = urlNavigate;\n\n            resolve(frameHandle);\n        }, navigateFrameWait);\n    });\n}\n/**\n * @hidden\n * Loads the iframe synchronously when the navigateTimeFrame is set to `0`\n * @param urlNavigate\n * @param frameName\n * @param logger\n */\nfunction loadFrameSync(urlNavigate: string): HTMLIFrameElement {\n    const frameHandle = createHiddenIframe();\n\n    frameHandle.src = urlNavigate;\n\n    return frameHandle;\n}\n\n/**\n * @hidden\n * Creates a new hidden iframe or gets an existing one for silent token renewal.\n * @ignore\n */\nfunction createHiddenIframe(): HTMLIFrameElement {\n    const authFrame = document.createElement(\"iframe\");\n\n    authFrame.style.visibility = \"hidden\";\n    authFrame.style.position = \"absolute\";\n    authFrame.style.width = authFrame.style.height = \"0\";\n    authFrame.style.border = \"0\";\n    authFrame.setAttribute(\n        \"sandbox\",\n        \"allow-scripts allow-same-origin allow-forms\"\n    );\n    document.body.appendChild(authFrame);\n\n    return authFrame;\n}\n\n/**\n * @hidden\n * Removes a hidden iframe from the page.\n * @ignore\n */\nfunction removeHiddenIframe(iframe: HTMLIFrameElement): void {\n    if (document.body === iframe.parentNode) {\n        document.body.removeChild(iframe);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}