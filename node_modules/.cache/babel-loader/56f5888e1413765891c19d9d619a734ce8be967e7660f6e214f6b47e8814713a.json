{"ast":null,"code":"/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\n\nimport { CacheManager, CredentialType, RefreshTokenEntity, AccessTokenEntity, IdTokenEntity, AccountEntity, ClientAuthError, AppMetadataEntity, ServerTelemetryEntity, AuthorityMetadataEntity, Constants, PersistentCacheKeys, ThrottlingEntity, StringUtils, ProtocolUtils, AuthToken, CacheRecord, DEFAULT_CRYPTO_IMPLEMENTATION, CcsCredentialType } from '@azure/msal-common';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { BrowserCacheLocation, StaticCacheKeys, InMemoryCacheKeys, TemporaryCacheKeys } from '../utils/BrowserConstants.mjs';\nimport { BrowserStorage } from './BrowserStorage.mjs';\nimport { MemoryStorage } from './MemoryStorage.mjs';\nimport { BrowserProtocolUtils } from '../utils/BrowserProtocolUtils.mjs';\nimport { base64Decode } from '../encode/Base64Decode.mjs';\nimport { base64Encode } from '../encode/Base64Encode.mjs';\nimport { noTokenRequestCacheError, unableToParseTokenRequestCacheError, noCachedAuthorityError, interactionInProgress } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This class implements the cache storage interface for MSAL through browser local or session storage.\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\n * parameters such as state and nonce, generally.\n */\nclass BrowserCacheManager extends CacheManager {\n  constructor(clientId, cacheConfig, cryptoImpl, logger) {\n    super(clientId, cryptoImpl, logger);\n    // Cookie life calculation (hours * minutes * seconds * ms)\n    this.COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\n    this.cacheConfig = cacheConfig;\n    this.logger = logger;\n    this.internalStorage = new MemoryStorage();\n    this.browserStorage = this.setupBrowserStorage(this.cacheConfig.cacheLocation);\n    this.temporaryCacheStorage = this.setupTemporaryCacheStorage(this.cacheConfig.temporaryCacheLocation, this.cacheConfig.cacheLocation);\n    // Migrate cache entries from older versions of MSAL.\n    if (cacheConfig.cacheMigrationEnabled) {\n      this.migrateCacheEntries();\n      this.createKeyMaps();\n    }\n  }\n  /**\n   * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\n   * @param cacheLocation\n   */\n  setupBrowserStorage(cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          return new BrowserStorage(cacheLocation);\n        } catch (e) {\n          this.logger.verbose(e);\n          break;\n        }\n    }\n    this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\n    return new MemoryStorage();\n  }\n  /**\n   * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured temporaryCacheLocation.\n   * @param temporaryCacheLocation\n   * @param cacheLocation\n   */\n  setupTemporaryCacheStorage(temporaryCacheLocation, cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\n          return new BrowserStorage(temporaryCacheLocation || BrowserCacheLocation.SessionStorage);\n        } catch (e) {\n          this.logger.verbose(e);\n          return this.internalStorage;\n        }\n      case BrowserCacheLocation.MemoryStorage:\n      default:\n        return this.internalStorage;\n    }\n  }\n  /**\n   * Migrate all old cache entries to new schema. No rollback supported.\n   * @param storeAuthStateInCookie\n   */\n  migrateCacheEntries() {\n    const idTokenKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ID_TOKEN}`;\n    const clientInfoKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.CLIENT_INFO}`;\n    const errorKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR}`;\n    const errorDescKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR_DESC}`;\n    const idTokenValue = this.browserStorage.getItem(idTokenKey);\n    const clientInfoValue = this.browserStorage.getItem(clientInfoKey);\n    const errorValue = this.browserStorage.getItem(errorKey);\n    const errorDescValue = this.browserStorage.getItem(errorDescKey);\n    const values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\n    const keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\n    keysToMigrate.forEach((cacheKey, index) => this.migrateCacheEntry(cacheKey, values[index]));\n  }\n  /**\n   * Utility function to help with migration.\n   * @param newKey\n   * @param value\n   * @param storeAuthStateInCookie\n   */\n  migrateCacheEntry(newKey, value) {\n    if (value) {\n      this.setTemporaryCache(newKey, value, true);\n    }\n  }\n  /**\n   * Searches all cache entries for MSAL accounts and creates the account key map\n   * This is used to migrate users from older versions of MSAL which did not create the map.\n   * @returns\n   */\n  createKeyMaps() {\n    this.logger.trace(\"BrowserCacheManager - createKeyMaps called.\");\n    const accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n    const tokenKeys = this.getItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`);\n    if (accountKeys && tokenKeys) {\n      this.logger.verbose(\"BrowserCacheManager:createKeyMaps - account and token key maps already exist, skipping migration.\");\n      // Key maps already exist, no need to iterate through cache\n      return;\n    }\n    const allKeys = this.browserStorage.getKeys();\n    allKeys.forEach(key => {\n      if (this.isCredentialKey(key)) {\n        // Get item, parse, validate and write key to map\n        const value = this.getItem(key);\n        if (value) {\n          const credObj = this.validateAndParseJson(value);\n          if (credObj && credObj.hasOwnProperty(\"credentialType\")) {\n            switch (credObj[\"credentialType\"]) {\n              case CredentialType.ID_TOKEN:\n                if (IdTokenEntity.isIdTokenEntity(credObj)) {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - idToken found, saving key to token key map\");\n                  this.logger.tracePii(`BrowserCacheManager:createKeyMaps - idToken with key: ${key} found, saving key to token key map`);\n                  const idTokenEntity = CacheManager.toObject(new IdTokenEntity(), credObj);\n                  const newKey = this.updateCredentialCacheKey(key, idTokenEntity);\n                  this.addTokenKey(newKey, CredentialType.ID_TOKEN);\n                  return;\n                } else {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching idToken schema with value containing idToken credentialType field but value failed IdTokenEntity validation, skipping.\");\n                  this.logger.tracePii(`BrowserCacheManager:createKeyMaps - failed idToken validation on key: ${key}`);\n                }\n                break;\n              case CredentialType.ACCESS_TOKEN:\n              case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n                if (AccessTokenEntity.isAccessTokenEntity(credObj)) {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - accessToken found, saving key to token key map\");\n                  this.logger.tracePii(`BrowserCacheManager:createKeyMaps - accessToken with key: ${key} found, saving key to token key map`);\n                  const accessTokenEntity = CacheManager.toObject(new AccessTokenEntity(), credObj);\n                  const newKey = this.updateCredentialCacheKey(key, accessTokenEntity);\n                  this.addTokenKey(newKey, CredentialType.ACCESS_TOKEN);\n                  return;\n                } else {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching accessToken schema with value containing accessToken credentialType field but value failed AccessTokenEntity validation, skipping.\");\n                  this.logger.tracePii(`BrowserCacheManager:createKeyMaps - failed accessToken validation on key: ${key}`);\n                }\n                break;\n              case CredentialType.REFRESH_TOKEN:\n                if (RefreshTokenEntity.isRefreshTokenEntity(credObj)) {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - refreshToken found, saving key to token key map\");\n                  this.logger.tracePii(`BrowserCacheManager:createKeyMaps - refreshToken with key: ${key} found, saving key to token key map`);\n                  const refreshTokenEntity = CacheManager.toObject(new RefreshTokenEntity(), credObj);\n                  const newKey = this.updateCredentialCacheKey(key, refreshTokenEntity);\n                  this.addTokenKey(newKey, CredentialType.REFRESH_TOKEN);\n                  return;\n                } else {\n                  this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching refreshToken schema with value containing refreshToken credentialType field but value failed RefreshTokenEntity validation, skipping.\");\n                  this.logger.tracePii(`BrowserCacheManager:createKeyMaps - failed refreshToken validation on key: ${key}`);\n                }\n                break;\n              // If credentialType isn't one of our predefined ones, it may not be an MSAL cache value. Ignore.\n            }\n          }\n        }\n      }\n\n      if (this.isAccountKey(key)) {\n        const value = this.getItem(key);\n        if (value) {\n          const accountObj = this.validateAndParseJson(value);\n          if (accountObj && AccountEntity.isAccountEntity(accountObj)) {\n            this.logger.trace(\"BrowserCacheManager:createKeyMaps - account found, saving key to account key map\");\n            this.logger.tracePii(`BrowserCacheManager:createKeyMaps - account with key: ${key} found, saving key to account key map`);\n            this.addAccountKeyToMap(key);\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Parses passed value as JSON object, JSON.parse() will throw an error.\n   * @param input\n   */\n  validateAndParseJson(jsonValue) {\n    try {\n      const parsedJson = JSON.parse(jsonValue);\n      /**\n       * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\n       * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\n       * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\n       *\n       */\n      return parsedJson && typeof parsedJson === \"object\" ? parsedJson : null;\n    } catch (error) {\n      return null;\n    }\n  }\n  /**\n   * fetches the entry from the browser storage based off the key\n   * @param key\n   */\n  getItem(key) {\n    return this.browserStorage.getItem(key);\n  }\n  /**\n   * sets the entry in the browser storage\n   * @param key\n   * @param value\n   */\n  setItem(key, value) {\n    this.browserStorage.setItem(key, value);\n  }\n  /**\n   * fetch the account entity from the platform cache\n   * @param accountKey\n   */\n  getAccount(accountKey) {\n    this.logger.trace(\"BrowserCacheManager.getAccount called\");\n    const account = this.getItem(accountKey);\n    if (!account) {\n      this.removeAccountKeyFromMap(accountKey);\n      return null;\n    }\n    const parsedAccount = this.validateAndParseJson(account);\n    if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n      this.removeAccountKeyFromMap(accountKey);\n      return null;\n    }\n    return CacheManager.toObject(new AccountEntity(), parsedAccount);\n  }\n  /**\n   * set account entity in the platform cache\n   * @param account\n   */\n  setAccount(account) {\n    this.logger.trace(\"BrowserCacheManager.setAccount called\");\n    const key = account.generateAccountKey();\n    this.setItem(key, JSON.stringify(account));\n    this.addAccountKeyToMap(key);\n  }\n  /**\n   * Returns the array of account keys currently cached\n   * @returns\n   */\n  getAccountKeys() {\n    this.logger.trace(\"BrowserCacheManager.getAccountKeys called\");\n    const accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n    if (accountKeys) {\n      return JSON.parse(accountKeys);\n    }\n    this.logger.verbose(\"BrowserCacheManager.getAccountKeys - No account keys found\");\n    return [];\n  }\n  /**\n   * Add a new account to the key map\n   * @param key\n   */\n  addAccountKeyToMap(key) {\n    this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\n    this.logger.tracePii(`BrowserCacheManager.addAccountKeyToMap called with key: ${key}`);\n    const accountKeys = this.getAccountKeys();\n    if (accountKeys.indexOf(key) === -1) {\n      // Only add key if it does not already exist in the map\n      accountKeys.push(key);\n      this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key added\");\n    } else {\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key already exists in map\");\n    }\n  }\n  /**\n   * Remove an account from the key map\n   * @param key\n   */\n  removeAccountKeyFromMap(key) {\n    this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\n    this.logger.tracePii(`BrowserCacheManager.removeAccountKeyFromMap called with key: ${key}`);\n    const accountKeys = this.getAccountKeys();\n    const removalIndex = accountKeys.indexOf(key);\n    if (removalIndex > -1) {\n      accountKeys.splice(removalIndex, 1);\n      this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap account key removed\");\n    } else {\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\");\n    }\n  }\n  /**\n   * Extends inherited removeAccount function to include removal of the account key from the map\n   * @param key\n   */\n  async removeAccount(key) {\n    void super.removeAccount(key);\n    this.removeAccountKeyFromMap(key);\n  }\n  /**\n   * Removes given idToken from the cache and from the key map\n   * @param key\n   */\n  removeIdToken(key) {\n    super.removeIdToken(key);\n    this.removeTokenKey(key, CredentialType.ID_TOKEN);\n  }\n  /**\n   * Removes given accessToken from the cache and from the key map\n   * @param key\n   */\n  async removeAccessToken(key) {\n    void super.removeAccessToken(key);\n    this.removeTokenKey(key, CredentialType.ACCESS_TOKEN);\n  }\n  /**\n   * Removes given refreshToken from the cache and from the key map\n   * @param key\n   */\n  removeRefreshToken(key) {\n    super.removeRefreshToken(key);\n    this.removeTokenKey(key, CredentialType.REFRESH_TOKEN);\n  }\n  /**\n   * Gets the keys for the cached tokens associated with this clientId\n   * @returns\n   */\n  getTokenKeys() {\n    this.logger.trace(\"BrowserCacheManager.getTokenKeys called\");\n    const item = this.getItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`);\n    if (item) {\n      const tokenKeys = this.validateAndParseJson(item);\n      if (tokenKeys && tokenKeys.hasOwnProperty(\"idToken\") && tokenKeys.hasOwnProperty(\"accessToken\") && tokenKeys.hasOwnProperty(\"refreshToken\")) {\n        return tokenKeys;\n      } else {\n        this.logger.error(\"BrowserCacheManager.getTokenKeys - Token keys found but in an unknown format. Returning empty key map.\");\n      }\n    } else {\n      this.logger.verbose(\"BrowserCacheManager.getTokenKeys - No token keys found\");\n    }\n    return {\n      idToken: [],\n      accessToken: [],\n      refreshToken: []\n    };\n  }\n  /**\n   * Adds the given key to the token key map\n   * @param key\n   * @param type\n   */\n  addTokenKey(key, type) {\n    this.logger.trace(\"BrowserCacheManager addTokenKey called\");\n    const tokenKeys = this.getTokenKeys();\n    switch (type) {\n      case CredentialType.ID_TOKEN:\n        if (tokenKeys.idToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - idToken added to map\");\n          tokenKeys.idToken.push(key);\n        }\n        break;\n      case CredentialType.ACCESS_TOKEN:\n        if (tokenKeys.accessToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - accessToken added to map\");\n          tokenKeys.accessToken.push(key);\n        }\n        break;\n      case CredentialType.REFRESH_TOKEN:\n        if (tokenKeys.refreshToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - refreshToken added to map\");\n          tokenKeys.refreshToken.push(key);\n        }\n        break;\n      default:\n        this.logger.error(`BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: ${type}`);\n        ClientAuthError.createUnexpectedCredentialTypeError();\n    }\n    this.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));\n  }\n  /**\n   * Removes the given key from the token key map\n   * @param key\n   * @param type\n   */\n  removeTokenKey(key, type) {\n    this.logger.trace(\"BrowserCacheManager removeTokenKey called\");\n    const tokenKeys = this.getTokenKeys();\n    switch (type) {\n      case CredentialType.ID_TOKEN:\n        this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: ${key} from map`);\n        const idRemoval = tokenKeys.idToken.indexOf(key);\n        if (idRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken removed from map\");\n          tokenKeys.idToken.splice(idRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      case CredentialType.ACCESS_TOKEN:\n        this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: ${key} from map`);\n        const accessRemoval = tokenKeys.accessToken.indexOf(key);\n        if (accessRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken removed from map\");\n          tokenKeys.accessToken.splice(accessRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      case CredentialType.REFRESH_TOKEN:\n        this.logger.infoPii(`BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: ${key} from map`);\n        const refreshRemoval = tokenKeys.refreshToken.indexOf(key);\n        if (refreshRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken removed from map\");\n          tokenKeys.refreshToken.splice(refreshRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      default:\n        this.logger.error(`BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: ${type}`);\n        ClientAuthError.createUnexpectedCredentialTypeError();\n    }\n    this.setItem(`${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`, JSON.stringify(tokenKeys));\n  }\n  /**\n   * generates idToken entity from a string\n   * @param idTokenKey\n   */\n  getIdTokenCredential(idTokenKey) {\n    const value = this.getItem(idTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n      return null;\n    }\n    const parsedIdToken = this.validateAndParseJson(value);\n    if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\n    return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\n  }\n  /**\n   * set IdToken credential to the platform cache\n   * @param idToken\n   */\n  setIdTokenCredential(idToken) {\n    this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n    const idTokenKey = idToken.generateCredentialKey();\n    this.setItem(idTokenKey, JSON.stringify(idToken));\n    this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n  }\n  /**\n   * generates accessToken entity from a string\n   * @param key\n   */\n  getAccessTokenCredential(accessTokenKey) {\n    const value = this.getItem(accessTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n      return null;\n    }\n    const parsedAccessToken = this.validateAndParseJson(value);\n    if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\n    return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);\n  }\n  /**\n   * set accessToken credential to the platform cache\n   * @param accessToken\n   */\n  setAccessTokenCredential(accessToken) {\n    this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\n    const accessTokenKey = accessToken.generateCredentialKey();\n    this.setItem(accessTokenKey, JSON.stringify(accessToken));\n    this.addTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n  }\n  /**\n   * generates refreshToken entity from a string\n   * @param refreshTokenKey\n   */\n  getRefreshTokenCredential(refreshTokenKey) {\n    const value = this.getItem(refreshTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n      return null;\n    }\n    const parsedRefreshToken = this.validateAndParseJson(value);\n    if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\n    return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);\n  }\n  /**\n   * set refreshToken credential to the platform cache\n   * @param refreshToken\n   */\n  setRefreshTokenCredential(refreshToken) {\n    this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\n    const refreshTokenKey = refreshToken.generateCredentialKey();\n    this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\n    this.addTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n  }\n  /**\n   * fetch appMetadata entity from the platform cache\n   * @param appMetadataKey\n   */\n  getAppMetadata(appMetadataKey) {\n    const value = this.getItem(appMetadataKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    const parsedMetadata = this.validateAndParseJson(value);\n    if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n    return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\n  }\n  /**\n   * set appMetadata entity to the platform cache\n   * @param appMetadata\n   */\n  setAppMetadata(appMetadata) {\n    this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n    const appMetadataKey = appMetadata.generateAppMetadataKey();\n    this.setItem(appMetadataKey, JSON.stringify(appMetadata));\n  }\n  /**\n   * fetch server telemetry entity from the platform cache\n   * @param serverTelemetryKey\n   */\n  getServerTelemetry(serverTelemetryKey) {\n    const value = this.getItem(serverTelemetryKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    const parsedMetadata = this.validateAndParseJson(value);\n    if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n    return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);\n  }\n  /**\n   * set server telemetry entity to the platform cache\n   * @param serverTelemetryKey\n   * @param serverTelemetry\n   */\n  setServerTelemetry(serverTelemetryKey, serverTelemetry) {\n    this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n    this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\n  }\n  /**\n   *\n   */\n  getAuthorityMetadata(key) {\n    const value = this.internalStorage.getItem(key);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\n      return null;\n    }\n    const parsedMetadata = this.validateAndParseJson(value);\n    if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\n      return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);\n    }\n    return null;\n  }\n  /**\n   *\n   */\n  getAuthorityMetadataKeys() {\n    const allKeys = this.internalStorage.getKeys();\n    return allKeys.filter(key => {\n      return this.isAuthorityMetadata(key);\n    });\n  }\n  /**\n   * Sets wrapper metadata in memory\n   * @param wrapperSKU\n   * @param wrapperVersion\n   */\n  setWrapperMetadata(wrapperSKU, wrapperVersion) {\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\n  }\n  /**\n   * Returns wrapper metadata from in-memory storage\n   */\n  getWrapperMetadata() {\n    const sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;\n    const version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;\n    return [sku, version];\n  }\n  /**\n   *\n   * @param entity\n   */\n  setAuthorityMetadata(key, entity) {\n    this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n    this.internalStorage.setItem(key, JSON.stringify(entity));\n  }\n  /**\n   * Gets the active account\n   */\n  getActiveAccount() {\n    const activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    const activeAccountValueFilters = this.getItem(activeAccountKeyFilters);\n    if (!activeAccountValueFilters) {\n      // if new active account cache type isn't found, it's an old version, so look for that instead\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account filters cache schema found, looking for legacy schema\");\n      const activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n      const activeAccountValueLocal = this.getItem(activeAccountKeyLocal);\n      if (!activeAccountValueLocal) {\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n        return null;\n      }\n      const activeAccount = this.getAccountInfoByFilter({\n        localAccountId: activeAccountValueLocal\n      })[0] || null;\n      if (activeAccount) {\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: Legacy active account cache schema found\");\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: Adding active account filters cache schema\");\n        this.setActiveAccount(activeAccount);\n        return activeAccount;\n      }\n      return null;\n    }\n    const activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters);\n    if (activeAccountValueObj) {\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: Active account filters schema found\");\n      return this.getAccountInfoByFilter({\n        homeAccountId: activeAccountValueObj.homeAccountId,\n        localAccountId: activeAccountValueObj.localAccountId\n      })[0] || null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n    return null;\n  }\n  /**\n   * Sets the active account's localAccountId in cache\n   * @param account\n   */\n  setActiveAccount(account) {\n    const activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    const activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n    if (account) {\n      this.logger.verbose(\"setActiveAccount: Active account set\");\n      const activeAccountValue = {\n        homeAccountId: account.homeAccountId,\n        localAccountId: account.localAccountId\n      };\n      this.browserStorage.setItem(activeAccountKey, JSON.stringify(activeAccountValue));\n      this.browserStorage.setItem(activeAccountKeyLocal, account.localAccountId);\n    } else {\n      this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\n      this.browserStorage.removeItem(activeAccountKey);\n      this.browserStorage.removeItem(activeAccountKeyLocal);\n    }\n  }\n  /**\n   * Gets a list of accounts that match all of the filters provided\n   * @param account\n   */\n  getAccountInfoByFilter(accountFilter) {\n    const allAccounts = this.getAllAccounts();\n    this.logger.trace(`BrowserCacheManager.getAccountInfoByFilter: total ${allAccounts.length} accounts found`);\n    return allAccounts.filter(accountObj => {\n      if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {\n        return false;\n      }\n      if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {\n        return false;\n      }\n      if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {\n        return false;\n      }\n      if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {\n        return false;\n      }\n      if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {\n        return false;\n      }\n      return true;\n    });\n  }\n  /**\n   * Checks the cache for accounts matching loginHint or SID\n   * @param loginHint\n   * @param sid\n   */\n  getAccountInfoByHints(loginHint, sid) {\n    const matchingAccounts = this.getAllAccounts().filter(accountInfo => {\n      if (sid) {\n        const accountSid = accountInfo.idTokenClaims && accountInfo.idTokenClaims[\"sid\"];\n        return sid === accountSid;\n      }\n      if (loginHint) {\n        return loginHint === accountInfo.username;\n      }\n      return false;\n    });\n    if (matchingAccounts.length === 1) {\n      return matchingAccounts[0];\n    } else if (matchingAccounts.length > 1) {\n      throw ClientAuthError.createMultipleMatchingAccountsInCacheError();\n    }\n    return null;\n  }\n  /**\n   * fetch throttling entity from the platform cache\n   * @param throttlingCacheKey\n   */\n  getThrottlingCache(throttlingCacheKey) {\n    const value = this.getItem(throttlingCacheKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    const parsedThrottlingCache = this.validateAndParseJson(value);\n    if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n    return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);\n  }\n  /**\n   * set throttling entity to the platform cache\n   * @param throttlingCacheKey\n   * @param throttlingCache\n   */\n  setThrottlingCache(throttlingCacheKey, throttlingCache) {\n    this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n    this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\n  }\n  /**\n   * Gets cache item with given key.\n   * Will retrieve from cookies if storeAuthStateInCookie is set to true.\n   * @param key\n   */\n  getTemporaryCache(cacheKey, generateKey) {\n    const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      const itemCookie = this.getItemCookie(key);\n      if (itemCookie) {\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\n        return itemCookie;\n      }\n    }\n    const value = this.temporaryCacheStorage.getItem(key);\n    if (!value) {\n      // If temp cache item not found in session/memory, check local storage for items set by old versions\n      if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n        const item = this.browserStorage.getItem(key);\n        if (item) {\n          this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\n          return item;\n        }\n      }\n      this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\n    return value;\n  }\n  /**\n   * Sets the cache item with the key and value given.\n   * Stores in cookie if storeAuthStateInCookie is set to true.\n   * This can cause cookie overflow if used incorrectly.\n   * @param key\n   * @param value\n   */\n  setTemporaryCache(cacheKey, value, generateKey) {\n    const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    this.temporaryCacheStorage.setItem(key, value);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\n      this.setItemCookie(key, value);\n    }\n  }\n  /**\n   * Removes the cache item with the given key.\n   * Will also clear the cookie item if storeAuthStateInCookie is set to true.\n   * @param key\n   */\n  removeItem(key) {\n    this.browserStorage.removeItem(key);\n    this.temporaryCacheStorage.removeItem(key);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\n      this.clearItemCookie(key);\n    }\n  }\n  /**\n   * Checks whether key is in cache.\n   * @param key\n   */\n  containsKey(key) {\n    return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key);\n  }\n  /**\n   * Gets all keys in window.\n   */\n  getKeys() {\n    return [...this.browserStorage.getKeys(), ...this.temporaryCacheStorage.getKeys()];\n  }\n  /**\n   * Clears all cache entries created by MSAL.\n   */\n  async clear() {\n    // Removes all accounts and their credentials\n    await this.removeAllAccounts();\n    this.removeAppMetadata();\n    // Removes all remaining MSAL cache items\n    this.getKeys().forEach(cacheKey => {\n      // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\n      if ((this.browserStorage.containsKey(cacheKey) || this.temporaryCacheStorage.containsKey(cacheKey)) && (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(this.clientId) !== -1)) {\n        this.removeItem(cacheKey);\n      }\n    });\n    this.internalStorage.clear();\n  }\n  /**\n   * Clears all access tokes that have claims prior to saving the current one\n   * @param credential\n   * @returns\n   */\n  async clearTokensAndKeysWithClaims() {\n    const tokenKeys = this.getTokenKeys();\n    const removedAccessTokens = [];\n    tokenKeys.accessToken.forEach(key => {\n      // if the access token has claims in its key, remove the token key and the token\n      const credential = this.getAccessTokenCredential(key);\n      if (credential?.requestedClaimsHash && key.includes(credential.requestedClaimsHash.toLowerCase())) {\n        removedAccessTokens.push(this.removeAccessToken(key));\n      }\n    });\n    await Promise.all(removedAccessTokens);\n    // warn if any access tokens are removed\n    if (removedAccessTokens.length > 0) {\n      this.logger.warning(`${removedAccessTokens.length} access tokens with claims in the cache keys have been removed from the cache.`);\n    }\n  }\n  /**\n   * Add value to cookies\n   * @param cookieName\n   * @param cookieValue\n   * @param expires\n   */\n  setItemCookie(cookieName, cookieValue, expires) {\n    let cookieStr = `${encodeURIComponent(cookieName)}=${encodeURIComponent(cookieValue)};path=/;SameSite=Lax;`;\n    if (expires) {\n      const expireTime = this.getCookieExpirationTime(expires);\n      cookieStr += `expires=${expireTime};`;\n    }\n    if (this.cacheConfig.secureCookies) {\n      cookieStr += \"Secure;\";\n    }\n    document.cookie = cookieStr;\n  }\n  /**\n   * Get one item by key from cookies\n   * @param cookieName\n   */\n  getItemCookie(cookieName) {\n    const name = `${encodeURIComponent(cookieName)}=`;\n    const cookieList = document.cookie.split(\";\");\n    for (let i = 0; i < cookieList.length; i++) {\n      let cookie = cookieList[i];\n      while (cookie.charAt(0) === \" \") {\n        cookie = cookie.substring(1);\n      }\n      if (cookie.indexOf(name) === 0) {\n        return decodeURIComponent(cookie.substring(name.length, cookie.length));\n      }\n    }\n    return Constants.EMPTY_STRING;\n  }\n  /**\n   * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\n   */\n  clearMsalCookies() {\n    const cookiePrefix = `${Constants.CACHE_PREFIX}.${this.clientId}`;\n    const cookieList = document.cookie.split(\";\");\n    cookieList.forEach(cookie => {\n      while (cookie.charAt(0) === \" \") {\n        // eslint-disable-next-line no-param-reassign\n        cookie = cookie.substring(1);\n      }\n      if (cookie.indexOf(cookiePrefix) === 0) {\n        const cookieKey = cookie.split(\"=\")[0];\n        this.clearItemCookie(cookieKey);\n      }\n    });\n  }\n  /**\n   * Clear an item in the cookies by key\n   * @param cookieName\n   */\n  clearItemCookie(cookieName) {\n    this.setItemCookie(cookieName, Constants.EMPTY_STRING, -1);\n  }\n  /**\n   * Get cookie expiration time\n   * @param cookieLifeDays\n   */\n  getCookieExpirationTime(cookieLifeDays) {\n    const today = new Date();\n    const expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);\n    return expr.toUTCString();\n  }\n  /**\n   * Gets the cache object referenced by the browser\n   */\n  getCache() {\n    return this.browserStorage;\n  }\n  /**\n   * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\n   */\n  setCache() {\n    // sets nothing\n  }\n  /**\n   * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\n   * @param key\n   * @param addInstanceId\n   */\n  generateCacheKey(key) {\n    const generatedKey = this.validateAndParseJson(key);\n    if (!generatedKey) {\n      if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\n        return key;\n      }\n      return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;\n    }\n    return JSON.stringify(key);\n  }\n  /**\n   * Create authorityKey to cache authority\n   * @param state\n   */\n  generateAuthorityKey(stateString) {\n    const {\n      libraryState: {\n        id: stateId\n      }\n    } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n    return this.generateCacheKey(`${TemporaryCacheKeys.AUTHORITY}.${stateId}`);\n  }\n  /**\n   * Create Nonce key to cache nonce\n   * @param state\n   */\n  generateNonceKey(stateString) {\n    const {\n      libraryState: {\n        id: stateId\n      }\n    } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n    return this.generateCacheKey(`${TemporaryCacheKeys.NONCE_IDTOKEN}.${stateId}`);\n  }\n  /**\n   * Creates full cache key for the request state\n   * @param stateString State string for the request\n   */\n  generateStateKey(stateString) {\n    // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\n    const {\n      libraryState: {\n        id: stateId\n      }\n    } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n    return this.generateCacheKey(`${TemporaryCacheKeys.REQUEST_STATE}.${stateId}`);\n  }\n  /**\n   * Gets the cached authority based on the cached state. Returns empty if no cached state found.\n   */\n  getCachedAuthority(cachedState) {\n    const stateCacheKey = this.generateStateKey(cachedState);\n    const state = this.getTemporaryCache(stateCacheKey);\n    if (!state) {\n      return null;\n    }\n    const authorityCacheKey = this.generateAuthorityKey(state);\n    return this.getTemporaryCache(authorityCacheKey);\n  }\n  /**\n   * Updates account, authority, and state in cache\n   * @param serverAuthenticationRequest\n   * @param account\n   */\n  updateCacheEntries(state, nonce, authorityInstance, loginHint, account) {\n    this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\");\n    // Cache the request state\n    const stateCacheKey = this.generateStateKey(state);\n    this.setTemporaryCache(stateCacheKey, state, false);\n    // Cache the nonce\n    const nonceCacheKey = this.generateNonceKey(state);\n    this.setTemporaryCache(nonceCacheKey, nonce, false);\n    // Cache authorityKey\n    const authorityCacheKey = this.generateAuthorityKey(state);\n    this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\n    if (account) {\n      const ccsCredential = {\n        credential: account.homeAccountId,\n        type: CcsCredentialType.HOME_ACCOUNT_ID\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    } else if (loginHint) {\n      const ccsCredential = {\n        credential: loginHint,\n        type: CcsCredentialType.UPN\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    }\n  }\n  /**\n   * Reset all temporary cache items\n   * @param state\n   */\n  resetRequestCache(state) {\n    this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\n    // check state and remove associated cache items\n    if (state) {\n      this.getKeys().forEach(key => {\n        if (key.indexOf(state) !== -1) {\n          this.removeItem(key);\n        }\n      });\n      // delete generic interactive request parameters\n      this.removeItem(this.generateStateKey(state));\n      this.removeItem(this.generateNonceKey(state));\n      this.removeItem(this.generateAuthorityKey(state));\n    }\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\n    this.setInteractionInProgress(false);\n  }\n  /**\n   * Removes temporary cache for the provided state\n   * @param stateString\n   */\n  cleanRequestByState(stateString) {\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\");\n    // Interaction is completed - remove interaction status.\n    if (stateString) {\n      const stateKey = this.generateStateKey(stateString);\n      const cachedState = this.temporaryCacheStorage.getItem(stateKey);\n      this.logger.infoPii(`BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: ${cachedState}`);\n      this.resetRequestCache(cachedState || Constants.EMPTY_STRING);\n    }\n    this.clearMsalCookies();\n  }\n  /**\n   * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\n   * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\n   * @param interactionType\n   */\n  cleanRequestByInteractionType(interactionType) {\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\");\n    // Loop through all keys to find state key\n    this.getKeys().forEach(key => {\n      // If this key is not the state key, move on\n      if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\n        return;\n      }\n      // Retrieve state value, return if not a valid value\n      const stateValue = this.temporaryCacheStorage.getItem(key);\n      if (!stateValue) {\n        return;\n      }\n      // Extract state and ensure it matches given InteractionType, then clean request cache\n      const parsedState = BrowserProtocolUtils.extractBrowserRequestState(this.cryptoImpl, stateValue);\n      if (parsedState && parsedState.interactionType === interactionType) {\n        this.logger.infoPii(`BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: ${stateValue}`);\n        this.resetRequestCache(stateValue);\n      }\n    });\n    this.clearMsalCookies();\n    this.setInteractionInProgress(false);\n  }\n  cacheCodeRequest(authCodeRequest) {\n    this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\n    const encodedValue = base64Encode(JSON.stringify(authCodeRequest));\n    this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\n  }\n  /**\n   * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\n   */\n  getCachedRequest(state) {\n    this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\n    // Get token request from cache and parse as TokenExchangeParameters.\n    const encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\n    if (!encodedTokenRequest) {\n      throw createBrowserAuthError(noTokenRequestCacheError);\n    }\n    let parsedRequest;\n    try {\n      parsedRequest = JSON.parse(base64Decode(encodedTokenRequest));\n    } catch (e) {\n      this.logger.errorPii(`Attempted to parse: ${encodedTokenRequest}`);\n      this.logger.error(`Parsing cached token request threw with error: ${e}`);\n      throw createBrowserAuthError(unableToParseTokenRequestCacheError);\n    }\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    // Get cached authority and use if no authority is cached with request.\n    if (!parsedRequest.authority) {\n      const authorityCacheKey = this.generateAuthorityKey(state);\n      const cachedAuthority = this.getTemporaryCache(authorityCacheKey);\n      if (!cachedAuthority) {\n        throw createBrowserAuthError(noCachedAuthorityError);\n      }\n      parsedRequest.authority = cachedAuthority;\n    }\n    return parsedRequest;\n  }\n  /**\n   * Gets cached native request for redirect flows\n   */\n  getCachedNativeRequest() {\n    this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n    const cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);\n    if (!cachedRequest) {\n      this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest: No cached native request found\");\n      return null;\n    }\n    const parsedRequest = this.validateAndParseJson(cachedRequest);\n    if (!parsedRequest) {\n      this.logger.error(\"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\");\n      return null;\n    }\n    return parsedRequest;\n  }\n  isInteractionInProgress(matchClientId) {\n    const clientId = this.getInteractionInProgress();\n    if (matchClientId) {\n      return clientId === this.clientId;\n    } else {\n      return !!clientId;\n    }\n  }\n  getInteractionInProgress() {\n    const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n    return this.getTemporaryCache(key, false);\n  }\n  setInteractionInProgress(inProgress) {\n    // Ensure we don't overwrite interaction in progress for a different clientId\n    const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n    if (inProgress) {\n      if (this.getInteractionInProgress()) {\n        throw createBrowserAuthError(interactionInProgress);\n      } else {\n        // No interaction is in progress\n        this.setTemporaryCache(key, this.clientId, false);\n      }\n    } else if (!inProgress && this.getInteractionInProgress() === this.clientId) {\n      this.removeItem(key);\n    }\n  }\n  /**\n   * Returns username retrieved from ADAL or MSAL v1 idToken\n   * @deprecated\n   */\n  getLegacyLoginHint() {\n    // Only check for adal/msal token if no SSO params are being used\n    const adalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);\n    if (adalIdTokenString) {\n      this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\n      this.logger.verbose(\"Cached ADAL id token retrieved.\");\n    }\n    // Check for cached MSAL v1 id token\n    const msalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, true);\n    if (msalIdTokenString) {\n      this.removeItem(this.generateCacheKey(PersistentCacheKeys.ID_TOKEN));\n      this.logger.verbose(\"Cached MSAL.js v1 id token retrieved\");\n    }\n    const cachedIdTokenString = msalIdTokenString || adalIdTokenString;\n    if (cachedIdTokenString) {\n      const idTokenClaims = AuthToken.extractTokenClaims(cachedIdTokenString, base64Decode);\n      if (idTokenClaims.preferred_username) {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint\");\n        return idTokenClaims.preferred_username;\n      } else if (idTokenClaims.upn) {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint\");\n        return idTokenClaims.upn;\n      } else {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.\");\n      }\n    }\n    return null;\n  }\n  /**\n   * Updates a credential's cache key if the current cache key is outdated\n   */\n  updateCredentialCacheKey(currentCacheKey, credential) {\n    const updatedCacheKey = credential.generateCredentialKey();\n    if (currentCacheKey !== updatedCacheKey) {\n      const cacheItem = this.getItem(currentCacheKey);\n      if (cacheItem) {\n        this.removeItem(currentCacheKey);\n        this.setItem(updatedCacheKey, cacheItem);\n        this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);\n        return updatedCacheKey;\n      } else {\n        this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);\n      }\n    }\n    return currentCacheKey;\n  }\n  /**\n   * Returns application id as redirect context during AcquireTokenRedirect flow.\n   */\n  getRedirectRequestContext() {\n    return this.getTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, true);\n  }\n  /**\n   * Sets application id as the redirect context during AcquireTokenRedirect flow.\n   * @param value\n   */\n  setRedirectRequestContext(value) {\n    this.setTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, value, true);\n  }\n  /**\n   * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache\n   * @param result\n   * @param request\n   */\n  async hydrateCache(result, request) {\n    const idTokenEntity = IdTokenEntity.createIdTokenEntity(result.account?.homeAccountId, result.account?.environment, result.idToken, this.clientId, result.tenantId);\n    let claimsHash;\n    if (request.claims) {\n      claimsHash = await this.cryptoImpl.hashString(request.claims);\n    }\n    const accessTokenEntity = AccessTokenEntity.createAccessTokenEntity(result.account?.homeAccountId, result.account.environment, result.accessToken, this.clientId, result.tenantId, result.scopes.join(\" \"), result.expiresOn?.getTime() || 0, result.extExpiresOn?.getTime() || 0, this.cryptoImpl, undefined,\n    // refreshOn\n    result.tokenType, undefined,\n    // userAssertionHash\n    request.sshKid, request.claims, claimsHash);\n    const cacheRecord = new CacheRecord(undefined, idTokenEntity, accessTokenEntity);\n    return this.saveCacheRecord(cacheRecord);\n  }\n}\nconst DEFAULT_BROWSER_CACHE_MANAGER = (clientId, logger) => {\n  const cacheOptions = {\n    cacheLocation: BrowserCacheLocation.MemoryStorage,\n    temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\n    storeAuthStateInCookie: false,\n    secureCookies: false,\n    cacheMigrationEnabled: false,\n    claimsBasedCachingEnabled: false\n  };\n  return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\n};\nexport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER };","map":{"version":3,"names":["BrowserCacheManager","CacheManager","constructor","clientId","cacheConfig","cryptoImpl","logger","COOKIE_LIFE_MULTIPLIER","internalStorage","MemoryStorage","cacheMigrationEnabled","migrateCacheEntries","cacheLocation","BrowserCacheLocation","LocalStorage","SessionStorage","verbose","e","idTokenKey","Constants","CACHE_PREFIX","PersistentCacheKeys","ID_TOKEN","clientInfoKey","CLIENT_INFO","idTokenValue","browserStorage","getItem","clientInfoValue","errorValue","errorKey","keysToMigrate","forEach","cacheKey","index","migrateCacheEntry","values","value","setTemporaryCache","newKey","accountKeys","StaticCacheKeys","ACCOUNT_KEYS","tokenKeys","TOKEN_KEYS","allKeys","getKeys","key","credObj","validateAndParseJson","CredentialType","IdTokenEntity","isIdTokenEntity","trace","updateCredentialCacheKey","idTokenEntity","addTokenKey","tracePii","ACCESS_TOKEN_WITH_AUTH_SCHEME","AccessTokenEntity","isAccessTokenEntity","accessTokenEntity","ACCESS_TOKEN","RefreshTokenEntity","isRefreshTokenEntity","REFRESH_TOKEN","isAccountKey","addAccountKeyToMap","parsedJson","JSON","parse","jsonValue","error","setItem","getAccount","accountKey","parsedAccount","account","AccountEntity","isAccountEntity","toObject","setAccount","stringify","getAccountKeys","indexOf","push","removeAccountKeyFromMap","removalIndex","splice","removeAccount","removeIdToken","removeTokenKey","removeRefreshToken","item","hasOwnProperty","accessToken","refreshToken","type","idToken","info"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\cache\\BrowserCacheManager.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    Constants,\n    PersistentCacheKeys,\n    StringUtils,\n    CommonAuthorizationCodeRequest,\n    ICrypto,\n    AccountEntity,\n    IdTokenEntity,\n    AccessTokenEntity,\n    RefreshTokenEntity,\n    AppMetadataEntity,\n    CacheManager,\n    ServerTelemetryEntity,\n    ThrottlingEntity,\n    ProtocolUtils,\n    Logger,\n    AuthorityMetadataEntity,\n    DEFAULT_CRYPTO_IMPLEMENTATION,\n    AccountInfo,\n    ActiveAccountFilters,\n    CcsCredential,\n    CcsCredentialType,\n    AuthToken,\n    ValidCredentialType,\n    ClientAuthError,\n    TokenKeys,\n    CredentialType,\n    CacheRecord,\n    AuthenticationScheme,\n} from \"@azure/msal-common\";\nimport { CacheOptions } from \"../config/Configuration\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError\";\nimport {\n    BrowserCacheLocation,\n    InteractionType,\n    TemporaryCacheKeys,\n    InMemoryCacheKeys,\n    StaticCacheKeys,\n} from \"../utils/BrowserConstants\";\nimport { BrowserStorage } from \"./BrowserStorage\";\nimport { MemoryStorage } from \"./MemoryStorage\";\nimport { IWindowStorage } from \"./IWindowStorage\";\nimport { BrowserProtocolUtils } from \"../utils/BrowserProtocolUtils\";\nimport { NativeTokenRequest } from \"../broker/nativeBroker/NativeRequest\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\nimport { SilentRequest } from \"../request/SilentRequest\";\nimport { SsoSilentRequest } from \"../request/SsoSilentRequest\";\nimport { RedirectRequest } from \"../request/RedirectRequest\";\nimport { PopupRequest } from \"../request/PopupRequest\";\nimport { base64Decode } from \"../encode/Base64Decode\";\nimport { base64Encode } from \"../encode/Base64Encode\";\n\n/**\n * This class implements the cache storage interface for MSAL through browser local or session storage.\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\n * parameters such as state and nonce, generally.\n */\nexport class BrowserCacheManager extends CacheManager {\n    // Cache configuration, either set by user or default values.\n    protected cacheConfig: Required<CacheOptions>;\n    // Window storage object (either local or sessionStorage)\n    protected browserStorage: IWindowStorage<string>;\n    // Internal in-memory storage object used for data used by msal that does not need to persist across page loads\n    protected internalStorage: MemoryStorage<string>;\n    // Temporary cache\n    protected temporaryCacheStorage: IWindowStorage<string>;\n    // Logger instance\n    protected logger: Logger;\n\n    // Cookie life calculation (hours * minutes * seconds * ms)\n    protected readonly COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\n\n    constructor(\n        clientId: string,\n        cacheConfig: Required<CacheOptions>,\n        cryptoImpl: ICrypto,\n        logger: Logger\n    ) {\n        super(clientId, cryptoImpl, logger);\n        this.cacheConfig = cacheConfig;\n        this.logger = logger;\n        this.internalStorage = new MemoryStorage();\n        this.browserStorage = this.setupBrowserStorage(\n            this.cacheConfig.cacheLocation\n        );\n        this.temporaryCacheStorage = this.setupTemporaryCacheStorage(\n            this.cacheConfig.temporaryCacheLocation,\n            this.cacheConfig.cacheLocation\n        );\n\n        // Migrate cache entries from older versions of MSAL.\n        if (cacheConfig.cacheMigrationEnabled) {\n            this.migrateCacheEntries();\n            this.createKeyMaps();\n        }\n    }\n\n    /**\n     * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\n     * @param cacheLocation\n     */\n    protected setupBrowserStorage(\n        cacheLocation: BrowserCacheLocation | string\n    ): IWindowStorage<string> {\n        switch (cacheLocation) {\n            case BrowserCacheLocation.LocalStorage:\n            case BrowserCacheLocation.SessionStorage:\n                try {\n                    return new BrowserStorage(cacheLocation);\n                } catch (e) {\n                    this.logger.verbose(e as string);\n                    break;\n                }\n            case BrowserCacheLocation.MemoryStorage:\n            default:\n                break;\n        }\n        this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\n        return new MemoryStorage();\n    }\n\n    /**\n     * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured temporaryCacheLocation.\n     * @param temporaryCacheLocation\n     * @param cacheLocation\n     */\n    protected setupTemporaryCacheStorage(\n        temporaryCacheLocation: BrowserCacheLocation | string,\n        cacheLocation: BrowserCacheLocation | string\n    ): IWindowStorage<string> {\n        switch (cacheLocation) {\n            case BrowserCacheLocation.LocalStorage:\n            case BrowserCacheLocation.SessionStorage:\n                try {\n                    // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\n                    return new BrowserStorage(\n                        temporaryCacheLocation ||\n                            BrowserCacheLocation.SessionStorage\n                    );\n                } catch (e) {\n                    this.logger.verbose(e as string);\n                    return this.internalStorage;\n                }\n            case BrowserCacheLocation.MemoryStorage:\n            default:\n                return this.internalStorage;\n        }\n    }\n\n    /**\n     * Migrate all old cache entries to new schema. No rollback supported.\n     * @param storeAuthStateInCookie\n     */\n    protected migrateCacheEntries(): void {\n        const idTokenKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ID_TOKEN}`;\n        const clientInfoKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.CLIENT_INFO}`;\n        const errorKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR}`;\n        const errorDescKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR_DESC}`;\n\n        const idTokenValue = this.browserStorage.getItem(idTokenKey);\n        const clientInfoValue = this.browserStorage.getItem(clientInfoKey);\n        const errorValue = this.browserStorage.getItem(errorKey);\n        const errorDescValue = this.browserStorage.getItem(errorDescKey);\n\n        const values = [\n            idTokenValue,\n            clientInfoValue,\n            errorValue,\n            errorDescValue,\n        ];\n        const keysToMigrate = [\n            PersistentCacheKeys.ID_TOKEN,\n            PersistentCacheKeys.CLIENT_INFO,\n            PersistentCacheKeys.ERROR,\n            PersistentCacheKeys.ERROR_DESC,\n        ];\n\n        keysToMigrate.forEach((cacheKey: string, index: number) =>\n            this.migrateCacheEntry(cacheKey, values[index])\n        );\n    }\n\n    /**\n     * Utility function to help with migration.\n     * @param newKey\n     * @param value\n     * @param storeAuthStateInCookie\n     */\n    protected migrateCacheEntry(newKey: string, value: string | null): void {\n        if (value) {\n            this.setTemporaryCache(newKey, value, true);\n        }\n    }\n\n    /**\n     * Searches all cache entries for MSAL accounts and creates the account key map\n     * This is used to migrate users from older versions of MSAL which did not create the map.\n     * @returns\n     */\n    private createKeyMaps(): void {\n        this.logger.trace(\"BrowserCacheManager - createKeyMaps called.\");\n        const accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n        const tokenKeys = this.getItem(\n            `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`\n        );\n        if (accountKeys && tokenKeys) {\n            this.logger.verbose(\n                \"BrowserCacheManager:createKeyMaps - account and token key maps already exist, skipping migration.\"\n            );\n            // Key maps already exist, no need to iterate through cache\n            return;\n        }\n\n        const allKeys = this.browserStorage.getKeys();\n        allKeys.forEach((key) => {\n            if (this.isCredentialKey(key)) {\n                // Get item, parse, validate and write key to map\n                const value = this.getItem(key);\n                if (value) {\n                    const credObj = this.validateAndParseJson(value);\n                    if (credObj && credObj.hasOwnProperty(\"credentialType\")) {\n                        switch (credObj[\"credentialType\"]) {\n                            case CredentialType.ID_TOKEN:\n                                if (IdTokenEntity.isIdTokenEntity(credObj)) {\n                                    this.logger.trace(\n                                        \"BrowserCacheManager:createKeyMaps - idToken found, saving key to token key map\"\n                                    );\n                                    this.logger.tracePii(\n                                        `BrowserCacheManager:createKeyMaps - idToken with key: ${key} found, saving key to token key map`\n                                    );\n                                    const idTokenEntity = CacheManager.toObject(\n                                        new IdTokenEntity(),\n                                        credObj\n                                    );\n                                    const newKey =\n                                        this.updateCredentialCacheKey(\n                                            key,\n                                            idTokenEntity\n                                        );\n                                    this.addTokenKey(\n                                        newKey,\n                                        CredentialType.ID_TOKEN\n                                    );\n                                    return;\n                                } else {\n                                    this.logger.trace(\n                                        \"BrowserCacheManager:createKeyMaps - key found matching idToken schema with value containing idToken credentialType field but value failed IdTokenEntity validation, skipping.\"\n                                    );\n                                    this.logger.tracePii(\n                                        `BrowserCacheManager:createKeyMaps - failed idToken validation on key: ${key}`\n                                    );\n                                }\n                                break;\n                            case CredentialType.ACCESS_TOKEN:\n                            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n                                if (\n                                    AccessTokenEntity.isAccessTokenEntity(\n                                        credObj\n                                    )\n                                ) {\n                                    this.logger.trace(\n                                        \"BrowserCacheManager:createKeyMaps - accessToken found, saving key to token key map\"\n                                    );\n                                    this.logger.tracePii(\n                                        `BrowserCacheManager:createKeyMaps - accessToken with key: ${key} found, saving key to token key map`\n                                    );\n                                    const accessTokenEntity =\n                                        CacheManager.toObject(\n                                            new AccessTokenEntity(),\n                                            credObj\n                                        );\n                                    const newKey =\n                                        this.updateCredentialCacheKey(\n                                            key,\n                                            accessTokenEntity\n                                        );\n                                    this.addTokenKey(\n                                        newKey,\n                                        CredentialType.ACCESS_TOKEN\n                                    );\n                                    return;\n                                } else {\n                                    this.logger.trace(\n                                        \"BrowserCacheManager:createKeyMaps - key found matching accessToken schema with value containing accessToken credentialType field but value failed AccessTokenEntity validation, skipping.\"\n                                    );\n                                    this.logger.tracePii(\n                                        `BrowserCacheManager:createKeyMaps - failed accessToken validation on key: ${key}`\n                                    );\n                                }\n                                break;\n                            case CredentialType.REFRESH_TOKEN:\n                                if (\n                                    RefreshTokenEntity.isRefreshTokenEntity(\n                                        credObj\n                                    )\n                                ) {\n                                    this.logger.trace(\n                                        \"BrowserCacheManager:createKeyMaps - refreshToken found, saving key to token key map\"\n                                    );\n                                    this.logger.tracePii(\n                                        `BrowserCacheManager:createKeyMaps - refreshToken with key: ${key} found, saving key to token key map`\n                                    );\n                                    const refreshTokenEntity =\n                                        CacheManager.toObject(\n                                            new RefreshTokenEntity(),\n                                            credObj\n                                        );\n                                    const newKey =\n                                        this.updateCredentialCacheKey(\n                                            key,\n                                            refreshTokenEntity\n                                        );\n                                    this.addTokenKey(\n                                        newKey,\n                                        CredentialType.REFRESH_TOKEN\n                                    );\n                                    return;\n                                } else {\n                                    this.logger.trace(\n                                        \"BrowserCacheManager:createKeyMaps - key found matching refreshToken schema with value containing refreshToken credentialType field but value failed RefreshTokenEntity validation, skipping.\"\n                                    );\n                                    this.logger.tracePii(\n                                        `BrowserCacheManager:createKeyMaps - failed refreshToken validation on key: ${key}`\n                                    );\n                                }\n                                break;\n                            default:\n                            // If credentialType isn't one of our predefined ones, it may not be an MSAL cache value. Ignore.\n                        }\n                    }\n                }\n            }\n\n            if (this.isAccountKey(key)) {\n                const value = this.getItem(key);\n                if (value) {\n                    const accountObj = this.validateAndParseJson(value);\n                    if (\n                        accountObj &&\n                        AccountEntity.isAccountEntity(accountObj)\n                    ) {\n                        this.logger.trace(\n                            \"BrowserCacheManager:createKeyMaps - account found, saving key to account key map\"\n                        );\n                        this.logger.tracePii(\n                            `BrowserCacheManager:createKeyMaps - account with key: ${key} found, saving key to account key map`\n                        );\n                        this.addAccountKeyToMap(key);\n                    }\n                }\n            }\n        });\n    }\n\n    /**\n     * Parses passed value as JSON object, JSON.parse() will throw an error.\n     * @param input\n     */\n    protected validateAndParseJson(jsonValue: string): object | null {\n        try {\n            const parsedJson = JSON.parse(jsonValue);\n            /**\n             * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\n             * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\n             * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\n             *\n             */\n            return parsedJson && typeof parsedJson === \"object\"\n                ? parsedJson\n                : null;\n        } catch (error) {\n            return null;\n        }\n    }\n\n    /**\n     * fetches the entry from the browser storage based off the key\n     * @param key\n     */\n    getItem(key: string): string | null {\n        return this.browserStorage.getItem(key);\n    }\n\n    /**\n     * sets the entry in the browser storage\n     * @param key\n     * @param value\n     */\n    setItem(key: string, value: string): void {\n        this.browserStorage.setItem(key, value);\n    }\n\n    /**\n     * fetch the account entity from the platform cache\n     * @param accountKey\n     */\n    getAccount(accountKey: string): AccountEntity | null {\n        this.logger.trace(\"BrowserCacheManager.getAccount called\");\n        const account = this.getItem(accountKey);\n        if (!account) {\n            this.removeAccountKeyFromMap(accountKey);\n            return null;\n        }\n\n        const parsedAccount = this.validateAndParseJson(account);\n        if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n            this.removeAccountKeyFromMap(accountKey);\n            return null;\n        }\n\n        return CacheManager.toObject<AccountEntity>(\n            new AccountEntity(),\n            parsedAccount\n        );\n    }\n\n    /**\n     * set account entity in the platform cache\n     * @param account\n     */\n    setAccount(account: AccountEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setAccount called\");\n        const key = account.generateAccountKey();\n        this.setItem(key, JSON.stringify(account));\n        this.addAccountKeyToMap(key);\n    }\n\n    /**\n     * Returns the array of account keys currently cached\n     * @returns\n     */\n    getAccountKeys(): Array<string> {\n        this.logger.trace(\"BrowserCacheManager.getAccountKeys called\");\n        const accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n        if (accountKeys) {\n            return JSON.parse(accountKeys);\n        }\n\n        this.logger.verbose(\n            \"BrowserCacheManager.getAccountKeys - No account keys found\"\n        );\n        return [];\n    }\n\n    /**\n     * Add a new account to the key map\n     * @param key\n     */\n    addAccountKeyToMap(key: string): void {\n        this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\n        this.logger.tracePii(\n            `BrowserCacheManager.addAccountKeyToMap called with key: ${key}`\n        );\n        const accountKeys = this.getAccountKeys();\n        if (accountKeys.indexOf(key) === -1) {\n            // Only add key if it does not already exist in the map\n            accountKeys.push(key);\n            this.setItem(\n                StaticCacheKeys.ACCOUNT_KEYS,\n                JSON.stringify(accountKeys)\n            );\n            this.logger.verbose(\n                \"BrowserCacheManager.addAccountKeyToMap account key added\"\n            );\n        } else {\n            this.logger.verbose(\n                \"BrowserCacheManager.addAccountKeyToMap account key already exists in map\"\n            );\n        }\n    }\n\n    /**\n     * Remove an account from the key map\n     * @param key\n     */\n    removeAccountKeyFromMap(key: string): void {\n        this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\n        this.logger.tracePii(\n            `BrowserCacheManager.removeAccountKeyFromMap called with key: ${key}`\n        );\n        const accountKeys = this.getAccountKeys();\n        const removalIndex = accountKeys.indexOf(key);\n        if (removalIndex > -1) {\n            accountKeys.splice(removalIndex, 1);\n            this.setItem(\n                StaticCacheKeys.ACCOUNT_KEYS,\n                JSON.stringify(accountKeys)\n            );\n            this.logger.trace(\n                \"BrowserCacheManager.removeAccountKeyFromMap account key removed\"\n            );\n        } else {\n            this.logger.trace(\n                \"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\"\n            );\n        }\n    }\n\n    /**\n     * Extends inherited removeAccount function to include removal of the account key from the map\n     * @param key\n     */\n    async removeAccount(key: string): Promise<void> {\n        void super.removeAccount(key);\n        this.removeAccountKeyFromMap(key);\n    }\n\n    /**\n     * Removes given idToken from the cache and from the key map\n     * @param key\n     */\n    removeIdToken(key: string): void {\n        super.removeIdToken(key);\n        this.removeTokenKey(key, CredentialType.ID_TOKEN);\n    }\n\n    /**\n     * Removes given accessToken from the cache and from the key map\n     * @param key\n     */\n    async removeAccessToken(key: string): Promise<void> {\n        void super.removeAccessToken(key);\n        this.removeTokenKey(key, CredentialType.ACCESS_TOKEN);\n    }\n\n    /**\n     * Removes given refreshToken from the cache and from the key map\n     * @param key\n     */\n    removeRefreshToken(key: string): void {\n        super.removeRefreshToken(key);\n        this.removeTokenKey(key, CredentialType.REFRESH_TOKEN);\n    }\n\n    /**\n     * Gets the keys for the cached tokens associated with this clientId\n     * @returns\n     */\n    getTokenKeys(): TokenKeys {\n        this.logger.trace(\"BrowserCacheManager.getTokenKeys called\");\n        const item = this.getItem(\n            `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`\n        );\n        if (item) {\n            const tokenKeys = this.validateAndParseJson(item);\n            if (\n                tokenKeys &&\n                tokenKeys.hasOwnProperty(\"idToken\") &&\n                tokenKeys.hasOwnProperty(\"accessToken\") &&\n                tokenKeys.hasOwnProperty(\"refreshToken\")\n            ) {\n                return tokenKeys as TokenKeys;\n            } else {\n                this.logger.error(\n                    \"BrowserCacheManager.getTokenKeys - Token keys found but in an unknown format. Returning empty key map.\"\n                );\n            }\n        } else {\n            this.logger.verbose(\n                \"BrowserCacheManager.getTokenKeys - No token keys found\"\n            );\n        }\n\n        return {\n            idToken: [],\n            accessToken: [],\n            refreshToken: [],\n        };\n    }\n\n    /**\n     * Adds the given key to the token key map\n     * @param key\n     * @param type\n     */\n    addTokenKey(key: string, type: CredentialType): void {\n        this.logger.trace(\"BrowserCacheManager addTokenKey called\");\n        const tokenKeys = this.getTokenKeys();\n\n        switch (type) {\n            case CredentialType.ID_TOKEN:\n                if (tokenKeys.idToken.indexOf(key) === -1) {\n                    this.logger.info(\n                        \"BrowserCacheManager: addTokenKey - idToken added to map\"\n                    );\n                    tokenKeys.idToken.push(key);\n                }\n                break;\n            case CredentialType.ACCESS_TOKEN:\n                if (tokenKeys.accessToken.indexOf(key) === -1) {\n                    this.logger.info(\n                        \"BrowserCacheManager: addTokenKey - accessToken added to map\"\n                    );\n                    tokenKeys.accessToken.push(key);\n                }\n                break;\n            case CredentialType.REFRESH_TOKEN:\n                if (tokenKeys.refreshToken.indexOf(key) === -1) {\n                    this.logger.info(\n                        \"BrowserCacheManager: addTokenKey - refreshToken added to map\"\n                    );\n                    tokenKeys.refreshToken.push(key);\n                }\n                break;\n            default:\n                this.logger.error(\n                    `BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: ${type}`\n                );\n                ClientAuthError.createUnexpectedCredentialTypeError();\n        }\n\n        this.setItem(\n            `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`,\n            JSON.stringify(tokenKeys)\n        );\n    }\n\n    /**\n     * Removes the given key from the token key map\n     * @param key\n     * @param type\n     */\n    removeTokenKey(key: string, type: CredentialType): void {\n        this.logger.trace(\"BrowserCacheManager removeTokenKey called\");\n        const tokenKeys = this.getTokenKeys();\n\n        switch (type) {\n            case CredentialType.ID_TOKEN:\n                this.logger.infoPii(\n                    `BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: ${key} from map`\n                );\n                const idRemoval = tokenKeys.idToken.indexOf(key);\n                if (idRemoval > -1) {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - idToken removed from map\"\n                    );\n                    tokenKeys.idToken.splice(idRemoval, 1);\n                } else {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.\"\n                    );\n                }\n                break;\n            case CredentialType.ACCESS_TOKEN:\n                this.logger.infoPii(\n                    `BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: ${key} from map`\n                );\n                const accessRemoval = tokenKeys.accessToken.indexOf(key);\n                if (accessRemoval > -1) {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - accessToken removed from map\"\n                    );\n                    tokenKeys.accessToken.splice(accessRemoval, 1);\n                } else {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.\"\n                    );\n                }\n                break;\n            case CredentialType.REFRESH_TOKEN:\n                this.logger.infoPii(\n                    `BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: ${key} from map`\n                );\n                const refreshRemoval = tokenKeys.refreshToken.indexOf(key);\n                if (refreshRemoval > -1) {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - refreshToken removed from map\"\n                    );\n                    tokenKeys.refreshToken.splice(refreshRemoval, 1);\n                } else {\n                    this.logger.info(\n                        \"BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.\"\n                    );\n                }\n                break;\n            default:\n                this.logger.error(\n                    `BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: ${type}`\n                );\n                ClientAuthError.createUnexpectedCredentialTypeError();\n        }\n\n        this.setItem(\n            `${StaticCacheKeys.TOKEN_KEYS}.${this.clientId}`,\n            JSON.stringify(tokenKeys)\n        );\n    }\n\n    /**\n     * generates idToken entity from a string\n     * @param idTokenKey\n     */\n    getIdTokenCredential(idTokenKey: string): IdTokenEntity | null {\n        const value = this.getItem(idTokenKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getIdTokenCredential: called, no cache hit\"\n            );\n            this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n            return null;\n        }\n\n        const parsedIdToken = this.validateAndParseJson(value);\n        if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\n            this.logger.trace(\n                \"BrowserCacheManager.getIdTokenCredential: called, no cache hit\"\n            );\n            this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n            return null;\n        }\n\n        this.logger.trace(\n            \"BrowserCacheManager.getIdTokenCredential: cache hit\"\n        );\n        return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\n    }\n\n    /**\n     * set IdToken credential to the platform cache\n     * @param idToken\n     */\n    setIdTokenCredential(idToken: IdTokenEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n        const idTokenKey = idToken.generateCredentialKey();\n\n        this.setItem(idTokenKey, JSON.stringify(idToken));\n\n        this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n    }\n\n    /**\n     * generates accessToken entity from a string\n     * @param key\n     */\n    getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null {\n        const value = this.getItem(accessTokenKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\"\n            );\n            this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n            return null;\n        }\n        const parsedAccessToken = this.validateAndParseJson(value);\n        if (\n            !parsedAccessToken ||\n            !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\"\n            );\n            this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n            return null;\n        }\n\n        this.logger.trace(\n            \"BrowserCacheManager.getAccessTokenCredential: cache hit\"\n        );\n        return CacheManager.toObject(\n            new AccessTokenEntity(),\n            parsedAccessToken\n        );\n    }\n\n    /**\n     * set accessToken credential to the platform cache\n     * @param accessToken\n     */\n    setAccessTokenCredential(accessToken: AccessTokenEntity): void {\n        this.logger.trace(\n            \"BrowserCacheManager.setAccessTokenCredential called\"\n        );\n        const accessTokenKey = accessToken.generateCredentialKey();\n        this.setItem(accessTokenKey, JSON.stringify(accessToken));\n\n        this.addTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n    }\n\n    /**\n     * generates refreshToken entity from a string\n     * @param refreshTokenKey\n     */\n    getRefreshTokenCredential(\n        refreshTokenKey: string\n    ): RefreshTokenEntity | null {\n        const value = this.getItem(refreshTokenKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\"\n            );\n            this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n            return null;\n        }\n        const parsedRefreshToken = this.validateAndParseJson(value);\n        if (\n            !parsedRefreshToken ||\n            !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\"\n            );\n            this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n            return null;\n        }\n\n        this.logger.trace(\n            \"BrowserCacheManager.getRefreshTokenCredential: cache hit\"\n        );\n        return CacheManager.toObject(\n            new RefreshTokenEntity(),\n            parsedRefreshToken\n        );\n    }\n\n    /**\n     * set refreshToken credential to the platform cache\n     * @param refreshToken\n     */\n    setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void {\n        this.logger.trace(\n            \"BrowserCacheManager.setRefreshTokenCredential called\"\n        );\n        const refreshTokenKey = refreshToken.generateCredentialKey();\n        this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\n\n        this.addTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n    }\n\n    /**\n     * fetch appMetadata entity from the platform cache\n     * @param appMetadataKey\n     */\n    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null {\n        const value = this.getItem(appMetadataKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAppMetadata: called, no cache hit\"\n            );\n            return null;\n        }\n\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (\n            !parsedMetadata ||\n            !AppMetadataEntity.isAppMetadataEntity(\n                appMetadataKey,\n                parsedMetadata\n            )\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAppMetadata: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n        return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\n    }\n\n    /**\n     * set appMetadata entity to the platform cache\n     * @param appMetadata\n     */\n    setAppMetadata(appMetadata: AppMetadataEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n        const appMetadataKey = appMetadata.generateAppMetadataKey();\n        this.setItem(appMetadataKey, JSON.stringify(appMetadata));\n    }\n\n    /**\n     * fetch server telemetry entity from the platform cache\n     * @param serverTelemetryKey\n     */\n    getServerTelemetry(\n        serverTelemetryKey: string\n    ): ServerTelemetryEntity | null {\n        const value = this.getItem(serverTelemetryKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getServerTelemetry: called, no cache hit\"\n            );\n            return null;\n        }\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (\n            !parsedMetadata ||\n            !ServerTelemetryEntity.isServerTelemetryEntity(\n                serverTelemetryKey,\n                parsedMetadata\n            )\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getServerTelemetry: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n        return CacheManager.toObject(\n            new ServerTelemetryEntity(),\n            parsedMetadata\n        );\n    }\n\n    /**\n     * set server telemetry entity to the platform cache\n     * @param serverTelemetryKey\n     * @param serverTelemetry\n     */\n    setServerTelemetry(\n        serverTelemetryKey: string,\n        serverTelemetry: ServerTelemetryEntity\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n        this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\n    }\n\n    /**\n     *\n     */\n    getAuthorityMetadata(key: string): AuthorityMetadataEntity | null {\n        const value = this.internalStorage.getItem(key);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\"\n            );\n            return null;\n        }\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (\n            parsedMetadata &&\n            AuthorityMetadataEntity.isAuthorityMetadataEntity(\n                key,\n                parsedMetadata\n            )\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getAuthorityMetadata: cache hit\"\n            );\n            return CacheManager.toObject(\n                new AuthorityMetadataEntity(),\n                parsedMetadata\n            );\n        }\n        return null;\n    }\n\n    /**\n     *\n     */\n    getAuthorityMetadataKeys(): Array<string> {\n        const allKeys = this.internalStorage.getKeys();\n        return allKeys.filter((key) => {\n            return this.isAuthorityMetadata(key);\n        });\n    }\n\n    /**\n     * Sets wrapper metadata in memory\n     * @param wrapperSKU\n     * @param wrapperVersion\n     */\n    setWrapperMetadata(wrapperSKU: string, wrapperVersion: string): void {\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n        this.internalStorage.setItem(\n            InMemoryCacheKeys.WRAPPER_VER,\n            wrapperVersion\n        );\n    }\n\n    /**\n     * Returns wrapper metadata from in-memory storage\n     */\n    getWrapperMetadata(): [string, string] {\n        const sku =\n            this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) ||\n            Constants.EMPTY_STRING;\n        const version =\n            this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) ||\n            Constants.EMPTY_STRING;\n        return [sku, version];\n    }\n\n    /**\n     *\n     * @param entity\n     */\n    setAuthorityMetadata(key: string, entity: AuthorityMetadataEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n        this.internalStorage.setItem(key, JSON.stringify(entity));\n    }\n\n    /**\n     * Gets the active account\n     */\n    getActiveAccount(): AccountInfo | null {\n        const activeAccountKeyFilters = this.generateCacheKey(\n            PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS\n        );\n        const activeAccountValueFilters = this.getItem(activeAccountKeyFilters);\n        if (!activeAccountValueFilters) {\n            // if new active account cache type isn't found, it's an old version, so look for that instead\n            this.logger.trace(\n                \"BrowserCacheManager.getActiveAccount: No active account filters cache schema found, looking for legacy schema\"\n            );\n            const activeAccountKeyLocal = this.generateCacheKey(\n                PersistentCacheKeys.ACTIVE_ACCOUNT\n            );\n            const activeAccountValueLocal = this.getItem(activeAccountKeyLocal);\n            if (!activeAccountValueLocal) {\n                this.logger.trace(\n                    \"BrowserCacheManager.getActiveAccount: No active account found\"\n                );\n                return null;\n            }\n            const activeAccount =\n                this.getAccountInfoByFilter({\n                    localAccountId: activeAccountValueLocal,\n                })[0] || null;\n            if (activeAccount) {\n                this.logger.trace(\n                    \"BrowserCacheManager.getActiveAccount: Legacy active account cache schema found\"\n                );\n                this.logger.trace(\n                    \"BrowserCacheManager.getActiveAccount: Adding active account filters cache schema\"\n                );\n                this.setActiveAccount(activeAccount);\n                return activeAccount;\n            }\n            return null;\n        }\n        const activeAccountValueObj = this.validateAndParseJson(\n            activeAccountValueFilters\n        ) as AccountInfo;\n        if (activeAccountValueObj) {\n            this.logger.trace(\n                \"BrowserCacheManager.getActiveAccount: Active account filters schema found\"\n            );\n            return (\n                this.getAccountInfoByFilter({\n                    homeAccountId: activeAccountValueObj.homeAccountId,\n                    localAccountId: activeAccountValueObj.localAccountId,\n                })[0] || null\n            );\n        }\n        this.logger.trace(\n            \"BrowserCacheManager.getActiveAccount: No active account found\"\n        );\n        return null;\n    }\n\n    /**\n     * Sets the active account's localAccountId in cache\n     * @param account\n     */\n    setActiveAccount(account: AccountInfo | null): void {\n        const activeAccountKey = this.generateCacheKey(\n            PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS\n        );\n        const activeAccountKeyLocal = this.generateCacheKey(\n            PersistentCacheKeys.ACTIVE_ACCOUNT\n        );\n        if (account) {\n            this.logger.verbose(\"setActiveAccount: Active account set\");\n            const activeAccountValue: ActiveAccountFilters = {\n                homeAccountId: account.homeAccountId,\n                localAccountId: account.localAccountId,\n            };\n            this.browserStorage.setItem(\n                activeAccountKey,\n                JSON.stringify(activeAccountValue)\n            );\n            this.browserStorage.setItem(\n                activeAccountKeyLocal,\n                account.localAccountId\n            );\n        } else {\n            this.logger.verbose(\n                \"setActiveAccount: No account passed, active account not set\"\n            );\n            this.browserStorage.removeItem(activeAccountKey);\n            this.browserStorage.removeItem(activeAccountKeyLocal);\n        }\n    }\n\n    /**\n     * Gets a list of accounts that match all of the filters provided\n     * @param account\n     */\n    getAccountInfoByFilter(\n        accountFilter: Partial<Omit<AccountInfo, \"idTokenClaims\" | \"name\">>\n    ): AccountInfo[] {\n        const allAccounts = this.getAllAccounts();\n        this.logger.trace(\n            `BrowserCacheManager.getAccountInfoByFilter: total ${allAccounts.length} accounts found`\n        );\n\n        return allAccounts.filter((accountObj) => {\n            if (\n                accountFilter.username &&\n                accountFilter.username.toLowerCase() !==\n                    accountObj.username.toLowerCase()\n            ) {\n                return false;\n            }\n\n            if (\n                accountFilter.homeAccountId &&\n                accountFilter.homeAccountId !== accountObj.homeAccountId\n            ) {\n                return false;\n            }\n\n            if (\n                accountFilter.localAccountId &&\n                accountFilter.localAccountId !== accountObj.localAccountId\n            ) {\n                return false;\n            }\n\n            if (\n                accountFilter.tenantId &&\n                accountFilter.tenantId !== accountObj.tenantId\n            ) {\n                return false;\n            }\n\n            if (\n                accountFilter.environment &&\n                accountFilter.environment !== accountObj.environment\n            ) {\n                return false;\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Checks the cache for accounts matching loginHint or SID\n     * @param loginHint\n     * @param sid\n     */\n    getAccountInfoByHints(\n        loginHint?: string,\n        sid?: string\n    ): AccountInfo | null {\n        const matchingAccounts = this.getAllAccounts().filter((accountInfo) => {\n            if (sid) {\n                const accountSid =\n                    accountInfo.idTokenClaims &&\n                    accountInfo.idTokenClaims[\"sid\"];\n                return sid === accountSid;\n            }\n\n            if (loginHint) {\n                return loginHint === accountInfo.username;\n            }\n\n            return false;\n        });\n\n        if (matchingAccounts.length === 1) {\n            return matchingAccounts[0];\n        } else if (matchingAccounts.length > 1) {\n            throw ClientAuthError.createMultipleMatchingAccountsInCacheError();\n        }\n\n        return null;\n    }\n\n    /**\n     * fetch throttling entity from the platform cache\n     * @param throttlingCacheKey\n     */\n    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null {\n        const value = this.getItem(throttlingCacheKey);\n        if (!value) {\n            this.logger.trace(\n                \"BrowserCacheManager.getThrottlingCache: called, no cache hit\"\n            );\n            return null;\n        }\n\n        const parsedThrottlingCache = this.validateAndParseJson(value);\n        if (\n            !parsedThrottlingCache ||\n            !ThrottlingEntity.isThrottlingEntity(\n                throttlingCacheKey,\n                parsedThrottlingCache\n            )\n        ) {\n            this.logger.trace(\n                \"BrowserCacheManager.getThrottlingCache: called, no cache hit\"\n            );\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n        return CacheManager.toObject(\n            new ThrottlingEntity(),\n            parsedThrottlingCache\n        );\n    }\n\n    /**\n     * set throttling entity to the platform cache\n     * @param throttlingCacheKey\n     * @param throttlingCache\n     */\n    setThrottlingCache(\n        throttlingCacheKey: string,\n        throttlingCache: ThrottlingEntity\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n        this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\n    }\n\n    /**\n     * Gets cache item with given key.\n     * Will retrieve from cookies if storeAuthStateInCookie is set to true.\n     * @param key\n     */\n    getTemporaryCache(cacheKey: string, generateKey?: boolean): string | null {\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            const itemCookie = this.getItemCookie(key);\n            if (itemCookie) {\n                this.logger.trace(\n                    \"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\"\n                );\n                return itemCookie;\n            }\n        }\n\n        const value = this.temporaryCacheStorage.getItem(key);\n        if (!value) {\n            // If temp cache item not found in session/memory, check local storage for items set by old versions\n            if (\n                this.cacheConfig.cacheLocation ===\n                BrowserCacheLocation.LocalStorage\n            ) {\n                const item = this.browserStorage.getItem(key);\n                if (item) {\n                    this.logger.trace(\n                        \"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\"\n                    );\n                    return item;\n                }\n            }\n            this.logger.trace(\n                \"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\"\n            );\n            return null;\n        }\n        this.logger.trace(\n            \"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\"\n        );\n        return value;\n    }\n\n    /**\n     * Sets the cache item with the key and value given.\n     * Stores in cookie if storeAuthStateInCookie is set to true.\n     * This can cause cookie overflow if used incorrectly.\n     * @param key\n     * @param value\n     */\n    setTemporaryCache(\n        cacheKey: string,\n        value: string,\n        generateKey?: boolean\n    ): void {\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n\n        this.temporaryCacheStorage.setItem(key, value);\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            this.logger.trace(\n                \"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\"\n            );\n            this.setItemCookie(key, value);\n        }\n    }\n\n    /**\n     * Removes the cache item with the given key.\n     * Will also clear the cookie item if storeAuthStateInCookie is set to true.\n     * @param key\n     */\n    removeItem(key: string): void {\n        this.browserStorage.removeItem(key);\n        this.temporaryCacheStorage.removeItem(key);\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            this.logger.trace(\n                \"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\"\n            );\n            this.clearItemCookie(key);\n        }\n    }\n\n    /**\n     * Checks whether key is in cache.\n     * @param key\n     */\n    containsKey(key: string): boolean {\n        return (\n            this.browserStorage.containsKey(key) ||\n            this.temporaryCacheStorage.containsKey(key)\n        );\n    }\n\n    /**\n     * Gets all keys in window.\n     */\n    getKeys(): string[] {\n        return [\n            ...this.browserStorage.getKeys(),\n            ...this.temporaryCacheStorage.getKeys(),\n        ];\n    }\n\n    /**\n     * Clears all cache entries created by MSAL.\n     */\n    async clear(): Promise<void> {\n        // Removes all accounts and their credentials\n        await this.removeAllAccounts();\n        this.removeAppMetadata();\n\n        // Removes all remaining MSAL cache items\n        this.getKeys().forEach((cacheKey: string) => {\n            // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\n            if (\n                (this.browserStorage.containsKey(cacheKey) ||\n                    this.temporaryCacheStorage.containsKey(cacheKey)) &&\n                (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 ||\n                    cacheKey.indexOf(this.clientId) !== -1)\n            ) {\n                this.removeItem(cacheKey);\n            }\n        });\n\n        this.internalStorage.clear();\n    }\n\n    /**\n     * Clears all access tokes that have claims prior to saving the current one\n     * @param credential\n     * @returns\n     */\n    async clearTokensAndKeysWithClaims(): Promise<void> {\n        const tokenKeys = this.getTokenKeys();\n\n        const removedAccessTokens: Array<Promise<void>> = [];\n        tokenKeys.accessToken.forEach((key: string) => {\n            // if the access token has claims in its key, remove the token key and the token\n            const credential = this.getAccessTokenCredential(key);\n            if (\n                credential?.requestedClaimsHash &&\n                key.includes(credential.requestedClaimsHash.toLowerCase())\n            ) {\n                removedAccessTokens.push(this.removeAccessToken(key));\n            }\n        });\n        await Promise.all(removedAccessTokens);\n\n        // warn if any access tokens are removed\n        if (removedAccessTokens.length > 0) {\n            this.logger.warning(\n                `${removedAccessTokens.length} access tokens with claims in the cache keys have been removed from the cache.`\n            );\n        }\n    }\n\n    /**\n     * Add value to cookies\n     * @param cookieName\n     * @param cookieValue\n     * @param expires\n     */\n    setItemCookie(\n        cookieName: string,\n        cookieValue: string,\n        expires?: number\n    ): void {\n        let cookieStr = `${encodeURIComponent(cookieName)}=${encodeURIComponent(\n            cookieValue\n        )};path=/;SameSite=Lax;`;\n        if (expires) {\n            const expireTime = this.getCookieExpirationTime(expires);\n            cookieStr += `expires=${expireTime};`;\n        }\n\n        if (this.cacheConfig.secureCookies) {\n            cookieStr += \"Secure;\";\n        }\n\n        document.cookie = cookieStr;\n    }\n\n    /**\n     * Get one item by key from cookies\n     * @param cookieName\n     */\n    getItemCookie(cookieName: string): string {\n        const name = `${encodeURIComponent(cookieName)}=`;\n        const cookieList = document.cookie.split(\";\");\n        for (let i: number = 0; i < cookieList.length; i++) {\n            let cookie = cookieList[i];\n            while (cookie.charAt(0) === \" \") {\n                cookie = cookie.substring(1);\n            }\n            if (cookie.indexOf(name) === 0) {\n                return decodeURIComponent(\n                    cookie.substring(name.length, cookie.length)\n                );\n            }\n        }\n        return Constants.EMPTY_STRING;\n    }\n\n    /**\n     * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\n     */\n    clearMsalCookies(): void {\n        const cookiePrefix = `${Constants.CACHE_PREFIX}.${this.clientId}`;\n        const cookieList = document.cookie.split(\";\");\n        cookieList.forEach((cookie: string): void => {\n            while (cookie.charAt(0) === \" \") {\n                // eslint-disable-next-line no-param-reassign\n                cookie = cookie.substring(1);\n            }\n            if (cookie.indexOf(cookiePrefix) === 0) {\n                const cookieKey = cookie.split(\"=\")[0];\n                this.clearItemCookie(cookieKey);\n            }\n        });\n    }\n\n    /**\n     * Clear an item in the cookies by key\n     * @param cookieName\n     */\n    clearItemCookie(cookieName: string): void {\n        this.setItemCookie(cookieName, Constants.EMPTY_STRING, -1);\n    }\n\n    /**\n     * Get cookie expiration time\n     * @param cookieLifeDays\n     */\n    getCookieExpirationTime(cookieLifeDays: number): string {\n        const today = new Date();\n        const expr = new Date(\n            today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER\n        );\n        return expr.toUTCString();\n    }\n\n    /**\n     * Gets the cache object referenced by the browser\n     */\n    getCache(): object {\n        return this.browserStorage;\n    }\n\n    /**\n     * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\n     */\n    setCache(): void {\n        // sets nothing\n    }\n\n    /**\n     * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\n     * @param key\n     * @param addInstanceId\n     */\n    generateCacheKey(key: string): string {\n        const generatedKey = this.validateAndParseJson(key);\n        if (!generatedKey) {\n            if (\n                StringUtils.startsWith(key, Constants.CACHE_PREFIX) ||\n                StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)\n            ) {\n                return key;\n            }\n            return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;\n        }\n\n        return JSON.stringify(key);\n    }\n\n    /**\n     * Create authorityKey to cache authority\n     * @param state\n     */\n    generateAuthorityKey(stateString: string): string {\n        const {\n            libraryState: { id: stateId },\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n\n        return this.generateCacheKey(\n            `${TemporaryCacheKeys.AUTHORITY}.${stateId}`\n        );\n    }\n\n    /**\n     * Create Nonce key to cache nonce\n     * @param state\n     */\n    generateNonceKey(stateString: string): string {\n        const {\n            libraryState: { id: stateId },\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n\n        return this.generateCacheKey(\n            `${TemporaryCacheKeys.NONCE_IDTOKEN}.${stateId}`\n        );\n    }\n\n    /**\n     * Creates full cache key for the request state\n     * @param stateString State string for the request\n     */\n    generateStateKey(stateString: string): string {\n        // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\n        const {\n            libraryState: { id: stateId },\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n        return this.generateCacheKey(\n            `${TemporaryCacheKeys.REQUEST_STATE}.${stateId}`\n        );\n    }\n\n    /**\n     * Gets the cached authority based on the cached state. Returns empty if no cached state found.\n     */\n    getCachedAuthority(cachedState: string): string | null {\n        const stateCacheKey = this.generateStateKey(cachedState);\n        const state = this.getTemporaryCache(stateCacheKey);\n        if (!state) {\n            return null;\n        }\n\n        const authorityCacheKey = this.generateAuthorityKey(state);\n        return this.getTemporaryCache(authorityCacheKey);\n    }\n\n    /**\n     * Updates account, authority, and state in cache\n     * @param serverAuthenticationRequest\n     * @param account\n     */\n    updateCacheEntries(\n        state: string,\n        nonce: string,\n        authorityInstance: string,\n        loginHint: string,\n        account: AccountInfo | null\n    ): void {\n        this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\");\n        // Cache the request state\n        const stateCacheKey = this.generateStateKey(state);\n        this.setTemporaryCache(stateCacheKey, state, false);\n\n        // Cache the nonce\n        const nonceCacheKey = this.generateNonceKey(state);\n        this.setTemporaryCache(nonceCacheKey, nonce, false);\n\n        // Cache authorityKey\n        const authorityCacheKey = this.generateAuthorityKey(state);\n        this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\n\n        if (account) {\n            const ccsCredential: CcsCredential = {\n                credential: account.homeAccountId,\n                type: CcsCredentialType.HOME_ACCOUNT_ID,\n            };\n            this.setTemporaryCache(\n                TemporaryCacheKeys.CCS_CREDENTIAL,\n                JSON.stringify(ccsCredential),\n                true\n            );\n        } else if (loginHint) {\n            const ccsCredential: CcsCredential = {\n                credential: loginHint,\n                type: CcsCredentialType.UPN,\n            };\n            this.setTemporaryCache(\n                TemporaryCacheKeys.CCS_CREDENTIAL,\n                JSON.stringify(ccsCredential),\n                true\n            );\n        }\n    }\n\n    /**\n     * Reset all temporary cache items\n     * @param state\n     */\n    resetRequestCache(state: string): void {\n        this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\n        // check state and remove associated cache items\n        if (state) {\n            this.getKeys().forEach((key) => {\n                if (key.indexOf(state) !== -1) {\n                    this.removeItem(key);\n                }\n            });\n\n            // delete generic interactive request parameters\n            this.removeItem(this.generateStateKey(state));\n            this.removeItem(this.generateNonceKey(state));\n            this.removeItem(this.generateAuthorityKey(state));\n        }\n        this.removeItem(\n            this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS)\n        );\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n        this.removeItem(\n            this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID)\n        );\n        this.removeItem(\n            this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL)\n        );\n        this.removeItem(\n            this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST)\n        );\n        this.setInteractionInProgress(false);\n    }\n\n    /**\n     * Removes temporary cache for the provided state\n     * @param stateString\n     */\n    cleanRequestByState(stateString: string): void {\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\");\n        // Interaction is completed - remove interaction status.\n        if (stateString) {\n            const stateKey = this.generateStateKey(stateString);\n            const cachedState = this.temporaryCacheStorage.getItem(stateKey);\n            this.logger.infoPii(\n                `BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: ${cachedState}`\n            );\n            this.resetRequestCache(cachedState || Constants.EMPTY_STRING);\n        }\n        this.clearMsalCookies();\n    }\n\n    /**\n     * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\n     * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\n     * @param interactionType\n     */\n    cleanRequestByInteractionType(interactionType: InteractionType): void {\n        this.logger.trace(\n            \"BrowserCacheManager.cleanRequestByInteractionType called\"\n        );\n        // Loop through all keys to find state key\n        this.getKeys().forEach((key) => {\n            // If this key is not the state key, move on\n            if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\n                return;\n            }\n\n            // Retrieve state value, return if not a valid value\n            const stateValue = this.temporaryCacheStorage.getItem(key);\n            if (!stateValue) {\n                return;\n            }\n            // Extract state and ensure it matches given InteractionType, then clean request cache\n            const parsedState = BrowserProtocolUtils.extractBrowserRequestState(\n                this.cryptoImpl,\n                stateValue\n            );\n            if (\n                parsedState &&\n                parsedState.interactionType === interactionType\n            ) {\n                this.logger.infoPii(\n                    `BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: ${stateValue}`\n                );\n                this.resetRequestCache(stateValue);\n            }\n        });\n        this.clearMsalCookies();\n        this.setInteractionInProgress(false);\n    }\n\n    cacheCodeRequest(authCodeRequest: CommonAuthorizationCodeRequest): void {\n        this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\n\n        const encodedValue = base64Encode(JSON.stringify(authCodeRequest));\n        this.setTemporaryCache(\n            TemporaryCacheKeys.REQUEST_PARAMS,\n            encodedValue,\n            true\n        );\n    }\n\n    /**\n     * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\n     */\n    getCachedRequest(state: string): CommonAuthorizationCodeRequest {\n        this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\n        // Get token request from cache and parse as TokenExchangeParameters.\n        const encodedTokenRequest = this.getTemporaryCache(\n            TemporaryCacheKeys.REQUEST_PARAMS,\n            true\n        );\n        if (!encodedTokenRequest) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.noTokenRequestCacheError\n            );\n        }\n\n        let parsedRequest: CommonAuthorizationCodeRequest;\n        try {\n            parsedRequest = JSON.parse(base64Decode(encodedTokenRequest));\n        } catch (e) {\n            this.logger.errorPii(`Attempted to parse: ${encodedTokenRequest}`);\n            this.logger.error(\n                `Parsing cached token request threw with error: ${e}`\n            );\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.unableToParseTokenRequestCacheError\n            );\n        }\n        this.removeItem(\n            this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS)\n        );\n\n        // Get cached authority and use if no authority is cached with request.\n        if (!parsedRequest.authority) {\n            const authorityCacheKey: string = this.generateAuthorityKey(state);\n            const cachedAuthority = this.getTemporaryCache(authorityCacheKey);\n            if (!cachedAuthority) {\n                throw createBrowserAuthError(\n                    BrowserAuthErrorCodes.noCachedAuthorityError\n                );\n            }\n            parsedRequest.authority = cachedAuthority;\n        }\n\n        return parsedRequest;\n    }\n\n    /**\n     * Gets cached native request for redirect flows\n     */\n    getCachedNativeRequest(): NativeTokenRequest | null {\n        this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n        const cachedRequest = this.getTemporaryCache(\n            TemporaryCacheKeys.NATIVE_REQUEST,\n            true\n        );\n        if (!cachedRequest) {\n            this.logger.trace(\n                \"BrowserCacheManager.getCachedNativeRequest: No cached native request found\"\n            );\n            return null;\n        }\n\n        const parsedRequest = this.validateAndParseJson(\n            cachedRequest\n        ) as NativeTokenRequest;\n        if (!parsedRequest) {\n            this.logger.error(\n                \"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\"\n            );\n            return null;\n        }\n\n        return parsedRequest;\n    }\n\n    isInteractionInProgress(matchClientId?: boolean): boolean {\n        const clientId = this.getInteractionInProgress();\n\n        if (matchClientId) {\n            return clientId === this.clientId;\n        } else {\n            return !!clientId;\n        }\n    }\n\n    getInteractionInProgress(): string | null {\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n        return this.getTemporaryCache(key, false);\n    }\n\n    setInteractionInProgress(inProgress: boolean): void {\n        // Ensure we don't overwrite interaction in progress for a different clientId\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n        if (inProgress) {\n            if (this.getInteractionInProgress()) {\n                throw createBrowserAuthError(\n                    BrowserAuthErrorCodes.interactionInProgress\n                );\n            } else {\n                // No interaction is in progress\n                this.setTemporaryCache(key, this.clientId, false);\n            }\n        } else if (\n            !inProgress &&\n            this.getInteractionInProgress() === this.clientId\n        ) {\n            this.removeItem(key);\n        }\n    }\n\n    /**\n     * Returns username retrieved from ADAL or MSAL v1 idToken\n     * @deprecated\n     */\n    getLegacyLoginHint(): string | null {\n        // Only check for adal/msal token if no SSO params are being used\n        const adalIdTokenString = this.getTemporaryCache(\n            PersistentCacheKeys.ADAL_ID_TOKEN\n        );\n        if (adalIdTokenString) {\n            this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\n            this.logger.verbose(\"Cached ADAL id token retrieved.\");\n        }\n\n        // Check for cached MSAL v1 id token\n        const msalIdTokenString = this.getTemporaryCache(\n            PersistentCacheKeys.ID_TOKEN,\n            true\n        );\n        if (msalIdTokenString) {\n            this.removeItem(\n                this.generateCacheKey(PersistentCacheKeys.ID_TOKEN)\n            );\n            this.logger.verbose(\"Cached MSAL.js v1 id token retrieved\");\n        }\n\n        const cachedIdTokenString = msalIdTokenString || adalIdTokenString;\n        if (cachedIdTokenString) {\n            const idTokenClaims = AuthToken.extractTokenClaims(\n                cachedIdTokenString,\n                base64Decode\n            );\n            if (idTokenClaims.preferred_username) {\n                this.logger.verbose(\n                    \"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint\"\n                );\n                return idTokenClaims.preferred_username;\n            } else if (idTokenClaims.upn) {\n                this.logger.verbose(\n                    \"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint\"\n                );\n                return idTokenClaims.upn;\n            } else {\n                this.logger.verbose(\n                    \"No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.\"\n                );\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Updates a credential's cache key if the current cache key is outdated\n     */\n    updateCredentialCacheKey(\n        currentCacheKey: string,\n        credential: ValidCredentialType\n    ): string {\n        const updatedCacheKey = credential.generateCredentialKey();\n\n        if (currentCacheKey !== updatedCacheKey) {\n            const cacheItem = this.getItem(currentCacheKey);\n            if (cacheItem) {\n                this.removeItem(currentCacheKey);\n                this.setItem(updatedCacheKey, cacheItem);\n                this.logger.verbose(\n                    `Updated an outdated ${credential.credentialType} cache key`\n                );\n                return updatedCacheKey;\n            } else {\n                this.logger.error(\n                    `Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`\n                );\n            }\n        }\n\n        return currentCacheKey;\n    }\n\n    /**\n     * Returns application id as redirect context during AcquireTokenRedirect flow.\n     */\n    getRedirectRequestContext(): string | null {\n        return this.getTemporaryCache(\n            TemporaryCacheKeys.REDIRECT_CONTEXT,\n            true\n        );\n    }\n\n    /**\n     * Sets application id as the redirect context during AcquireTokenRedirect flow.\n     * @param value\n     */\n    setRedirectRequestContext(value: string): void {\n        this.setTemporaryCache(\n            TemporaryCacheKeys.REDIRECT_CONTEXT,\n            value,\n            true\n        );\n    }\n\n    /**\n     * Builds credential entities from AuthenticationResult object and saves the resulting credentials to the cache\n     * @param result\n     * @param request\n     */\n    async hydrateCache(\n        result: AuthenticationResult,\n        request:\n            | SilentRequest\n            | SsoSilentRequest\n            | RedirectRequest\n            | PopupRequest\n    ): Promise<void> {\n        const idTokenEntity = IdTokenEntity.createIdTokenEntity(\n            result.account?.homeAccountId,\n            result.account?.environment,\n            result.idToken,\n            this.clientId,\n            result.tenantId\n        );\n\n        let claimsHash;\n        if (request.claims) {\n            claimsHash = await this.cryptoImpl.hashString(request.claims);\n        }\n        const accessTokenEntity = AccessTokenEntity.createAccessTokenEntity(\n            result.account?.homeAccountId,\n            result.account.environment,\n            result.accessToken,\n            this.clientId,\n            result.tenantId,\n            result.scopes.join(\" \"),\n            result.expiresOn?.getTime() || 0,\n            result.extExpiresOn?.getTime() || 0,\n            this.cryptoImpl,\n            undefined, // refreshOn\n            result.tokenType as AuthenticationScheme,\n            undefined, // userAssertionHash\n            request.sshKid,\n            request.claims,\n            claimsHash\n        );\n\n        const cacheRecord = new CacheRecord(\n            undefined,\n            idTokenEntity,\n            accessTokenEntity\n        );\n        return this.saveCacheRecord(cacheRecord);\n    }\n}\n\nexport const DEFAULT_BROWSER_CACHE_MANAGER = (\n    clientId: string,\n    logger: Logger\n): BrowserCacheManager => {\n    const cacheOptions: Required<CacheOptions> = {\n        cacheLocation: BrowserCacheLocation.MemoryStorage,\n        temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\n        storeAuthStateInCookie: false,\n        secureCookies: false,\n        cacheMigrationEnabled: false,\n        claimsBasedCachingEnabled: false,\n    };\n    return new BrowserCacheManager(\n        clientId,\n        cacheOptions,\n        DEFAULT_CRYPTO_IMPLEMENTATION,\n        logger\n    );\n};\n"],"mappings":";;;;;;;;;;;;;AAKA;AA8BA;AAKA;AAQA;;;;AAgBG;AACH;AAEI,MAASA,mBAAA,SAAuBC,YAAc;EAE9CC,WAAwBA,CAAAC,QAAA,EAAAC,WAAA,EAAAC,UAAiB,EAAMC,MAAE;IAEjD,KAAS,CAACH,QAAe,EAAAE,UAAA,EAAAC,MAAA;IAEzB;IAEA,KAASC,sBAAgB;IAGzB,KAASH,WAAU,GAAAA,WAAA;IAGf,KAAAE,MAAA,GAAAA,MAAgB;IAwBpB,KAAAE,eAAA,OAAAC,aAAA;;;IAGG;IACH,IAAAL,WAAU,CAAAM,qBACN,EAAa;MAmBjB,KAAAC,mBAAA;;;;EAIG;AACH;AAuBA;;;IAGG,QAAAC,aAAA;MACM,KAAoBC,oBAAI,CAAIC,YAAA;MA6BrC,KAAAD,oBAAA,CAAAE,cAAA;;;;UAKG,KAAAT,MAAA,CAAAU,OAAA,CAAAC,CAAA;UACO;QAMV;IAIG;IACH,IAAQ,CAAab,WAAA,CAAAQ,aAAA,GAAAC,oBAAA,CAAAJ,aAAA;IA2JrB,WAAAA,aAAA;;;AAGG;;AAkBH;;;IAGG,QAAAG,aAAA;MACK,KAAKC,oBAAsB,CAAAC,YAAA;MAInC,KAAAD,oBAAA,CAAAE,cAAA;;;8DAIGF,oBAAA,CAAAE,cAAA;SACU,CAIb,OAAAE,CAAA;;;QAGG;MACH,KAAqBJ,oBAAW,CAAAJ,aAAA;MAoBhC;;;EAGG;EACH;AAOA;;;EAGGE,oBAAA;IACH,MAAAO,UAAkB,GAAM,GAAAC,SAAO,CAAAC,YAAA,IAAAC,mBAAA,CAAAC,QAAA;IAa/B,MAAAC,aAAA,MAAAJ,SAAA,CAAAC,YAAA,IAAAC,mBAAA,CAAAG,WAAA;;;IAGG,MAAAC,YAAA,QAAAC,cAAA,CAAAC,OAAA,CAAAT,UAAA;IACH,MAAAU,eAAwB,QAASF,cAAI,CAAAC,OAAA,CAAAJ,aAAA;IAuBrC,MAAAM,UAAA,QAAAH,cAAA,CAAAC,OAAA,CAAAG,QAAA;;oBAGGL,YAAA,EACHG,eAAuB,EAuBvBC,UAAA,E;IAGG,MAAAE,aAAA,IACgBV,mBAAA,CAAeC,QAAQ,EAK1CD,mBAAA,CAAAG,WAAA,E,0DAGG;IACHO,aAAiB,CAAEC,OAAM,EAAAC,QAAO,EAAAC,KAAA,UAAAC,iBAAA,CAAAF,QAAA,EAAAG,MAAA,CAAAF,KAAA;EAKhC;;;AAGG;;AAMH;;;IAGG,IAAAG,KAAA;MACH,KAAAC,iBAA8B,CAAAC,MAAO,EAAAF,KAAA;IAKrC;;;AAGG;AACH;AAgCA;;;;IAIG,MAAAG,WAAA,QAAAb,OAAA,CAAAc,eAAA,CAAAC,YAAA;IACQ,MAAAC,SAAM,OAAY,CAAAhB,OAAgB,IAAAc,eAAO,CAAAG,UAAA,SAAAzC,QAAA;IA0CpD,IAAAqC,WAAA,IAAAG,SAAA;;;;IAIG;IACW,MAAAE,OAAA,GAAM,KAAAnB,cAA4B,CAAAoB,OAAA;IAkEhDD,OAAA,CAAAb,OAAA,CAAAe,GAAA;;;QAGG,MAAAV,KAAA,QAAAV,OAAA,CAAAoB,GAAA;QACH,IAAAV,KAAqB,EAAU;UAyB/B,MAAAW,OAAA,QAAAC,oBAAA,CAAAZ,KAAA;;;cAGG,KAAAa,cAAA,CAAA5B,QAAA;gBACyB,IAAE6B,aAAA,CAAgBC,eAAI,CAAAJ,OAAA;kBASlD,KAAA1C,MAAA,CAAA+C,KAAA;;;kBAGG,MAAAd,MAAA,QAAAe,wBAAA,CAAAP,GAAA,EAAAQ,aAAA;kBACoC,KAAAC,WAAW,CAAAjB,MAAA,EAAAW,cAAwB,CAAA5B,QAAA;kBA8B1E;;kBAGG,KAAAhB,MAAA,CAAA+C,KAAA;kBACsB,IAAW,CAAE/C,MAAA,CAAAmD,QAAA,0EAAwBV,GAAA;gBAU9D;;;cAGG,KAAAG,cAAA,CAAAQ,6BAAA;gBAEgB,IAAAC,iBAAQ,CACxBC,mBAAA,CAAkBZ,OAAO;kBA8B5B,KAAA1C,MAAA,CAAA+C,KAAA;;;kBAGG,MAAAd,MAAA,QAAAe,wBAAA,CAAAP,GAAA,EAAAc,iBAAA;kBACuB,KAAAL,WAAc,CAAAjB,MAAA,EAAAW,cAAyB,CAAAY,YAAA;kBAUjE;;kBAGG,KAAAxD,MAAA,CAAA+C,KAAA;kBACH,KAAqC/C,MAAG,CAAAmD,QAAA,8EAAwBV,GAAA;gBA2BhE;;;gBAGG,IAAAgB,kBAAA,CAAAC,oBAAA,CAAAhB,OAAA;kBACyB,KAAA1C,MAAA,CAAA+C,KAAwB;kBAMpD,KAAA/C,MAAA,CAAAmD,QAAA,+DAAAV,GAAA;;;kBAGG,KAAAS,WAAA,CAAAjB,MAAA,EAAAW,cAAA,CAAAe,aAAA;kBAEmB;gBA8BtB,O;;;gBAIG;;;YAWA;UACH;QA2BA;;;MAEG,SAAAC,YAAA,CAAAnB,GAAA;QACH,MAAAV,KAAA,GAA4B,KAAAV,OAAM,CAAAoB,GAAO;QAOzC,IAAAV,KAAA;;;YAIG,KAAA/B,MAAA,CAAA+C,KAAA;uBAC4B,CAAAI,QAAsB,0DAAeV,GAAA;YAQpE,KAAAoB,kBAAA,CAAApB,GAAA;;QAEG;MACH;IAUA;;;AAGG;;AAMH;;IAEG;MACa,MAAAqB,UAAe,GAAAC,IAAA,CAAAC,KAAO,CAAAC,SAAA;MAwDtC;;;AAGG;AACH;AA8BA;yEAGG;IACH,EAiDA,OAAAC,KAAA;;;;EAIG;AACH;AA4BA;;;IAGG,YAAA9C,cAAA,CAAAC,OAAA,CAAAoB,GAAA;EACH;EA8BA;;;;AAIG;EACH0B,OAAkBA,CAAA1B,GAAA,EAAAV,KAAA;IAQlB,KAAAX,cAAA,CAAA+C,OAAA,CAAA1B,GAAA,EAAAV,KAAA;;;;AAIG;AACH;EAsCAqC,WAAAC,UAAA;;;;;;IAMG;IACH,MAAAC,aACI,GAAQ,IAAE,CAAA3B,oBAEV,CAAW4B,OAAA;IAaf,KAAAD,aAAA,KAAAE,aAAA,CAAAC,eAAA,CAAAH,aAAA;;;;IAIG,OAAA3E,YAAA,CAAA+E,QAAA,KAAAF,aAAA,IAAAF,aAAA;EACH;EAWA;;;AAGG;EACHK,WAAWJ,OAAM;IAOjB,KAAAvE,MAAA,CAAA+C,KAAA;;IAEG,KAAAoB,OAAA,CAAA1B,GAAA,EAAAsB,IAAA,CAAAa,SAAA,CAAAL,OAAA;IACI,KAAAV,kBAAY,CAAApB,GAAA;EAOnB;;AAEG;AACG;AAqBN;;;;IAIG,IAAAP,WAAA;MACG,OAAA6B,IAAA,CAAAC,KAAA,CAAA9B,WAAgC;IAwBtC;;;;;AAKG;AACH;AAoBA;;;IAGG,KAAAlC,MAAA,CAAAmD,QAAA,4DAAAV,GAAA;IACH,MAAAP,WAAc,GAAU,IAAE,CAAA2C,cAAe;IAiBzC,IAAA3C,WAAA,CAAA4C,OAAA,CAAArC,GAAA;;MAEGP,WAAA,CAAA6C,IAAA,CAAAtC,GAAA;MACH,KAAA0B,OAAoB,CAAIhC,eAAA,CAAAC,YAAA,EAAA2B,IAAA,CAAAa,SAAA,CAAA1C,WAAA;MAexB,KAAAlC,MAAA,CAAAU,OAAA;;MAGG,KAAAV,MAAA,CAAAU,OAAA;IACH;EAIA;;;AAGG;AACH;EAQAsE,wBAAAvC,GAAA;;IAEG,KAAAzC,MAAA,CAAAmD,QAAA,iEAAAV,GAAA;IACH,MAAAP,WAAkB,QAAA2C,cAAA;IAIlB,MAAAI,YAAA,GAAA/C,WAAA,CAAA4C,OAAA,CAAArC,GAAA;;MAEGP,WAAA,CAAAgD,MAAA,CAAAD,YAAA;MACK,IAAI,CAAId,OAAA,CAAAhC,eAAA,CAAAC,YAAA,EAAA2B,IAAA,CAAAa,SAAA,CAAA1C,WAAA;MAIhB,KAAAlC,MAAA,CAAA+C,KAAA;;;IAIG;EACH;EAeA;;;AAGG;EACH,MAAAoC,cAAoB1C,GAAC;IAUrB,WAAA0C,aAAA,CAAA1C,GAAA;;;EAGG;AACH;AAUA;;;IAGG,MAAA2C,aAAA,CAAA3C,GAAA;IACH,KAAA4C,cAAiB,CAAA5C,GAAA,EAAaG,cAAe,CAAA5B,QAAA;EAU7C;;AAEG;AACH;AAWA;;;;EAIG;;AA4CH;;;EAGGsE,mBAAA7C,GAAA;IACH,MAAA6C,kBAAyB,CAAA7C,GAAA;IAgCzB,KAAA4C,cAAA,CAAA5C,GAAA,EAAAG,cAAA,CAAAe,aAAA;;;AAGG;AACH;AAcA;;;;IAIG,IAAA4B,IAAA;MACH,MAAAlD,SAAA,OAA8B,CAAAM,oBAAiB,CAAA4C,IAAA;MAmC/C,IAAAlD,SAAiB,IAWjBA,SAAA,CAAAmD,cAAA,e,2CAEGnD,SAAA,CAAAmD,cAAA;QACH,OAAiBnD,SAAO;MA4CxB,O;QAEG,KAAArC,MAAA,CAAAkE,KAAA;;IA2BH,OAUwB;MAKxB,KAAAlE,MAAA,CAAAU,OAAyB,yDAA0B;IAoBnD;;;MAGG+E,WAAA;MACeC,YAAA,EAAI;IAgDtB;;EAEG;;AA0BH;;AAEG;EACHxC,WAAyBA,CAAAT,GAAA,EAAAkD,IAAA;IAOzB,KAAA3F,MAAA,CAAA+C,KAAA;;;MAGG,KAAAH,cAAA,CAAA5B,QAAA;QACH,IAAAqB,SAAyB,CAACuD,OAAO,CAAAd,OAAA,CAASrC,GAAI;UAQ9C,KAAAzC,MAAA,CAAA6F,IAAA;;;;MAIG,KAAAjD,cAAA,CAAAY,YAAA;QACe,IACRnB,SAAA,CAAAoD,WAAA,CAAAX,OACN,CAAArC,GAAA,CAAO,KACY;UA0C1B,KAAAzC,MAAA,CAAA6F,IAAA;UAEMxD,SAAA,CAAAoD,WAAA,CAAAV,IAAA,CAAAtC,GAAmC,CAC5B"},"metadata":{},"sourceType":"module","externalDependencies":[]}