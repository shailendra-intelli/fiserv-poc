{"ast":null,"code":"/*! @azure/msal-common v14.7.0 2024-02-07 */\n'use strict';\n\nimport { BaseClient } from './BaseClient.mjs';\nimport { RequestParameterBuilder } from '../request/RequestParameterBuilder.mjs';\nimport { Separators, GrantType, AuthenticationScheme, PromptValue, HeaderNames } from '../utils/Constants.mjs';\nimport { CLIENT_ID, RETURN_SPA_CODE } from '../constants/AADServerParamKeys.mjs';\nimport { isOidcProtocolMode } from '../config/ClientConfiguration.mjs';\nimport { ResponseHandler } from '../response/ResponseHandler.mjs';\nimport { StringUtils } from '../utils/StringUtils.mjs';\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { UrlString } from '../url/UrlString.mjs';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.mjs';\nimport { nowSeconds } from '../utils/TimeUtils.mjs';\nimport { buildClientInfo, buildClientInfoFromHomeAccountId } from '../account/ClientInfo.mjs';\nimport { CcsCredentialType } from '../account/CcsCredential.mjs';\nimport { createClientConfigurationError } from '../error/ClientConfigurationError.mjs';\nimport { RequestValidator } from '../request/RequestValidator.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { invokeAsync } from '../utils/FunctionWrappers.mjs';\nimport { requestCannotBeMade, authorizationCodeMissingFromServerResponse } from '../error/ClientAuthErrorCodes.mjs';\nimport { logoutRequestEmpty, missingSshJwk } from '../error/ClientConfigurationErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Oauth2.0 Authorization Code client\n * @internal\n */\nclass AuthorizationCodeClient extends BaseClient {\n  constructor(configuration, performanceClient) {\n    super(configuration, performanceClient);\n    // Flag to indicate if client is for hybrid spa auth code redemption\n    this.includeRedirectUri = true;\n    this.oidcDefaultScopes = this.config.authOptions.authority.options.OIDCOptions?.defaultScopes;\n  }\n  /**\n   * Creates the URL of the authorization request letting the user input credentials and consent to the\n   * application. The URL target the /authorize endpoint of the authority configured in the\n   * application object.\n   *\n   * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\n   * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\n   * acquireToken(AuthorizationCodeRequest)\n   * @param request\n   */\n  async getAuthCodeUrl(request) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.GetAuthCodeUrl, request.correlationId);\n    const queryString = await invokeAsync(this.createAuthCodeUrlQueryString.bind(this), PerformanceEvents.AuthClientCreateQueryString, this.logger, this.performanceClient, request.correlationId)(request);\n    return UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString);\n  }\n  /**\n   * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\n   * authorization_code_grant\n   * @param request\n   */\n  async acquireToken(request, authCodePayload) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);\n    if (!request.code) {\n      throw createClientAuthError(requestCannotBeMade);\n    }\n    const reqTimestamp = nowSeconds();\n    const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.AuthClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(this.authority, request);\n    // Retrieve requestId from response headers\n    const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];\n    const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient);\n    // Validate response. This function throws a server error if an error is returned by the server.\n    responseHandler.validateTokenResponse(response.body);\n    return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, authCodePayload, undefined, undefined, undefined, requestId);\n  }\n  /**\n   * Handles the hash fragment response from public client code request. Returns a code response used by\n   * the client to exchange for a token in acquireToken.\n   * @param hashFragment\n   */\n  handleFragmentResponse(serverParams, cachedState) {\n    // Handle responses.\n    const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);\n    // Get code response\n    responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState);\n    // throw when there is no auth code in the response\n    if (!serverParams.code) {\n      throw createClientAuthError(authorizationCodeMissingFromServerResponse);\n    }\n    return serverParams;\n  }\n  /**\n   * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\n   * Default behaviour is to redirect the user to `window.location.href`.\n   * @param authorityUri\n   */\n  getLogoutUri(logoutRequest) {\n    // Throw error if logoutRequest is null/undefined\n    if (!logoutRequest) {\n      throw createClientConfigurationError(logoutRequestEmpty);\n    }\n    const queryString = this.createLogoutUrlQueryString(logoutRequest);\n    // Construct logout URI\n    return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);\n  }\n  /**\n   * Executes POST request to token endpoint\n   * @param authority\n   * @param request\n   */\n  async executeTokenRequest(authority, request) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);\n    const queryParametersString = this.createTokenQueryParameters(request);\n    const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\n    const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.AuthClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);\n    let ccsCredential = undefined;\n    if (request.clientInfo) {\n      try {\n        const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);\n        ccsCredential = {\n          credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n          type: CcsCredentialType.HOME_ACCOUNT_ID\n        };\n      } catch (e) {\n        this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n      }\n    }\n    const headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);\n    const thumbprint = {\n      clientId: request.tokenBodyParameters?.clientId || this.config.authOptions.clientId,\n      authority: authority.canonicalAuthority,\n      scopes: request.scopes,\n      claims: request.claims,\n      authenticationScheme: request.authenticationScheme,\n      resourceRequestMethod: request.resourceRequestMethod,\n      resourceRequestUri: request.resourceRequestUri,\n      shrClaims: request.shrClaims,\n      sshKid: request.sshKid\n    };\n    return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint);\n  }\n  /**\n   * Generates a map for all the params to be sent to the service\n   * @param request\n   */\n  async createTokenRequestBody(request) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);\n    const parameterBuilder = new RequestParameterBuilder();\n    parameterBuilder.addClientId(request.tokenBodyParameters?.[CLIENT_ID] || this.config.authOptions.clientId);\n    /*\n     * For hybrid spa flow, there will be a code but no verifier\n     * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\n     */\n    if (!this.includeRedirectUri) {\n      // Just validate\n      RequestValidator.validateRedirectUri(request.redirectUri);\n    } else {\n      // Validate and include redirect uri\n      parameterBuilder.addRedirectUri(request.redirectUri);\n    }\n    // Add scope array, parameter builder will add default scopes and dedupe\n    parameterBuilder.addScopes(request.scopes, true, this.oidcDefaultScopes);\n    // add code: user set, not validated\n    parameterBuilder.addAuthorizationCode(request.code);\n    // Add library metadata\n    parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n    parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\n    parameterBuilder.addThrottling();\n    if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {\n      parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n    }\n    // add code_verifier if passed\n    if (request.codeVerifier) {\n      parameterBuilder.addCodeVerifier(request.codeVerifier);\n    }\n    if (this.config.clientCredentials.clientSecret) {\n      parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\n    }\n    if (this.config.clientCredentials.clientAssertion) {\n      const clientAssertion = this.config.clientCredentials.clientAssertion;\n      parameterBuilder.addClientAssertion(clientAssertion.assertion);\n      parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\n    }\n    parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\n    parameterBuilder.addClientInfo();\n    if (request.authenticationScheme === AuthenticationScheme.POP) {\n      const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);\n      const reqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);\n      // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\n      parameterBuilder.addPopToken(reqCnfData.reqCnfString);\n    } else if (request.authenticationScheme === AuthenticationScheme.SSH) {\n      if (request.sshJwk) {\n        parameterBuilder.addSshJwk(request.sshJwk);\n      } else {\n        throw createClientConfigurationError(missingSshJwk);\n      }\n    }\n    const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n    parameterBuilder.addCorrelationId(correlationId);\n    if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n      parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n    }\n    let ccsCred = undefined;\n    if (request.clientInfo) {\n      try {\n        const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);\n        ccsCred = {\n          credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n          type: CcsCredentialType.HOME_ACCOUNT_ID\n        };\n      } catch (e) {\n        this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n      }\n    } else {\n      ccsCred = request.ccsCredential;\n    }\n    // Adds these as parameters in the request instead of headers to prevent CORS preflight request\n    if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\n      switch (ccsCred.type) {\n        case CcsCredentialType.HOME_ACCOUNT_ID:\n          try {\n            const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\n            parameterBuilder.addCcsOid(clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n          }\n          break;\n        case CcsCredentialType.UPN:\n          parameterBuilder.addCcsUpn(ccsCred.credential);\n          break;\n      }\n    }\n    if (request.tokenBodyParameters) {\n      parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters);\n    }\n    // Add hybrid spa parameters if not already provided\n    if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[RETURN_SPA_CODE])) {\n      parameterBuilder.addExtraQueryParameters({\n        [RETURN_SPA_CODE]: \"1\"\n      });\n    }\n    return parameterBuilder.createQueryString();\n  }\n  /**\n   * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\n   * @param request\n   */\n  async createAuthCodeUrlQueryString(request) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateQueryString, request.correlationId);\n    const parameterBuilder = new RequestParameterBuilder();\n    parameterBuilder.addClientId(request.extraQueryParameters?.[CLIENT_ID] || this.config.authOptions.clientId);\n    const requestScopes = [...(request.scopes || []), ...(request.extraScopesToConsent || [])];\n    parameterBuilder.addScopes(requestScopes, true, this.oidcDefaultScopes);\n    // validate the redirectUri (to be a non null value)\n    parameterBuilder.addRedirectUri(request.redirectUri);\n    // generate the correlationId if not set by the user and add\n    const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n    parameterBuilder.addCorrelationId(correlationId);\n    // add response_mode. If not passed in it defaults to query.\n    parameterBuilder.addResponseMode(request.responseMode);\n    // add response_type = code\n    parameterBuilder.addResponseTypeCode();\n    // add library info parameters\n    parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n    if (!isOidcProtocolMode(this.config)) {\n      parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\n    }\n    // add client_info=1\n    parameterBuilder.addClientInfo();\n    if (request.codeChallenge && request.codeChallengeMethod) {\n      parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);\n    }\n    if (request.prompt) {\n      parameterBuilder.addPrompt(request.prompt);\n    }\n    if (request.domainHint) {\n      parameterBuilder.addDomainHint(request.domainHint);\n    }\n    // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object\n    if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\n      // AAD will throw if prompt=select_account is passed with an account hint\n      if (request.sid && request.prompt === PromptValue.NONE) {\n        // SessionID is only used in silent calls\n        this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\");\n        parameterBuilder.addSid(request.sid);\n      } else if (request.account) {\n        const accountSid = this.extractAccountSid(request.account);\n        const accountLoginHintClaim = this.extractLoginHint(request.account);\n        // If login_hint claim is present, use it over sid/username\n        if (accountLoginHintClaim) {\n          this.logger.verbose(\"createAuthCodeUrlQueryString: login_hint claim present on account\");\n          parameterBuilder.addLoginHint(accountLoginHintClaim);\n          try {\n            const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n            parameterBuilder.addCcsOid(clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n          }\n        } else if (accountSid && request.prompt === PromptValue.NONE) {\n          /*\n           * If account and loginHint are provided, we will check account first for sid before adding loginHint\n           * SessionId is only used in silent calls\n           */\n          this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\");\n          parameterBuilder.addSid(accountSid);\n          try {\n            const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n            parameterBuilder.addCcsOid(clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n          }\n        } else if (request.loginHint) {\n          this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from request\");\n          parameterBuilder.addLoginHint(request.loginHint);\n          parameterBuilder.addCcsUpn(request.loginHint);\n        } else if (request.account.username) {\n          // Fallback to account username if provided\n          this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from account\");\n          parameterBuilder.addLoginHint(request.account.username);\n          try {\n            const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n            parameterBuilder.addCcsOid(clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\");\n          }\n        }\n      } else if (request.loginHint) {\n        this.logger.verbose(\"createAuthCodeUrlQueryString: No account, adding login_hint from request\");\n        parameterBuilder.addLoginHint(request.loginHint);\n        parameterBuilder.addCcsUpn(request.loginHint);\n      }\n    } else {\n      this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\");\n    }\n    if (request.nonce) {\n      parameterBuilder.addNonce(request.nonce);\n    }\n    if (request.state) {\n      parameterBuilder.addState(request.state);\n    }\n    if (request.claims || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n      parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n    }\n    if (request.extraQueryParameters) {\n      parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n    }\n    if (request.nativeBroker) {\n      // signal ests that this is a WAM call\n      parameterBuilder.addNativeBroker();\n      // pass the req_cnf for POP\n      if (request.authenticationScheme === AuthenticationScheme.POP) {\n        const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);\n        // to reduce the URL length, it is recommended to send the hash of the req_cnf instead of the whole string\n        const reqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);\n        parameterBuilder.addPopToken(reqCnfData.reqCnfHash);\n      }\n    }\n    return parameterBuilder.createQueryString();\n  }\n  /**\n   * This API validates the `EndSessionRequest` and creates a URL\n   * @param request\n   */\n  createLogoutUrlQueryString(request) {\n    const parameterBuilder = new RequestParameterBuilder();\n    if (request.postLogoutRedirectUri) {\n      parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);\n    }\n    if (request.correlationId) {\n      parameterBuilder.addCorrelationId(request.correlationId);\n    }\n    if (request.idTokenHint) {\n      parameterBuilder.addIdTokenHint(request.idTokenHint);\n    }\n    if (request.state) {\n      parameterBuilder.addState(request.state);\n    }\n    if (request.logoutHint) {\n      parameterBuilder.addLogoutHint(request.logoutHint);\n    }\n    if (request.extraQueryParameters) {\n      parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n    }\n    return parameterBuilder.createQueryString();\n  }\n  /**\n   * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\n   * @param account\n   */\n  extractAccountSid(account) {\n    return account.idTokenClaims?.sid || null;\n  }\n  extractLoginHint(account) {\n    return account.idTokenClaims?.login_hint || null;\n  }\n}\nexport { AuthorizationCodeClient };","map":{"version":3,"names":["AuthorizationCodeClient","BaseClient","constructor","configuration","performanceClient","includeRedirectUri","oidcDefaultScopes","config","authOptions","authority","options","OIDCOptions","defaultScopes","getAuthCodeUrl","request","addQueueMeasurement","PerformanceEvents","GetAuthCodeUrl","correlationId","queryString","invokeAsync","createAuthCodeUrlQueryString","bind","AuthClientCreateQueryString","logger","UrlString","appendQueryString","authorizationEndpoint","acquireToken","authCodePayload","AuthClientAcquireToken","code","createClientAuthError","requestCannotBeMade","reqTimestamp","nowSeconds","response","executeTokenRequest","AuthClientExecuteTokenRequest","requestId","headers","HeaderNames","X_MS_REQUEST_ID","responseHandler","ResponseHandler","clientId","cacheManager","cryptoUtils","serializableCache","persistencePlugin","validateTokenResponse","body","handleServerTokenResponse","HandleServerTokenResponse","undefined","handleFragmentResponse","serverParams","cachedState","validateServerAuthorizationCodeResponse","authorizationCodeMissingFromServerResponse","getLogoutUri","logoutRequest","createClientConfigurationError","logoutRequestEmpty","createLogoutUrlQueryString","endSessionEndpoint","queryParametersString","createTokenQueryParameters","endpoint","tokenEndpoint","requestBody","createTokenRequestBody","AuthClientCreateTokenRequestBody","ccsCredential","clientInfo","buildClientInfo","base64Decode","credential","uid","Separators","CLIENT_INFO_SEPARATOR","utid","type","CcsCredentialType","HOME_ACCOUNT_ID","e","verbose","createTokenRequestHeaders","thumbprint","tokenBodyParameters","canonicalAuthority","scopes","claims","authenticationScheme","resourceRequestMethod","resourceRequestUri","shrClaims","sshKid","executePostToTokenEndpoint","AuthorizationCodeClientExecutePostToTokenEndpoint","parameterBuilder","RequestParameterBuilder","addClientId","CLIENT_ID","RequestValidator","validateRedirectUri","redirectUri","addRedirectUri","addScopes","addAuthorizationCode","addLibraryInfo","libraryInfo","addApplicationTelemetry","telemetry","application","addThrottling","serverTelemetryManager","isOidcProtocolMode","addServerTelemetry","codeVerifier","addCodeVerifier","clientCredentials","clientSecret","addClientSecret","clientAssertion","addClientAssertion","assertion","addClientAssertionType","assertionType","addGrantType","GrantType","AUTHORIZATION_CODE_GRANT","addClientInfo","AuthenticationScheme","POP","popTokenGenerator","PopTokenGenerator","reqCnfData","generateCnf","PopTokenGenerateCnf","addPopToken","reqCnfString","SSH","sshJwk","addSshJwk","missingSshJwk","cryptoInterface","createNewGuid","addCorrelationId","StringUtils","isEmptyObj","clientCapabilities","length","addClaims","ccsCred","systemOptions","preventCorsPreflight","buildClientInfoFromHomeAccountId","addCcsOid","UPN","addCcsUpn","addExtraQueryParameters","enableSpaAuthorizationCode","RETURN_SPA_CODE","createQueryString","extraQueryParameters","requestScopes","extraScopesToConsent","addResponseMode","responseMode","addResponseTypeCode","codeChallenge","codeChallengeMethod","addCodeChallengeParams","prompt","addPrompt","domainHint","addDomainHint","PromptValue","SELECT_ACCOUNT","sid","NONE","addSid","account","accountSid","extractAccountSid","accountLoginHintClaim","extractLoginHint","addLoginHint","homeAccountId","loginHint","username","nonce","addNonce","state","addState","nativeBroker","addNativeBroker","reqCnfHash","postLogoutRedirectUri","addPostLogoutRedirectUri","idTokenHint","addIdTokenHint","logoutHint","addLogoutHint","idTokenClaims","login_hint"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-common\\src\\client\\AuthorizationCodeClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { BaseClient } from \"./BaseClient\";\nimport { CommonAuthorizationUrlRequest } from \"../request/CommonAuthorizationUrlRequest\";\nimport { CommonAuthorizationCodeRequest } from \"../request/CommonAuthorizationCodeRequest\";\nimport { Authority } from \"../authority/Authority\";\nimport { RequestParameterBuilder } from \"../request/RequestParameterBuilder\";\nimport {\n    GrantType,\n    AuthenticationScheme,\n    PromptValue,\n    Separators,\n    HeaderNames,\n} from \"../utils/Constants\";\nimport * as AADServerParamKeys from \"../constants/AADServerParamKeys\";\nimport {\n    ClientConfiguration,\n    isOidcProtocolMode,\n} from \"../config/ClientConfiguration\";\nimport { ServerAuthorizationTokenResponse } from \"../response/ServerAuthorizationTokenResponse\";\nimport { NetworkResponse } from \"../network/NetworkManager\";\nimport { ResponseHandler } from \"../response/ResponseHandler\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\nimport { StringUtils } from \"../utils/StringUtils\";\nimport {\n    ClientAuthErrorCodes,\n    createClientAuthError,\n} from \"../error/ClientAuthError\";\nimport { UrlString } from \"../url/UrlString\";\nimport { ServerAuthorizationCodeResponse } from \"../response/ServerAuthorizationCodeResponse\";\nimport { CommonEndSessionRequest } from \"../request/CommonEndSessionRequest\";\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator\";\nimport { RequestThumbprint } from \"../network/RequestThumbprint\";\nimport { AuthorizationCodePayload } from \"../response/AuthorizationCodePayload\";\nimport * as TimeUtils from \"../utils/TimeUtils\";\nimport { AccountInfo } from \"../account/AccountInfo\";\nimport {\n    buildClientInfoFromHomeAccountId,\n    buildClientInfo,\n} from \"../account/ClientInfo\";\nimport { CcsCredentialType, CcsCredential } from \"../account/CcsCredential\";\nimport {\n    createClientConfigurationError,\n    ClientConfigurationErrorCodes,\n} from \"../error/ClientConfigurationError\";\nimport { RequestValidator } from \"../request/RequestValidator\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent\";\nimport { invokeAsync } from \"../utils/FunctionWrappers\";\n\n/**\n * Oauth2.0 Authorization Code client\n * @internal\n */\nexport class AuthorizationCodeClient extends BaseClient {\n    // Flag to indicate if client is for hybrid spa auth code redemption\n    protected includeRedirectUri: boolean = true;\n    private oidcDefaultScopes;\n\n    constructor(\n        configuration: ClientConfiguration,\n        performanceClient?: IPerformanceClient\n    ) {\n        super(configuration, performanceClient);\n        this.oidcDefaultScopes =\n            this.config.authOptions.authority.options.OIDCOptions?.defaultScopes;\n    }\n\n    /**\n     * Creates the URL of the authorization request letting the user input credentials and consent to the\n     * application. The URL target the /authorize endpoint of the authority configured in the\n     * application object.\n     *\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\n     * acquireToken(AuthorizationCodeRequest)\n     * @param request\n     */\n    async getAuthCodeUrl(\n        request: CommonAuthorizationUrlRequest\n    ): Promise<string> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.GetAuthCodeUrl,\n            request.correlationId\n        );\n\n        const queryString = await invokeAsync(\n            this.createAuthCodeUrlQueryString.bind(this),\n            PerformanceEvents.AuthClientCreateQueryString,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(request);\n\n        return UrlString.appendQueryString(\n            this.authority.authorizationEndpoint,\n            queryString\n        );\n    }\n\n    /**\n     * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\n     * authorization_code_grant\n     * @param request\n     */\n    async acquireToken(\n        request: CommonAuthorizationCodeRequest,\n        authCodePayload?: AuthorizationCodePayload\n    ): Promise<AuthenticationResult> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthClientAcquireToken,\n            request.correlationId\n        );\n\n        if (!request.code) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.requestCannotBeMade\n            );\n        }\n\n        const reqTimestamp = TimeUtils.nowSeconds();\n        const response = await invokeAsync(\n            this.executeTokenRequest.bind(this),\n            PerformanceEvents.AuthClientExecuteTokenRequest,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(this.authority, request);\n\n        // Retrieve requestId from response headers\n        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];\n\n        const responseHandler = new ResponseHandler(\n            this.config.authOptions.clientId,\n            this.cacheManager,\n            this.cryptoUtils,\n            this.logger,\n            this.config.serializableCache,\n            this.config.persistencePlugin,\n            this.performanceClient\n        );\n\n        // Validate response. This function throws a server error if an error is returned by the server.\n        responseHandler.validateTokenResponse(response.body);\n\n        return invokeAsync(\n            responseHandler.handleServerTokenResponse.bind(responseHandler),\n            PerformanceEvents.HandleServerTokenResponse,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(\n            response.body,\n            this.authority,\n            reqTimestamp,\n            request,\n            authCodePayload,\n            undefined,\n            undefined,\n            undefined,\n            requestId\n        );\n    }\n\n    /**\n     * Handles the hash fragment response from public client code request. Returns a code response used by\n     * the client to exchange for a token in acquireToken.\n     * @param hashFragment\n     */\n    handleFragmentResponse(\n        serverParams: ServerAuthorizationCodeResponse,\n        cachedState: string\n    ): AuthorizationCodePayload {\n        // Handle responses.\n        const responseHandler = new ResponseHandler(\n            this.config.authOptions.clientId,\n            this.cacheManager,\n            this.cryptoUtils,\n            this.logger,\n            null,\n            null\n        );\n\n        // Get code response\n        responseHandler.validateServerAuthorizationCodeResponse(\n            serverParams,\n            cachedState\n        );\n\n        // throw when there is no auth code in the response\n        if (!serverParams.code) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.authorizationCodeMissingFromServerResponse\n            );\n        }\n\n        return serverParams as AuthorizationCodePayload;\n    }\n\n    /**\n     * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\n     * Default behaviour is to redirect the user to `window.location.href`.\n     * @param authorityUri\n     */\n    getLogoutUri(logoutRequest: CommonEndSessionRequest): string {\n        // Throw error if logoutRequest is null/undefined\n        if (!logoutRequest) {\n            throw createClientConfigurationError(\n                ClientConfigurationErrorCodes.logoutRequestEmpty\n            );\n        }\n        const queryString = this.createLogoutUrlQueryString(logoutRequest);\n\n        // Construct logout URI\n        return UrlString.appendQueryString(\n            this.authority.endSessionEndpoint,\n            queryString\n        );\n    }\n\n    /**\n     * Executes POST request to token endpoint\n     * @param authority\n     * @param request\n     */\n    private async executeTokenRequest(\n        authority: Authority,\n        request: CommonAuthorizationCodeRequest\n    ): Promise<NetworkResponse<ServerAuthorizationTokenResponse>> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthClientExecuteTokenRequest,\n            request.correlationId\n        );\n\n        const queryParametersString = this.createTokenQueryParameters(request);\n        const endpoint = UrlString.appendQueryString(\n            authority.tokenEndpoint,\n            queryParametersString\n        );\n\n        const requestBody = await invokeAsync(\n            this.createTokenRequestBody.bind(this),\n            PerformanceEvents.AuthClientCreateTokenRequestBody,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(request);\n\n        let ccsCredential: CcsCredential | undefined = undefined;\n        if (request.clientInfo) {\n            try {\n                const clientInfo = buildClientInfo(\n                    request.clientInfo,\n                    this.cryptoUtils.base64Decode\n                );\n                ccsCredential = {\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n                    type: CcsCredentialType.HOME_ACCOUNT_ID,\n                };\n            } catch (e) {\n                this.logger.verbose(\n                    \"Could not parse client info for CCS Header: \" + e\n                );\n            }\n        }\n        const headers: Record<string, string> = this.createTokenRequestHeaders(\n            ccsCredential || request.ccsCredential\n        );\n\n        const thumbprint: RequestThumbprint = {\n            clientId:\n                request.tokenBodyParameters?.clientId ||\n                this.config.authOptions.clientId,\n            authority: authority.canonicalAuthority,\n            scopes: request.scopes,\n            claims: request.claims,\n            authenticationScheme: request.authenticationScheme,\n            resourceRequestMethod: request.resourceRequestMethod,\n            resourceRequestUri: request.resourceRequestUri,\n            shrClaims: request.shrClaims,\n            sshKid: request.sshKid,\n        };\n\n        return invokeAsync(\n            this.executePostToTokenEndpoint.bind(this),\n            PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(\n            endpoint,\n            requestBody,\n            headers,\n            thumbprint,\n            request.correlationId,\n            PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint\n        );\n    }\n\n    /**\n     * Generates a map for all the params to be sent to the service\n     * @param request\n     */\n    private async createTokenRequestBody(\n        request: CommonAuthorizationCodeRequest\n    ): Promise<string> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthClientCreateTokenRequestBody,\n            request.correlationId\n        );\n\n        const parameterBuilder = new RequestParameterBuilder();\n\n        parameterBuilder.addClientId(\n            request.tokenBodyParameters?.[AADServerParamKeys.CLIENT_ID] ||\n                this.config.authOptions.clientId\n        );\n\n        /*\n         * For hybrid spa flow, there will be a code but no verifier\n         * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\n         */\n        if (!this.includeRedirectUri) {\n            // Just validate\n            RequestValidator.validateRedirectUri(request.redirectUri);\n        } else {\n            // Validate and include redirect uri\n            parameterBuilder.addRedirectUri(request.redirectUri);\n        }\n\n        // Add scope array, parameter builder will add default scopes and dedupe\n        parameterBuilder.addScopes(\n            request.scopes,\n            true,\n            this.oidcDefaultScopes\n        );\n\n        // add code: user set, not validated\n        parameterBuilder.addAuthorizationCode(request.code);\n\n        // Add library metadata\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n        parameterBuilder.addApplicationTelemetry(\n            this.config.telemetry.application\n        );\n        parameterBuilder.addThrottling();\n\n        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {\n            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n        }\n\n        // add code_verifier if passed\n        if (request.codeVerifier) {\n            parameterBuilder.addCodeVerifier(request.codeVerifier);\n        }\n\n        if (this.config.clientCredentials.clientSecret) {\n            parameterBuilder.addClientSecret(\n                this.config.clientCredentials.clientSecret\n            );\n        }\n\n        if (this.config.clientCredentials.clientAssertion) {\n            const clientAssertion =\n                this.config.clientCredentials.clientAssertion;\n            parameterBuilder.addClientAssertion(clientAssertion.assertion);\n            parameterBuilder.addClientAssertionType(\n                clientAssertion.assertionType\n            );\n        }\n\n        parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\n        parameterBuilder.addClientInfo();\n\n        if (request.authenticationScheme === AuthenticationScheme.POP) {\n            const popTokenGenerator = new PopTokenGenerator(\n                this.cryptoUtils,\n                this.performanceClient\n            );\n\n            const reqCnfData = await invokeAsync(\n                popTokenGenerator.generateCnf.bind(popTokenGenerator),\n                PerformanceEvents.PopTokenGenerateCnf,\n                this.logger,\n                this.performanceClient,\n                request.correlationId\n            )(request, this.logger);\n            // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\n            parameterBuilder.addPopToken(reqCnfData.reqCnfString);\n        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {\n            if (request.sshJwk) {\n                parameterBuilder.addSshJwk(request.sshJwk);\n            } else {\n                throw createClientConfigurationError(\n                    ClientConfigurationErrorCodes.missingSshJwk\n                );\n            }\n        }\n\n        const correlationId =\n            request.correlationId ||\n            this.config.cryptoInterface.createNewGuid();\n        parameterBuilder.addCorrelationId(correlationId);\n\n        if (\n            !StringUtils.isEmptyObj(request.claims) ||\n            (this.config.authOptions.clientCapabilities &&\n                this.config.authOptions.clientCapabilities.length > 0)\n        ) {\n            parameterBuilder.addClaims(\n                request.claims,\n                this.config.authOptions.clientCapabilities\n            );\n        }\n\n        let ccsCred: CcsCredential | undefined = undefined;\n        if (request.clientInfo) {\n            try {\n                const clientInfo = buildClientInfo(\n                    request.clientInfo,\n                    this.cryptoUtils.base64Decode\n                );\n                ccsCred = {\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n                    type: CcsCredentialType.HOME_ACCOUNT_ID,\n                };\n            } catch (e) {\n                this.logger.verbose(\n                    \"Could not parse client info for CCS Header: \" + e\n                );\n            }\n        } else {\n            ccsCred = request.ccsCredential;\n        }\n\n        // Adds these as parameters in the request instead of headers to prevent CORS preflight request\n        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\n            switch (ccsCred.type) {\n                case CcsCredentialType.HOME_ACCOUNT_ID:\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(\n                            ccsCred.credential\n                        );\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\n                            \"Could not parse home account ID for CCS Header: \" +\n                                e\n                        );\n                    }\n                    break;\n                case CcsCredentialType.UPN:\n                    parameterBuilder.addCcsUpn(ccsCred.credential);\n                    break;\n            }\n        }\n\n        if (request.tokenBodyParameters) {\n            parameterBuilder.addExtraQueryParameters(\n                request.tokenBodyParameters\n            );\n        }\n\n        // Add hybrid spa parameters if not already provided\n        if (\n            request.enableSpaAuthorizationCode &&\n            (!request.tokenBodyParameters ||\n                !request.tokenBodyParameters[\n                    AADServerParamKeys.RETURN_SPA_CODE\n                ])\n        ) {\n            parameterBuilder.addExtraQueryParameters({\n                [AADServerParamKeys.RETURN_SPA_CODE]: \"1\",\n            });\n        }\n\n        return parameterBuilder.createQueryString();\n    }\n\n    /**\n     * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\n     * @param request\n     */\n    private async createAuthCodeUrlQueryString(\n        request: CommonAuthorizationUrlRequest\n    ): Promise<string> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthClientCreateQueryString,\n            request.correlationId\n        );\n\n        const parameterBuilder = new RequestParameterBuilder();\n\n        parameterBuilder.addClientId(\n            request.extraQueryParameters?.[AADServerParamKeys.CLIENT_ID] ||\n                this.config.authOptions.clientId\n        );\n\n        const requestScopes = [\n            ...(request.scopes || []),\n            ...(request.extraScopesToConsent || []),\n        ];\n        parameterBuilder.addScopes(requestScopes, true, this.oidcDefaultScopes);\n\n        // validate the redirectUri (to be a non null value)\n        parameterBuilder.addRedirectUri(request.redirectUri);\n\n        // generate the correlationId if not set by the user and add\n        const correlationId =\n            request.correlationId ||\n            this.config.cryptoInterface.createNewGuid();\n        parameterBuilder.addCorrelationId(correlationId);\n\n        // add response_mode. If not passed in it defaults to query.\n        parameterBuilder.addResponseMode(request.responseMode);\n\n        // add response_type = code\n        parameterBuilder.addResponseTypeCode();\n\n        // add library info parameters\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n        if (!isOidcProtocolMode(this.config)) {\n            parameterBuilder.addApplicationTelemetry(\n                this.config.telemetry.application\n            );\n        }\n\n        // add client_info=1\n        parameterBuilder.addClientInfo();\n\n        if (request.codeChallenge && request.codeChallengeMethod) {\n            parameterBuilder.addCodeChallengeParams(\n                request.codeChallenge,\n                request.codeChallengeMethod\n            );\n        }\n\n        if (request.prompt) {\n            parameterBuilder.addPrompt(request.prompt);\n        }\n\n        if (request.domainHint) {\n            parameterBuilder.addDomainHint(request.domainHint);\n        }\n\n        // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object\n        if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\n            // AAD will throw if prompt=select_account is passed with an account hint\n            if (request.sid && request.prompt === PromptValue.NONE) {\n                // SessionID is only used in silent calls\n                this.logger.verbose(\n                    \"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\"\n                );\n                parameterBuilder.addSid(request.sid);\n            } else if (request.account) {\n                const accountSid = this.extractAccountSid(request.account);\n                const accountLoginHintClaim = this.extractLoginHint(\n                    request.account\n                );\n                // If login_hint claim is present, use it over sid/username\n                if (accountLoginHintClaim) {\n                    this.logger.verbose(\n                        \"createAuthCodeUrlQueryString: login_hint claim present on account\"\n                    );\n                    parameterBuilder.addLoginHint(accountLoginHintClaim);\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(\n                            request.account.homeAccountId\n                        );\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\n                            \"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\"\n                        );\n                    }\n                } else if (accountSid && request.prompt === PromptValue.NONE) {\n                    /*\n                     * If account and loginHint are provided, we will check account first for sid before adding loginHint\n                     * SessionId is only used in silent calls\n                     */\n                    this.logger.verbose(\n                        \"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\"\n                    );\n                    parameterBuilder.addSid(accountSid);\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(\n                            request.account.homeAccountId\n                        );\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\n                            \"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\"\n                        );\n                    }\n                } else if (request.loginHint) {\n                    this.logger.verbose(\n                        \"createAuthCodeUrlQueryString: Adding login_hint from request\"\n                    );\n                    parameterBuilder.addLoginHint(request.loginHint);\n                    parameterBuilder.addCcsUpn(request.loginHint);\n                } else if (request.account.username) {\n                    // Fallback to account username if provided\n                    this.logger.verbose(\n                        \"createAuthCodeUrlQueryString: Adding login_hint from account\"\n                    );\n                    parameterBuilder.addLoginHint(request.account.username);\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(\n                            request.account.homeAccountId\n                        );\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\n                            \"createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header\"\n                        );\n                    }\n                }\n            } else if (request.loginHint) {\n                this.logger.verbose(\n                    \"createAuthCodeUrlQueryString: No account, adding login_hint from request\"\n                );\n                parameterBuilder.addLoginHint(request.loginHint);\n                parameterBuilder.addCcsUpn(request.loginHint);\n            }\n        } else {\n            this.logger.verbose(\n                \"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\"\n            );\n        }\n\n        if (request.nonce) {\n            parameterBuilder.addNonce(request.nonce);\n        }\n\n        if (request.state) {\n            parameterBuilder.addState(request.state);\n        }\n\n        if (\n            request.claims ||\n            (this.config.authOptions.clientCapabilities &&\n                this.config.authOptions.clientCapabilities.length > 0)\n        ) {\n            parameterBuilder.addClaims(\n                request.claims,\n                this.config.authOptions.clientCapabilities\n            );\n        }\n\n        if (request.extraQueryParameters) {\n            parameterBuilder.addExtraQueryParameters(\n                request.extraQueryParameters\n            );\n        }\n\n        if (request.nativeBroker) {\n            // signal ests that this is a WAM call\n            parameterBuilder.addNativeBroker();\n\n            // pass the req_cnf for POP\n            if (request.authenticationScheme === AuthenticationScheme.POP) {\n                const popTokenGenerator = new PopTokenGenerator(\n                    this.cryptoUtils\n                );\n                // to reduce the URL length, it is recommended to send the hash of the req_cnf instead of the whole string\n                const reqCnfData = await invokeAsync(\n                    popTokenGenerator.generateCnf.bind(popTokenGenerator),\n                    PerformanceEvents.PopTokenGenerateCnf,\n                    this.logger,\n                    this.performanceClient,\n                    request.correlationId\n                )(request, this.logger);\n                parameterBuilder.addPopToken(reqCnfData.reqCnfHash);\n            }\n        }\n\n        return parameterBuilder.createQueryString();\n    }\n\n    /**\n     * This API validates the `EndSessionRequest` and creates a URL\n     * @param request\n     */\n    private createLogoutUrlQueryString(\n        request: CommonEndSessionRequest\n    ): string {\n        const parameterBuilder = new RequestParameterBuilder();\n\n        if (request.postLogoutRedirectUri) {\n            parameterBuilder.addPostLogoutRedirectUri(\n                request.postLogoutRedirectUri\n            );\n        }\n\n        if (request.correlationId) {\n            parameterBuilder.addCorrelationId(request.correlationId);\n        }\n\n        if (request.idTokenHint) {\n            parameterBuilder.addIdTokenHint(request.idTokenHint);\n        }\n\n        if (request.state) {\n            parameterBuilder.addState(request.state);\n        }\n\n        if (request.logoutHint) {\n            parameterBuilder.addLogoutHint(request.logoutHint);\n        }\n\n        if (request.extraQueryParameters) {\n            parameterBuilder.addExtraQueryParameters(\n                request.extraQueryParameters\n            );\n        }\n\n        return parameterBuilder.createQueryString();\n    }\n\n    /**\n     * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\n     * @param account\n     */\n    private extractAccountSid(account: AccountInfo): string | null {\n        return account.idTokenClaims?.sid || null;\n    }\n\n    private extractLoginHint(account: AccountInfo): string | null {\n        return account.idTokenClaims?.login_hint || null;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}