{"ast":null,"code":"/*! @azure/msal-react v2.0.3 2023-09-05 */\n'use strict';\n\nimport React__default, { useEffect, useMemo, useReducer } from 'react';\nimport { WrapperSKU, InteractionStatus, EventMessageUtils } from '@azure/msal-browser';\nimport { MsalContext } from './MsalContext.js';\nimport { accountArraysAreEqual } from './utils/utilities.js';\nimport { version, name } from './packageMetadata.js';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst MsalProviderActionType = {\n  UNBLOCK_INPROGRESS: \"UNBLOCK_INPROGRESS\",\n  EVENT: \"EVENT\"\n};\n/**\n * Returns the next inProgress and accounts state based on event message\n * @param previousState\n * @param action\n */\nconst reducer = (previousState, action) => {\n  const {\n    type,\n    payload\n  } = action;\n  let newInProgress = previousState.inProgress;\n  switch (type) {\n    case MsalProviderActionType.UNBLOCK_INPROGRESS:\n      if (previousState.inProgress === InteractionStatus.Startup) {\n        newInProgress = InteractionStatus.None;\n        payload.logger.info(\"MsalProvider - handleRedirectPromise resolved, setting inProgress to 'none'\");\n      }\n      break;\n    case MsalProviderActionType.EVENT:\n      const message = payload.message;\n      const status = EventMessageUtils.getInteractionStatusFromEvent(message, previousState.inProgress);\n      if (status) {\n        payload.logger.info(`MsalProvider - ${message.eventType} results in setting inProgress from ${previousState.inProgress} to ${status}`);\n        newInProgress = status;\n      }\n      break;\n    default:\n      throw new Error(`Unknown action type: ${type}`);\n  }\n  const currentAccounts = payload.instance.getAllAccounts();\n  if (newInProgress !== previousState.inProgress && !accountArraysAreEqual(currentAccounts, previousState.accounts)) {\n    // Both inProgress and accounts changed\n    return {\n      ...previousState,\n      inProgress: newInProgress,\n      accounts: currentAccounts\n    };\n  } else if (newInProgress !== previousState.inProgress) {\n    // Only only inProgress changed\n    return {\n      ...previousState,\n      inProgress: newInProgress\n    };\n  } else if (!accountArraysAreEqual(currentAccounts, previousState.accounts)) {\n    // Only accounts changed\n    return {\n      ...previousState,\n      accounts: currentAccounts\n    };\n  } else {\n    // Nothing changed\n    return previousState;\n  }\n};\n/**\n * MSAL context provider component. This must be rendered above any other components that use MSAL.\n */\nfunction MsalProvider({\n  instance,\n  children\n}) {\n  useEffect(() => {\n    instance.initializeWrapperLibrary(WrapperSKU.React, version);\n  }, [instance]);\n  // Create a logger instance for msal-react with the same options as PublicClientApplication\n  const logger = useMemo(() => {\n    return instance.getLogger().clone(name, version);\n  }, [instance]);\n  const [state, updateState] = useReducer(reducer, undefined, () => {\n    // Lazy initialization of the initial state\n    return {\n      inProgress: InteractionStatus.Startup,\n      accounts: instance.getAllAccounts()\n    };\n  });\n  useEffect(() => {\n    const callbackId = instance.addEventCallback(message => {\n      updateState({\n        payload: {\n          instance,\n          logger,\n          message\n        },\n        type: MsalProviderActionType.EVENT\n      });\n    });\n    logger.verbose(`MsalProvider - Registered event callback with id: ${callbackId}`);\n    instance.initialize().then(() => {\n      instance.handleRedirectPromise().catch(() => {\n        // Errors should be handled by listening to the LOGIN_FAILURE event\n        return;\n      }).finally(() => {\n        /*\n         * If handleRedirectPromise returns a cached promise the necessary events may not be fired\n         * This is a fallback to prevent inProgress from getting stuck in 'startup'\n         */\n        updateState({\n          payload: {\n            instance,\n            logger\n          },\n          type: MsalProviderActionType.UNBLOCK_INPROGRESS\n        });\n      });\n    }).catch(() => {\n      // Errors should be handled by listening to the LOGIN_FAILURE event\n      return;\n    });\n    return () => {\n      // Remove callback when component unmounts or accounts change\n      if (callbackId) {\n        logger.verbose(`MsalProvider - Removing event callback ${callbackId}`);\n        instance.removeEventCallback(callbackId);\n      }\n    };\n  }, [instance, logger]);\n  const contextValue = {\n    instance,\n    inProgress: state.inProgress,\n    accounts: state.accounts,\n    logger\n  };\n  return React__default.createElement(MsalContext.Provider, {\n    value: contextValue\n  }, children);\n}\nexport { MsalProvider };","map":{"version":3,"names":["MsalProviderActionType","UNBLOCK_INPROGRESS","EVENT","reducer","previousState","action","type","payload","newInProgress","inProgress","InteractionStatus","Startup","None","logger","info","message","status","EventMessageUtils","getInteractionStatusFromEvent","eventType","Error","currentAccounts","instance","getAllAccounts","accountArraysAreEqual","accounts","MsalProvider","children","useEffect","initializeWrapperLibrary","WrapperSKU","React","version","useMemo","getLogger","clone","name","state","updateState","useReducer","undefined","callbackId","addEventCallback","verbose","initialize","then","handleRedirectPromise","catch","finally","removeEventCallback","contextValue","React__default","createElement","MsalContext","Provider","value"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-react\\src\\MsalProvider.tsx"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nimport React, { useEffect, useReducer, useMemo, } from \"react\";\nimport { EventMessageUtils, InteractionStatus, WrapperSKU, } from \"@azure/msal-browser\";\nimport { MsalContext } from \"./MsalContext\";\nimport { accountArraysAreEqual } from \"./utils/utilities\";\nimport { name as SKU, version } from \"./packageMetadata\";\nconst MsalProviderActionType = {\n    UNBLOCK_INPROGRESS: \"UNBLOCK_INPROGRESS\",\n    EVENT: \"EVENT\",\n};\n/**\n * Returns the next inProgress and accounts state based on event message\n * @param previousState\n * @param action\n */\nconst reducer = (previousState, action) => {\n    const { type, payload } = action;\n    let newInProgress = previousState.inProgress;\n    switch (type) {\n        case MsalProviderActionType.UNBLOCK_INPROGRESS:\n            if (previousState.inProgress === InteractionStatus.Startup) {\n                newInProgress = InteractionStatus.None;\n                payload.logger.info(\"MsalProvider - handleRedirectPromise resolved, setting inProgress to 'none'\");\n            }\n            break;\n        case MsalProviderActionType.EVENT:\n            const message = payload.message;\n            const status = EventMessageUtils.getInteractionStatusFromEvent(message, previousState.inProgress);\n            if (status) {\n                payload.logger.info(`MsalProvider - ${message.eventType} results in setting inProgress from ${previousState.inProgress} to ${status}`);\n                newInProgress = status;\n            }\n            break;\n        default:\n            throw new Error(`Unknown action type: ${type}`);\n    }\n    const currentAccounts = payload.instance.getAllAccounts();\n    if (newInProgress !== previousState.inProgress &&\n        !accountArraysAreEqual(currentAccounts, previousState.accounts)) {\n        // Both inProgress and accounts changed\n        return {\n            ...previousState,\n            inProgress: newInProgress,\n            accounts: currentAccounts,\n        };\n    }\n    else if (newInProgress !== previousState.inProgress) {\n        // Only only inProgress changed\n        return {\n            ...previousState,\n            inProgress: newInProgress,\n        };\n    }\n    else if (!accountArraysAreEqual(currentAccounts, previousState.accounts)) {\n        // Only accounts changed\n        return {\n            ...previousState,\n            accounts: currentAccounts,\n        };\n    }\n    else {\n        // Nothing changed\n        return previousState;\n    }\n};\n/**\n * MSAL context provider component. This must be rendered above any other components that use MSAL.\n */\nexport function MsalProvider({ instance, children, }) {\n    useEffect(() => {\n        instance.initializeWrapperLibrary(WrapperSKU.React, version);\n    }, [instance]);\n    // Create a logger instance for msal-react with the same options as PublicClientApplication\n    const logger = useMemo(() => {\n        return instance.getLogger().clone(SKU, version);\n    }, [instance]);\n    const [state, updateState] = useReducer(reducer, undefined, () => {\n        // Lazy initialization of the initial state\n        return {\n            inProgress: InteractionStatus.Startup,\n            accounts: instance.getAllAccounts(),\n        };\n    });\n    useEffect(() => {\n        const callbackId = instance.addEventCallback((message) => {\n            updateState({\n                payload: {\n                    instance,\n                    logger,\n                    message,\n                },\n                type: MsalProviderActionType.EVENT,\n            });\n        });\n        logger.verbose(`MsalProvider - Registered event callback with id: ${callbackId}`);\n        instance\n            .initialize()\n            .then(() => {\n            instance\n                .handleRedirectPromise()\n                .catch(() => {\n                // Errors should be handled by listening to the LOGIN_FAILURE event\n                return;\n            })\n                .finally(() => {\n                /*\n                 * If handleRedirectPromise returns a cached promise the necessary events may not be fired\n                 * This is a fallback to prevent inProgress from getting stuck in 'startup'\n                 */\n                updateState({\n                    payload: {\n                        instance,\n                        logger,\n                    },\n                    type: MsalProviderActionType.UNBLOCK_INPROGRESS,\n                });\n            });\n        })\n            .catch(() => {\n            // Errors should be handled by listening to the LOGIN_FAILURE event\n            return;\n        });\n        return () => {\n            // Remove callback when component unmounts or accounts change\n            if (callbackId) {\n                logger.verbose(`MsalProvider - Removing event callback ${callbackId}`);\n                instance.removeEventCallback(callbackId);\n            }\n        };\n    }, [instance, logger]);\n    const contextValue = {\n        instance,\n        inProgress: state.inProgress,\n        accounts: state.accounts,\n        logger,\n    };\n    return (React.createElement(MsalContext.Provider, { value: contextValue }, children));\n}\n//# sourceMappingURL=MsalProvider.js.map"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}