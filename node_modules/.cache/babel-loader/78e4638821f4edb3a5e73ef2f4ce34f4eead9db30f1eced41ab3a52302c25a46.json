{"ast":null,"code":"/*! @azure/msal-browser v3.5.0 2023-11-07 */\n'use strict';\n\nimport { BrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { DatabaseStorage } from './DatabaseStorage.mjs';\nimport { MemoryStorage } from './MemoryStorage.mjs';\nimport { databaseUnavailable } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This class allows MSAL to store artifacts asynchronously using the DatabaseStorage IndexedDB wrapper,\n * backed up with the more volatile MemoryStorage object for cases in which IndexedDB may be unavailable.\n */\nclass AsyncMemoryStorage {\n  constructor(logger, storeName) {\n    this.inMemoryCache = new MemoryStorage();\n    this.indexedDBCache = new DatabaseStorage();\n    this.logger = logger;\n    this.storeName = storeName;\n  }\n  handleDatabaseAccessError(error) {\n    if (error instanceof BrowserAuthError && error.errorCode === databaseUnavailable) {\n      this.logger.error(\"Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.\");\n    } else {\n      throw error;\n    }\n  }\n  /**\n   * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous\n   * storage object if item isn't found in-memory.\n   * @param key\n   */\n  async getItem(key) {\n    const item = this.inMemoryCache.getItem(key);\n    if (!item) {\n      try {\n        this.logger.verbose(\"Queried item not found in in-memory cache, now querying persistent storage.\");\n        return await this.indexedDBCache.getItem(key);\n      } catch (e) {\n        this.handleDatabaseAccessError(e);\n      }\n    }\n    return item;\n  }\n  /**\n   * Sets the item in the in-memory cache and then tries to set it in the asynchronous\n   * storage object with the given key.\n   * @param key\n   * @param value\n   */\n  async setItem(key, value) {\n    this.inMemoryCache.setItem(key, value);\n    try {\n      await this.indexedDBCache.setItem(key, value);\n    } catch (e) {\n      this.handleDatabaseAccessError(e);\n    }\n  }\n  /**\n   * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.\n   * @param key\n   */\n  async removeItem(key) {\n    this.inMemoryCache.removeItem(key);\n    try {\n      await this.indexedDBCache.removeItem(key);\n    } catch (e) {\n      this.handleDatabaseAccessError(e);\n    }\n  }\n  /**\n   * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the\n   * asynchronous storage object.\n   */\n  async getKeys() {\n    const cacheKeys = this.inMemoryCache.getKeys();\n    if (cacheKeys.length === 0) {\n      try {\n        this.logger.verbose(\"In-memory cache is empty, now querying persistent storage.\");\n        return await this.indexedDBCache.getKeys();\n      } catch (e) {\n        this.handleDatabaseAccessError(e);\n      }\n    }\n    return cacheKeys;\n  }\n  /**\n   * Returns true or false if the given key is present in the cache.\n   * @param key\n   */\n  async containsKey(key) {\n    const containsKey = this.inMemoryCache.containsKey(key);\n    if (!containsKey) {\n      try {\n        this.logger.verbose(\"Key not found in in-memory cache, now querying persistent storage.\");\n        return await this.indexedDBCache.containsKey(key);\n      } catch (e) {\n        this.handleDatabaseAccessError(e);\n      }\n    }\n    return containsKey;\n  }\n  /**\n   * Clears in-memory Map\n   */\n  clearInMemory() {\n    // InMemory cache is a Map instance, clear is straightforward\n    this.logger.verbose(`Deleting in-memory keystore ${this.storeName}`);\n    this.inMemoryCache.clear();\n    this.logger.verbose(`In-memory keystore ${this.storeName} deleted`);\n  }\n  /**\n   * Tries to delete the IndexedDB database\n   * @returns\n   */\n  async clearPersistent() {\n    try {\n      this.logger.verbose(\"Deleting persistent keystore\");\n      const dbDeleted = await this.indexedDBCache.deleteDatabase();\n      if (dbDeleted) {\n        this.logger.verbose(\"Persistent keystore deleted\");\n      }\n      return dbDeleted;\n    } catch (e) {\n      this.handleDatabaseAccessError(e);\n      return false;\n    }\n  }\n}\nexport { AsyncMemoryStorage };","map":{"version":3,"names":["AsyncMemoryStorage","constructor","logger","storeName","inMemoryCache","MemoryStorage","handleDatabaseAccessError","error","BrowserAuthError","item","verbose","e"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\cache\\AsyncMemoryStorage.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Logger } from \"@azure/msal-common\";\nimport {\n    BrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError\";\nimport { DatabaseStorage } from \"./DatabaseStorage\";\nimport { IAsyncStorage } from \"./IAsyncMemoryStorage\";\nimport { MemoryStorage } from \"./MemoryStorage\";\n\n/**\n * This class allows MSAL to store artifacts asynchronously using the DatabaseStorage IndexedDB wrapper,\n * backed up with the more volatile MemoryStorage object for cases in which IndexedDB may be unavailable.\n */\nexport class AsyncMemoryStorage<T> implements IAsyncStorage<T> {\n    private inMemoryCache: MemoryStorage<T>;\n    private indexedDBCache: DatabaseStorage<T>;\n    private logger: Logger;\n    private storeName: string;\n\n    constructor(logger: Logger, storeName: string) {\n        this.inMemoryCache = new MemoryStorage<T>();\n        this.indexedDBCache = new DatabaseStorage<T>();\n        this.logger = logger;\n        this.storeName = storeName;\n    }\n\n    private handleDatabaseAccessError(error: unknown): void {\n        if (\n            error instanceof BrowserAuthError &&\n            error.errorCode === BrowserAuthErrorCodes.databaseUnavailable\n        ) {\n            this.logger.error(\n                \"Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.\"\n            );\n        } else {\n            throw error;\n        }\n    }\n    /**\n     * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous\n     * storage object if item isn't found in-memory.\n     * @param key\n     */\n    async getItem(key: string): Promise<T | null> {\n        const item = this.inMemoryCache.getItem(key);\n        if (!item) {\n            try {\n                this.logger.verbose(\n                    \"Queried item not found in in-memory cache, now querying persistent storage.\"\n                );\n                return await this.indexedDBCache.getItem(key);\n            } catch (e) {\n                this.handleDatabaseAccessError(e);\n            }\n        }\n        return item;\n    }\n\n    /**\n     * Sets the item in the in-memory cache and then tries to set it in the asynchronous\n     * storage object with the given key.\n     * @param key\n     * @param value\n     */\n    async setItem(key: string, value: T): Promise<void> {\n        this.inMemoryCache.setItem(key, value);\n        try {\n            await this.indexedDBCache.setItem(key, value);\n        } catch (e) {\n            this.handleDatabaseAccessError(e);\n        }\n    }\n\n    /**\n     * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.\n     * @param key\n     */\n    async removeItem(key: string): Promise<void> {\n        this.inMemoryCache.removeItem(key);\n        try {\n            await this.indexedDBCache.removeItem(key);\n        } catch (e) {\n            this.handleDatabaseAccessError(e);\n        }\n    }\n\n    /**\n     * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the\n     * asynchronous storage object.\n     */\n    async getKeys(): Promise<string[]> {\n        const cacheKeys = this.inMemoryCache.getKeys();\n        if (cacheKeys.length === 0) {\n            try {\n                this.logger.verbose(\n                    \"In-memory cache is empty, now querying persistent storage.\"\n                );\n                return await this.indexedDBCache.getKeys();\n            } catch (e) {\n                this.handleDatabaseAccessError(e);\n            }\n        }\n        return cacheKeys;\n    }\n\n    /**\n     * Returns true or false if the given key is present in the cache.\n     * @param key\n     */\n    async containsKey(key: string): Promise<boolean> {\n        const containsKey = this.inMemoryCache.containsKey(key);\n        if (!containsKey) {\n            try {\n                this.logger.verbose(\n                    \"Key not found in in-memory cache, now querying persistent storage.\"\n                );\n                return await this.indexedDBCache.containsKey(key);\n            } catch (e) {\n                this.handleDatabaseAccessError(e);\n            }\n        }\n        return containsKey;\n    }\n\n    /**\n     * Clears in-memory Map\n     */\n    clearInMemory(): void {\n        // InMemory cache is a Map instance, clear is straightforward\n        this.logger.verbose(`Deleting in-memory keystore ${this.storeName}`);\n        this.inMemoryCache.clear();\n        this.logger.verbose(`In-memory keystore ${this.storeName} deleted`);\n    }\n\n    /**\n     * Tries to delete the IndexedDB database\n     * @returns\n     */\n    async clearPersistent(): Promise<boolean> {\n        try {\n            this.logger.verbose(\"Deleting persistent keystore\");\n            const dbDeleted = await this.indexedDBCache.deleteDatabase();\n            if (dbDeleted) {\n                this.logger.verbose(\"Persistent keystore deleted\");\n            }\n\n            return dbDeleted;\n        } catch (e) {\n            this.handleDatabaseAccessError(e);\n            return false;\n        }\n    }\n}\n"],"mappings":";;;;;;;;AAKA;AAMA;AAGA;;;;;;AAUgB,MAAAA,kBAAgB;EAO5BC,WAAiCA,CAAAC,MAAA,EAAAC,SAAA;IAYjC,KAAAC,aAAA,OAAAC,aAAA;;;;EAIG;EACGC,0BAAAC,KAA+B,EAAG;IAexC,IAAAA,KAAA,YAAAC,gBAAA,I;;;MAKG,MAAAD,KAAA;IACG;EASN;;;AAGG;;AAUH;;;IAGG,KAAAE,IAAA;MACc;QAejB,KAAAP,MAAA,CAAAQ,OAAA;;QAGG,OAAAC,CAAA;QACe,IAAK,CAAAL,yBAAyB,CAAAK,CAAA;MAehD;;IAEG,OAAAF,IAAA;EACH;EAOA;;;AAGG;AACG;AAcT"},"metadata":{},"sourceType":"module","externalDependencies":[]}