{"ast":null,"code":"/*! @azure/msal-common v14.4.0 2023-11-07 */\n'use strict';\n\nimport { Constants } from './Constants.mjs';\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { noCryptoObject, invalidState } from '../error/ClientAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Class which provides helpers for OAuth 2.0 protocol specific values\n */\nclass ProtocolUtils {\n  /**\n   * Appends user state with random guid, or returns random guid.\n   * @param userState\n   * @param randomGuid\n   */\n  static setRequestState(cryptoObj, userState, meta) {\n    const libraryState = ProtocolUtils.generateLibraryState(cryptoObj, meta);\n    return userState ? `${libraryState}${Constants.RESOURCE_DELIM}${userState}` : libraryState;\n  }\n  /**\n   * Generates the state value used by the common library.\n   * @param randomGuid\n   * @param cryptoObj\n   */\n  static generateLibraryState(cryptoObj, meta) {\n    if (!cryptoObj) {\n      throw createClientAuthError(noCryptoObject);\n    }\n    // Create a state object containing a unique id and the timestamp of the request creation\n    const stateObj = {\n      id: cryptoObj.createNewGuid()\n    };\n    if (meta) {\n      stateObj.meta = meta;\n    }\n    const stateString = JSON.stringify(stateObj);\n    return cryptoObj.base64Encode(stateString);\n  }\n  /**\n   * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.\n   * @param state\n   * @param cryptoObj\n   */\n  static parseRequestState(cryptoObj, state) {\n    if (!cryptoObj) {\n      throw createClientAuthError(noCryptoObject);\n    }\n    if (!state) {\n      throw createClientAuthError(invalidState);\n    }\n    try {\n      // Split the state between library state and user passed state and decode them separately\n      const splitState = state.split(Constants.RESOURCE_DELIM);\n      const libraryState = splitState[0];\n      const userState = splitState.length > 1 ? splitState.slice(1).join(Constants.RESOURCE_DELIM) : Constants.EMPTY_STRING;\n      const libraryStateString = cryptoObj.base64Decode(libraryState);\n      const libraryStateObj = JSON.parse(libraryStateString);\n      return {\n        userRequestState: userState || Constants.EMPTY_STRING,\n        libraryState: libraryStateObj\n      };\n    } catch (e) {\n      throw createClientAuthError(invalidState);\n    }\n  }\n}\nexport { ProtocolUtils };","map":{"version":3,"names":["ProtocolUtils","setRequestState","cryptoObj","userState","meta","libraryState","generateLibraryState","Constants","RESOURCE_DELIM","noCryptoObject","stateObj"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-common\\src\\utils\\ProtocolUtils.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Constants } from \"./Constants\";\nimport { ICrypto } from \"../crypto/ICrypto\";\nimport {\n    ClientAuthErrorCodes,\n    createClientAuthError,\n} from \"../error/ClientAuthError\";\n\n/**\n * Type which defines the object that is stringified, encoded and sent in the state value.\n * Contains the following:\n * - id - unique identifier for this request\n * - ts - timestamp for the time the request was made. Used to ensure that token expiration is not calculated incorrectly.\n * - platformState - string value sent from the platform.\n */\nexport type LibraryStateObject = {\n    id: string;\n    meta?: Record<string, string>;\n};\n\n/**\n * Type which defines the stringified and encoded object sent to the service in the authorize request.\n */\nexport type RequestStateObject = {\n    userRequestState: string;\n    libraryState: LibraryStateObject;\n};\n\n/**\n * Class which provides helpers for OAuth 2.0 protocol specific values\n */\nexport class ProtocolUtils {\n    /**\n     * Appends user state with random guid, or returns random guid.\n     * @param userState\n     * @param randomGuid\n     */\n    static setRequestState(\n        cryptoObj: ICrypto,\n        userState?: string,\n        meta?: Record<string, string>\n    ): string {\n        const libraryState = ProtocolUtils.generateLibraryState(\n            cryptoObj,\n            meta\n        );\n        return userState\n            ? `${libraryState}${Constants.RESOURCE_DELIM}${userState}`\n            : libraryState;\n    }\n\n    /**\n     * Generates the state value used by the common library.\n     * @param randomGuid\n     * @param cryptoObj\n     */\n    static generateLibraryState(\n        cryptoObj: ICrypto,\n        meta?: Record<string, string>\n    ): string {\n        if (!cryptoObj) {\n            throw createClientAuthError(ClientAuthErrorCodes.noCryptoObject);\n        }\n\n        // Create a state object containing a unique id and the timestamp of the request creation\n        const stateObj: LibraryStateObject = {\n            id: cryptoObj.createNewGuid(),\n        };\n\n        if (meta) {\n            stateObj.meta = meta;\n        }\n\n        const stateString = JSON.stringify(stateObj);\n\n        return cryptoObj.base64Encode(stateString);\n    }\n\n    /**\n     * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.\n     * @param state\n     * @param cryptoObj\n     */\n    static parseRequestState(\n        cryptoObj: ICrypto,\n        state: string\n    ): RequestStateObject {\n        if (!cryptoObj) {\n            throw createClientAuthError(ClientAuthErrorCodes.noCryptoObject);\n        }\n\n        if (!state) {\n            throw createClientAuthError(ClientAuthErrorCodes.invalidState);\n        }\n\n        try {\n            // Split the state between library state and user passed state and decode them separately\n            const splitState = state.split(Constants.RESOURCE_DELIM);\n            const libraryState = splitState[0];\n            const userState =\n                splitState.length > 1\n                    ? splitState.slice(1).join(Constants.RESOURCE_DELIM)\n                    : Constants.EMPTY_STRING;\n            const libraryStateString = cryptoObj.base64Decode(libraryState);\n            const libraryStateObj = JSON.parse(\n                libraryStateString\n            ) as LibraryStateObject;\n            return {\n                userRequestState: userState || Constants.EMPTY_STRING,\n                libraryState: libraryStateObj,\n            };\n        } catch (e) {\n            throw createClientAuthError(ClientAuthErrorCodes.invalidState);\n        }\n    }\n}\n"],"mappings":";;;;;;;AAMA;AAMA;;;;AAMG;AACH;AACM,MAAAA,aAAS;;;AAIf;;AAEG;EACG,OAAAC,gBAAAC,SAA2B,EAAAC,SAAA,EAAAC,IAAA;IACb,MAAAC,YAAA,GAASL,aAAA,CAAAM,oBAAA,CAAAJ,SAAA,EAAAE,IAAA;IACb,OAAAD,SAAA,GACd,GAAAE,YAAA,GAAAE,SAAA,CAAAC,cAAA,GAAAL,SAAA,KAEFE,YAAA;;EAEG;AACH;AACI;;;;IAIG,KAAAH,SAAA;iCAEmB,CAAAO,cAEL;IAWjB;;;;IAIG;IACH,IAA2BL,IAAA;MAsB3BM,QAAA,CAAAN,IAAA,GAAAA,IAAA;;;;EAIG;;AAiCN"},"metadata":{},"sourceType":"module","externalDependencies":[]}