{"ast":null,"code":"/*! @azure/msal-browser v3.9.0 2024-02-07 */\n'use strict';\n\nimport { BrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { DatabaseStorage } from './DatabaseStorage.mjs';\nimport { MemoryStorage } from './MemoryStorage.mjs';\nimport { databaseUnavailable } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This class allows MSAL to store artifacts asynchronously using the DatabaseStorage IndexedDB wrapper,\n * backed up with the more volatile MemoryStorage object for cases in which IndexedDB may be unavailable.\n */\nclass AsyncMemoryStorage {\n  constructor(logger, storeName) {\n    this.inMemoryCache = new MemoryStorage();\n    this.indexedDBCache = new DatabaseStorage();\n    this.logger = logger;\n    this.storeName = storeName;\n  }\n  handleDatabaseAccessError(error) {\n    if (error instanceof BrowserAuthError && error.errorCode === databaseUnavailable) {\n      this.logger.error(\"Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.\");\n    } else {\n      throw error;\n    }\n  }\n  /**\n   * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous\n   * storage object if item isn't found in-memory.\n   * @param key\n   */\n  async getItem(key) {\n    const item = this.inMemoryCache.getItem(key);\n    if (!item) {\n      try {\n        this.logger.verbose(\"Queried item not found in in-memory cache, now querying persistent storage.\");\n        return await this.indexedDBCache.getItem(key);\n      } catch (e) {\n        this.handleDatabaseAccessError(e);\n      }\n    }\n    return item;\n  }\n  /**\n   * Sets the item in the in-memory cache and then tries to set it in the asynchronous\n   * storage object with the given key.\n   * @param key\n   * @param value\n   */\n  async setItem(key, value) {\n    this.inMemoryCache.setItem(key, value);\n    try {\n      await this.indexedDBCache.setItem(key, value);\n    } catch (e) {\n      this.handleDatabaseAccessError(e);\n    }\n  }\n  /**\n   * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.\n   * @param key\n   */\n  async removeItem(key) {\n    this.inMemoryCache.removeItem(key);\n    try {\n      await this.indexedDBCache.removeItem(key);\n    } catch (e) {\n      this.handleDatabaseAccessError(e);\n    }\n  }\n  /**\n   * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the\n   * asynchronous storage object.\n   */\n  async getKeys() {\n    const cacheKeys = this.inMemoryCache.getKeys();\n    if (cacheKeys.length === 0) {\n      try {\n        this.logger.verbose(\"In-memory cache is empty, now querying persistent storage.\");\n        return await this.indexedDBCache.getKeys();\n      } catch (e) {\n        this.handleDatabaseAccessError(e);\n      }\n    }\n    return cacheKeys;\n  }\n  /**\n   * Returns true or false if the given key is present in the cache.\n   * @param key\n   */\n  async containsKey(key) {\n    const containsKey = this.inMemoryCache.containsKey(key);\n    if (!containsKey) {\n      try {\n        this.logger.verbose(\"Key not found in in-memory cache, now querying persistent storage.\");\n        return await this.indexedDBCache.containsKey(key);\n      } catch (e) {\n        this.handleDatabaseAccessError(e);\n      }\n    }\n    return containsKey;\n  }\n  /**\n   * Clears in-memory Map\n   */\n  clearInMemory() {\n    // InMemory cache is a Map instance, clear is straightforward\n    this.logger.verbose(`Deleting in-memory keystore ${this.storeName}`);\n    this.inMemoryCache.clear();\n    this.logger.verbose(`In-memory keystore ${this.storeName} deleted`);\n  }\n  /**\n   * Tries to delete the IndexedDB database\n   * @returns\n   */\n  async clearPersistent() {\n    try {\n      this.logger.verbose(\"Deleting persistent keystore\");\n      const dbDeleted = await this.indexedDBCache.deleteDatabase();\n      if (dbDeleted) {\n        this.logger.verbose(\"Persistent keystore deleted\");\n      }\n      return dbDeleted;\n    } catch (e) {\n      this.handleDatabaseAccessError(e);\n      return false;\n    }\n  }\n}\nexport { AsyncMemoryStorage };","map":{"version":3,"names":["AsyncMemoryStorage","constructor","logger","storeName","inMemoryCache","MemoryStorage","indexedDBCache","DatabaseStorage","handleDatabaseAccessError","error","BrowserAuthError","errorCode","databaseUnavailable","getItem","key","item","verbose","e","setItem","value","removeItem","getKeys","cacheKeys","length","containsKey","clearInMemory","clear","clearPersistent","dbDeleted","deleteDatabase"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\cache\\AsyncMemoryStorage.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Logger } from \"@azure/msal-common\";\nimport {\n    BrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError\";\nimport { DatabaseStorage } from \"./DatabaseStorage\";\nimport { IAsyncStorage } from \"./IAsyncMemoryStorage\";\nimport { MemoryStorage } from \"./MemoryStorage\";\n\n/**\n * This class allows MSAL to store artifacts asynchronously using the DatabaseStorage IndexedDB wrapper,\n * backed up with the more volatile MemoryStorage object for cases in which IndexedDB may be unavailable.\n */\nexport class AsyncMemoryStorage<T> implements IAsyncStorage<T> {\n    private inMemoryCache: MemoryStorage<T>;\n    private indexedDBCache: DatabaseStorage<T>;\n    private logger: Logger;\n    private storeName: string;\n\n    constructor(logger: Logger, storeName: string) {\n        this.inMemoryCache = new MemoryStorage<T>();\n        this.indexedDBCache = new DatabaseStorage<T>();\n        this.logger = logger;\n        this.storeName = storeName;\n    }\n\n    private handleDatabaseAccessError(error: unknown): void {\n        if (\n            error instanceof BrowserAuthError &&\n            error.errorCode === BrowserAuthErrorCodes.databaseUnavailable\n        ) {\n            this.logger.error(\n                \"Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.\"\n            );\n        } else {\n            throw error;\n        }\n    }\n    /**\n     * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous\n     * storage object if item isn't found in-memory.\n     * @param key\n     */\n    async getItem(key: string): Promise<T | null> {\n        const item = this.inMemoryCache.getItem(key);\n        if (!item) {\n            try {\n                this.logger.verbose(\n                    \"Queried item not found in in-memory cache, now querying persistent storage.\"\n                );\n                return await this.indexedDBCache.getItem(key);\n            } catch (e) {\n                this.handleDatabaseAccessError(e);\n            }\n        }\n        return item;\n    }\n\n    /**\n     * Sets the item in the in-memory cache and then tries to set it in the asynchronous\n     * storage object with the given key.\n     * @param key\n     * @param value\n     */\n    async setItem(key: string, value: T): Promise<void> {\n        this.inMemoryCache.setItem(key, value);\n        try {\n            await this.indexedDBCache.setItem(key, value);\n        } catch (e) {\n            this.handleDatabaseAccessError(e);\n        }\n    }\n\n    /**\n     * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.\n     * @param key\n     */\n    async removeItem(key: string): Promise<void> {\n        this.inMemoryCache.removeItem(key);\n        try {\n            await this.indexedDBCache.removeItem(key);\n        } catch (e) {\n            this.handleDatabaseAccessError(e);\n        }\n    }\n\n    /**\n     * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the\n     * asynchronous storage object.\n     */\n    async getKeys(): Promise<string[]> {\n        const cacheKeys = this.inMemoryCache.getKeys();\n        if (cacheKeys.length === 0) {\n            try {\n                this.logger.verbose(\n                    \"In-memory cache is empty, now querying persistent storage.\"\n                );\n                return await this.indexedDBCache.getKeys();\n            } catch (e) {\n                this.handleDatabaseAccessError(e);\n            }\n        }\n        return cacheKeys;\n    }\n\n    /**\n     * Returns true or false if the given key is present in the cache.\n     * @param key\n     */\n    async containsKey(key: string): Promise<boolean> {\n        const containsKey = this.inMemoryCache.containsKey(key);\n        if (!containsKey) {\n            try {\n                this.logger.verbose(\n                    \"Key not found in in-memory cache, now querying persistent storage.\"\n                );\n                return await this.indexedDBCache.containsKey(key);\n            } catch (e) {\n                this.handleDatabaseAccessError(e);\n            }\n        }\n        return containsKey;\n    }\n\n    /**\n     * Clears in-memory Map\n     */\n    clearInMemory(): void {\n        // InMemory cache is a Map instance, clear is straightforward\n        this.logger.verbose(`Deleting in-memory keystore ${this.storeName}`);\n        this.inMemoryCache.clear();\n        this.logger.verbose(`In-memory keystore ${this.storeName} deleted`);\n    }\n\n    /**\n     * Tries to delete the IndexedDB database\n     * @returns\n     */\n    async clearPersistent(): Promise<boolean> {\n        try {\n            this.logger.verbose(\"Deleting persistent keystore\");\n            const dbDeleted = await this.indexedDBCache.deleteDatabase();\n            if (dbDeleted) {\n                this.logger.verbose(\"Persistent keystore deleted\");\n            }\n\n            return dbDeleted;\n        } catch (e) {\n            this.handleDatabaseAccessError(e);\n            return false;\n        }\n    }\n}\n"],"mappings":";;;;;;;;AAAA;;;AAGG;AAWH;;;AAGG;MACUA,kBAAkB;EAM3BC,WAAYA,CAAAC,MAAc,EAAEC,SAAiB;IACzC,IAAI,CAACC,aAAa,GAAG,IAAIC,aAAa,EAAK;IAC3C,IAAI,CAACC,cAAc,GAAG,IAAIC,eAAe,EAAK;IAC9C,IAAI,CAACL,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,SAAS,GAAGA,SAAS;;EAGtBK,yBAAyBA,CAACC,KAAc;IAC5C,IACIA,KAAK,YAAYC,gBAAgB,IACjCD,KAAK,CAACE,SAAS,KAAKC,mBAAyC,EAC/D;MACE,IAAI,CAACV,MAAM,CAACO,KAAK,CACb,6IAA6I,CAChJ;IACJ,OAAM;MACH,MAAMA,KAAK;IACd;;EAEL;;;;AAIG;EACH,MAAMI,OAAOA,CAACC,GAAW;IACrB,MAAMC,IAAI,GAAG,IAAI,CAACX,aAAa,CAACS,OAAO,CAACC,GAAG,CAAC;IAC5C,IAAI,CAACC,IAAI,EAAE;MACP,IAAI;QACA,IAAI,CAACb,MAAM,CAACc,OAAO,CACf,6EAA6E,CAChF;QACD,OAAO,MAAM,IAAI,CAACV,cAAc,CAACO,OAAO,CAACC,GAAG,CAAC;MAChD,EAAC,OAAOG,CAAC,EAAE;QACR,IAAI,CAACT,yBAAyB,CAACS,CAAC,CAAC;MACpC;IACJ;IACD,OAAOF,IAAI;;EAGf;;;;;AAKG;EACH,MAAMG,OAAOA,CAACJ,GAAW,EAAEK,KAAQ;IAC/B,IAAI,CAACf,aAAa,CAACc,OAAO,CAACJ,GAAG,EAAEK,KAAK,CAAC;IACtC,IAAI;MACA,MAAM,IAAI,CAACb,cAAc,CAACY,OAAO,CAACJ,GAAG,EAAEK,KAAK,CAAC;IAChD,EAAC,OAAOF,CAAC,EAAE;MACR,IAAI,CAACT,yBAAyB,CAACS,CAAC,CAAC;IACpC;;EAGL;;;AAGG;EACH,MAAMG,UAAUA,CAACN,GAAW;IACxB,IAAI,CAACV,aAAa,CAACgB,UAAU,CAACN,GAAG,CAAC;IAClC,IAAI;MACA,MAAM,IAAI,CAACR,cAAc,CAACc,UAAU,CAACN,GAAG,CAAC;IAC5C,EAAC,OAAOG,CAAC,EAAE;MACR,IAAI,CAACT,yBAAyB,CAACS,CAAC,CAAC;IACpC;;EAGL;;;AAGG;EACH,MAAMI,OAAOA,CAAA;IACT,MAAMC,SAAS,GAAG,IAAI,CAAClB,aAAa,CAACiB,OAAO,EAAE;IAC9C,IAAIC,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;MACxB,IAAI;QACA,IAAI,CAACrB,MAAM,CAACc,OAAO,CACf,4DAA4D,CAC/D;QACD,OAAO,MAAM,IAAI,CAACV,cAAc,CAACe,OAAO,EAAE;MAC7C,EAAC,OAAOJ,CAAC,EAAE;QACR,IAAI,CAACT,yBAAyB,CAACS,CAAC,CAAC;MACpC;IACJ;IACD,OAAOK,SAAS;;EAGpB;;;AAGG;EACH,MAAME,WAAWA,CAACV,GAAW;IACzB,MAAMU,WAAW,GAAG,IAAI,CAACpB,aAAa,CAACoB,WAAW,CAACV,GAAG,CAAC;IACvD,IAAI,CAACU,WAAW,EAAE;MACd,IAAI;QACA,IAAI,CAACtB,MAAM,CAACc,OAAO,CACf,oEAAoE,CACvE;QACD,OAAO,MAAM,IAAI,CAACV,cAAc,CAACkB,WAAW,CAACV,GAAG,CAAC;MACpD,EAAC,OAAOG,CAAC,EAAE;QACR,IAAI,CAACT,yBAAyB,CAACS,CAAC,CAAC;MACpC;IACJ;IACD,OAAOO,WAAW;;EAGtB;;AAEG;EACHC,aAAaA,CAAA;;IAET,IAAI,CAACvB,MAAM,CAACc,OAAO,CAAgC,mCAAI,CAACb,SAAW,GAAC;IACpE,IAAI,CAACC,aAAa,CAACsB,KAAK,EAAE;IAC1B,IAAI,CAACxB,MAAM,CAACc,OAAO,CAAuB,0BAAI,CAACb,SAAmB,WAAC;;EAGvE;;;AAGG;EACH,MAAMwB,eAAeA,CAAA;IACjB,IAAI;MACA,IAAI,CAACzB,MAAM,CAACc,OAAO,CAAC,8BAA8B,CAAC;MACnD,MAAMY,SAAS,GAAG,MAAM,IAAI,CAACtB,cAAc,CAACuB,cAAc,EAAE;MAC5D,IAAID,SAAS,EAAE;QACX,IAAI,CAAC1B,MAAM,CAACc,OAAO,CAAC,6BAA6B,CAAC;MACrD;MAED,OAAOY,SAAS;IACnB,EAAC,OAAOX,CAAC,EAAE;MACR,IAAI,CAACT,yBAAyB,CAACS,CAAC,CAAC;MACjC,OAAO,KAAK;IACf;;AAER"},"metadata":{},"sourceType":"module","externalDependencies":[]}