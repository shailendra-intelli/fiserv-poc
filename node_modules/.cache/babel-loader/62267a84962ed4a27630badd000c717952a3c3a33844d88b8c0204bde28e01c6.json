{"ast":null,"code":"/*! @azure/msal-common v14.4.0 2023-11-07 */\n'use strict';\n\nimport { CacheOutcome, Constants, SERVER_TELEM_CONSTANTS, Separators } from '../../utils/Constants.mjs';\nimport { AuthError } from '../../error/AuthError.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/** @internal */\nclass ServerTelemetryManager {\n  constructor(telemetryRequest, cacheManager) {\n    this.cacheOutcome = CacheOutcome.NOT_APPLICABLE;\n    this.cacheManager = cacheManager;\n    this.apiId = telemetryRequest.apiId;\n    this.correlationId = telemetryRequest.correlationId;\n    this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;\n    this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;\n    this.telemetryCacheKey = SERVER_TELEM_CONSTANTS.CACHE_KEY + Separators.CACHE_KEY_SEPARATOR + telemetryRequest.clientId;\n  }\n  /**\n   * API to add MSER Telemetry to request\n   */\n  generateCurrentRequestHeaderValue() {\n    const request = `${this.apiId}${SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR}${this.cacheOutcome}`;\n    const platformFields = [this.wrapperSKU, this.wrapperVer].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\n    const regionDiscoveryFields = this.getRegionDiscoveryFields();\n    const requestWithRegionDiscoveryFields = [request, regionDiscoveryFields].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\n    return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, requestWithRegionDiscoveryFields, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);\n  }\n  /**\n   * API to add MSER Telemetry for the last failed request\n   */\n  generateLastRequestHeaderValue() {\n    const lastRequests = this.getLastRequests();\n    const maxErrors = ServerTelemetryManager.maxErrorsToSend(lastRequests);\n    const failedRequests = lastRequests.failedRequests.slice(0, 2 * maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\n    const errors = lastRequests.errors.slice(0, maxErrors).join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\n    const errorCount = lastRequests.errors.length;\n    // Indicate whether this header contains all data or partial data\n    const overflow = maxErrors < errorCount ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;\n    const platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\n    return [SERVER_TELEM_CONSTANTS.SCHEMA_VERSION, lastRequests.cacheHits, failedRequests, errors, platformFields].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);\n  }\n  /**\n   * API to cache token failures for MSER data capture\n   * @param error\n   */\n  cacheFailedRequest(error) {\n    const lastRequests = this.getLastRequests();\n    if (lastRequests.errors.length >= SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {\n      // Remove a cached error to make room, first in first out\n      lastRequests.failedRequests.shift(); // apiId\n      lastRequests.failedRequests.shift(); // correlationId\n      lastRequests.errors.shift();\n    }\n    lastRequests.failedRequests.push(this.apiId, this.correlationId);\n    if (error instanceof Error && !!error && error.toString()) {\n      if (error instanceof AuthError) {\n        if (error.subError) {\n          lastRequests.errors.push(error.subError);\n        } else if (error.errorCode) {\n          lastRequests.errors.push(error.errorCode);\n        } else {\n          lastRequests.errors.push(error.toString());\n        }\n      } else {\n        lastRequests.errors.push(error.toString());\n      }\n    } else {\n      lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);\n    }\n    this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);\n    return;\n  }\n  /**\n   * Update server telemetry cache entry by incrementing cache hit counter\n   */\n  incrementCacheHits() {\n    const lastRequests = this.getLastRequests();\n    lastRequests.cacheHits += 1;\n    this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests);\n    return lastRequests.cacheHits;\n  }\n  /**\n   * Get the server telemetry entity from cache or initialize a new one\n   */\n  getLastRequests() {\n    const initialValue = {\n      failedRequests: [],\n      errors: [],\n      cacheHits: 0\n    };\n    const lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);\n    return lastRequests || initialValue;\n  }\n  /**\n   * Remove server telemetry cache entry\n   */\n  clearTelemetryCache() {\n    const lastRequests = this.getLastRequests();\n    const numErrorsFlushed = ServerTelemetryManager.maxErrorsToSend(lastRequests);\n    const errorCount = lastRequests.errors.length;\n    if (numErrorsFlushed === errorCount) {\n      // All errors were sent on last request, clear Telemetry cache\n      this.cacheManager.removeItem(this.telemetryCacheKey);\n    } else {\n      // Partial data was flushed to server, construct a new telemetry cache item with errors that were not flushed\n      const serverTelemEntity = {\n        failedRequests: lastRequests.failedRequests.slice(numErrorsFlushed * 2),\n        errors: lastRequests.errors.slice(numErrorsFlushed),\n        cacheHits: 0\n      };\n      this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity);\n    }\n  }\n  /**\n   * Returns the maximum number of errors that can be flushed to the server in the next network request\n   * @param serverTelemetryEntity\n   */\n  static maxErrorsToSend(serverTelemetryEntity) {\n    let i;\n    let maxErrors = 0;\n    let dataSize = 0;\n    const errorCount = serverTelemetryEntity.errors.length;\n    for (i = 0; i < errorCount; i++) {\n      // failedRequests parameter contains pairs of apiId and correlationId, multiply index by 2 to preserve pairs\n      const apiId = serverTelemetryEntity.failedRequests[2 * i] || Constants.EMPTY_STRING;\n      const correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] || Constants.EMPTY_STRING;\n      const errorCode = serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING;\n      // Count number of characters that would be added to header, each character is 1 byte. Add 3 at the end to account for separators\n      dataSize += apiId.toString().length + correlationId.toString().length + errorCode.length + 3;\n      if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {\n        // Adding this entry to the header would still keep header size below the limit\n        maxErrors += 1;\n      } else {\n        break;\n      }\n    }\n    return maxErrors;\n  }\n  /**\n   * Get the region discovery fields\n   *\n   * @returns string\n   */\n  getRegionDiscoveryFields() {\n    const regionDiscoveryFields = [];\n    regionDiscoveryFields.push(this.regionUsed || Constants.EMPTY_STRING);\n    regionDiscoveryFields.push(this.regionSource || Constants.EMPTY_STRING);\n    regionDiscoveryFields.push(this.regionOutcome || Constants.EMPTY_STRING);\n    return regionDiscoveryFields.join(\",\");\n  }\n  /**\n   * Update the region discovery metadata\n   *\n   * @param regionDiscoveryMetadata\n   * @returns void\n   */\n  updateRegionDiscoveryMetadata(regionDiscoveryMetadata) {\n    this.regionUsed = regionDiscoveryMetadata.region_used;\n    this.regionSource = regionDiscoveryMetadata.region_source;\n    this.regionOutcome = regionDiscoveryMetadata.region_outcome;\n  }\n  /**\n   * Set cache outcome\n   */\n  setCacheOutcome(cacheOutcome) {\n    this.cacheOutcome = cacheOutcome;\n  }\n}\nexport { ServerTelemetryManager };","map":{"version":3,"names":["ServerTelemetryManager","constructor","telemetryRequest","cacheManager","cacheOutcome","CacheOutcome","NOT_APPLICABLE","apiId","correlationId","wrapperSKU","Constants","EMPTY_STRING","wrapperVer","telemetryCacheKey","SERVER_TELEM_CONSTANTS","CACHE_KEY","Separators","CACHE_KEY_SEPARATOR","clientId","request","VALUE_SEPARATOR","platformFields","join","regionDiscoveryFields","getRegionDiscoveryFields","requestWithRegionDiscoveryFields","CATEGORY_SEPARATOR","lastRequests","getLastRequests","maxErrors","maxErrorsToSend","failedRequests","errors","slice","OVERFLOW_TRUE","OVERFLOW_FALSE","errorCount","overflow"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-common\\src\\telemetry\\server\\ServerTelemetryManager.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    SERVER_TELEM_CONSTANTS,\n    Separators,\n    CacheOutcome,\n    Constants,\n    RegionDiscoverySources,\n    RegionDiscoveryOutcomes,\n} from \"../../utils/Constants\";\nimport { CacheManager } from \"../../cache/CacheManager\";\nimport { AuthError } from \"../../error/AuthError\";\nimport { ServerTelemetryRequest } from \"./ServerTelemetryRequest\";\nimport { ServerTelemetryEntity } from \"../../cache/entities/ServerTelemetryEntity\";\nimport { RegionDiscoveryMetadata } from \"../../authority/RegionDiscoveryMetadata\";\n\n/** @internal */\nexport class ServerTelemetryManager {\n    private cacheManager: CacheManager;\n    private apiId: number;\n    private correlationId: string;\n    private telemetryCacheKey: string;\n    private wrapperSKU: String;\n    private wrapperVer: String;\n    private regionUsed: string | undefined;\n    private regionSource: RegionDiscoverySources | undefined;\n    private regionOutcome: RegionDiscoveryOutcomes | undefined;\n    private cacheOutcome: CacheOutcome = CacheOutcome.NOT_APPLICABLE;\n\n    constructor(\n        telemetryRequest: ServerTelemetryRequest,\n        cacheManager: CacheManager\n    ) {\n        this.cacheManager = cacheManager;\n        this.apiId = telemetryRequest.apiId;\n        this.correlationId = telemetryRequest.correlationId;\n        this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;\n        this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;\n\n        this.telemetryCacheKey =\n            SERVER_TELEM_CONSTANTS.CACHE_KEY +\n            Separators.CACHE_KEY_SEPARATOR +\n            telemetryRequest.clientId;\n    }\n\n    /**\n     * API to add MSER Telemetry to request\n     */\n    generateCurrentRequestHeaderValue(): string {\n        const request = `${this.apiId}${SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR}${this.cacheOutcome}`;\n        const platformFields = [this.wrapperSKU, this.wrapperVer].join(\n            SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR\n        );\n        const regionDiscoveryFields = this.getRegionDiscoveryFields();\n        const requestWithRegionDiscoveryFields = [\n            request,\n            regionDiscoveryFields,\n        ].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\n\n        return [\n            SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,\n            requestWithRegionDiscoveryFields,\n            platformFields,\n        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);\n    }\n\n    /**\n     * API to add MSER Telemetry for the last failed request\n     */\n    generateLastRequestHeaderValue(): string {\n        const lastRequests = this.getLastRequests();\n\n        const maxErrors = ServerTelemetryManager.maxErrorsToSend(lastRequests);\n        const failedRequests = lastRequests.failedRequests\n            .slice(0, 2 * maxErrors)\n            .join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\n        const errors = lastRequests.errors\n            .slice(0, maxErrors)\n            .join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);\n        const errorCount = lastRequests.errors.length;\n\n        // Indicate whether this header contains all data or partial data\n        const overflow =\n            maxErrors < errorCount\n                ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE\n                : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;\n        const platformFields = [errorCount, overflow].join(\n            SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR\n        );\n\n        return [\n            SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,\n            lastRequests.cacheHits,\n            failedRequests,\n            errors,\n            platformFields,\n        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);\n    }\n\n    /**\n     * API to cache token failures for MSER data capture\n     * @param error\n     */\n    cacheFailedRequest(error: unknown): void {\n        const lastRequests = this.getLastRequests();\n        if (\n            lastRequests.errors.length >=\n            SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS\n        ) {\n            // Remove a cached error to make room, first in first out\n            lastRequests.failedRequests.shift(); // apiId\n            lastRequests.failedRequests.shift(); // correlationId\n            lastRequests.errors.shift();\n        }\n\n        lastRequests.failedRequests.push(this.apiId, this.correlationId);\n\n        if (error instanceof Error && !!error && error.toString()) {\n            if (error instanceof AuthError) {\n                if (error.subError) {\n                    lastRequests.errors.push(error.subError);\n                } else if (error.errorCode) {\n                    lastRequests.errors.push(error.errorCode);\n                } else {\n                    lastRequests.errors.push(error.toString());\n                }\n            } else {\n                lastRequests.errors.push(error.toString());\n            }\n        } else {\n            lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);\n        }\n\n        this.cacheManager.setServerTelemetry(\n            this.telemetryCacheKey,\n            lastRequests\n        );\n\n        return;\n    }\n\n    /**\n     * Update server telemetry cache entry by incrementing cache hit counter\n     */\n    incrementCacheHits(): number {\n        const lastRequests = this.getLastRequests();\n        lastRequests.cacheHits += 1;\n\n        this.cacheManager.setServerTelemetry(\n            this.telemetryCacheKey,\n            lastRequests\n        );\n        return lastRequests.cacheHits;\n    }\n\n    /**\n     * Get the server telemetry entity from cache or initialize a new one\n     */\n    getLastRequests(): ServerTelemetryEntity {\n        const initialValue: ServerTelemetryEntity = {\n            failedRequests: [],\n            errors: [],\n            cacheHits: 0,\n        };\n        const lastRequests = this.cacheManager.getServerTelemetry(\n            this.telemetryCacheKey\n        ) as ServerTelemetryEntity;\n\n        return lastRequests || initialValue;\n    }\n\n    /**\n     * Remove server telemetry cache entry\n     */\n    clearTelemetryCache(): void {\n        const lastRequests = this.getLastRequests();\n        const numErrorsFlushed =\n            ServerTelemetryManager.maxErrorsToSend(lastRequests);\n        const errorCount = lastRequests.errors.length;\n        if (numErrorsFlushed === errorCount) {\n            // All errors were sent on last request, clear Telemetry cache\n            this.cacheManager.removeItem(this.telemetryCacheKey);\n        } else {\n            // Partial data was flushed to server, construct a new telemetry cache item with errors that were not flushed\n            const serverTelemEntity: ServerTelemetryEntity = {\n                failedRequests: lastRequests.failedRequests.slice(\n                    numErrorsFlushed * 2\n                ), // failedRequests contains 2 items for each error\n                errors: lastRequests.errors.slice(numErrorsFlushed),\n                cacheHits: 0,\n            };\n\n            this.cacheManager.setServerTelemetry(\n                this.telemetryCacheKey,\n                serverTelemEntity\n            );\n        }\n    }\n\n    /**\n     * Returns the maximum number of errors that can be flushed to the server in the next network request\n     * @param serverTelemetryEntity\n     */\n    static maxErrorsToSend(\n        serverTelemetryEntity: ServerTelemetryEntity\n    ): number {\n        let i;\n        let maxErrors = 0;\n        let dataSize = 0;\n        const errorCount = serverTelemetryEntity.errors.length;\n        for (i = 0; i < errorCount; i++) {\n            // failedRequests parameter contains pairs of apiId and correlationId, multiply index by 2 to preserve pairs\n            const apiId =\n                serverTelemetryEntity.failedRequests[2 * i] ||\n                Constants.EMPTY_STRING;\n            const correlationId =\n                serverTelemetryEntity.failedRequests[2 * i + 1] ||\n                Constants.EMPTY_STRING;\n            const errorCode =\n                serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING;\n\n            // Count number of characters that would be added to header, each character is 1 byte. Add 3 at the end to account for separators\n            dataSize +=\n                apiId.toString().length +\n                correlationId.toString().length +\n                errorCode.length +\n                3;\n\n            if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {\n                // Adding this entry to the header would still keep header size below the limit\n                maxErrors += 1;\n            } else {\n                break;\n            }\n        }\n\n        return maxErrors;\n    }\n\n    /**\n     * Get the region discovery fields\n     *\n     * @returns string\n     */\n    getRegionDiscoveryFields(): string {\n        const regionDiscoveryFields: string[] = [];\n\n        regionDiscoveryFields.push(this.regionUsed || Constants.EMPTY_STRING);\n        regionDiscoveryFields.push(this.regionSource || Constants.EMPTY_STRING);\n        regionDiscoveryFields.push(\n            this.regionOutcome || Constants.EMPTY_STRING\n        );\n\n        return regionDiscoveryFields.join(\",\");\n    }\n\n    /**\n     * Update the region discovery metadata\n     *\n     * @param regionDiscoveryMetadata\n     * @returns void\n     */\n    updateRegionDiscoveryMetadata(\n        regionDiscoveryMetadata: RegionDiscoveryMetadata\n    ): void {\n        this.regionUsed = regionDiscoveryMetadata.region_used;\n        this.regionSource = regionDiscoveryMetadata.region_source;\n        this.regionOutcome = regionDiscoveryMetadata.region_outcome;\n    }\n\n    /**\n     * Set cache outcome\n     */\n    setCacheOutcome(cacheOutcome: CacheOutcome): void {\n        this.cacheOutcome = cacheOutcome;\n    }\n}\n"],"mappings":";;;;;;AAKA;AAQA;AAEA;AACA;AAIA;AACW,MAAAA,sBAA4B;EACnCC,YAAAC,gBAAsB,EAAAC,YAAA;IACf,IAAC,CAAAC,YAAa,GAASC,YAAA,CAAAC,cAAA;IACvB,IAAC,CAAAH,YAAA,GAAAA,YAA0B;IAC3B,IAAC,CAAAI,KAAA,GAAAL,gBAAmB,CAAAK,KAAA;IACpB,IAAC,CAAAC,aAAmB,GAAAN,gBAAA,CAAAM,aAAA;IACpB,IAAC,CAAAC,UAA+B,GAAAP,gBAAA,CAAAO,UAAA,IAAAC,SAAA,CAAAC,YAAA;IAChC,IAAC,CAAAC,UAAA,GAAiDV,gBAAA,CAAAU,UAAA,IAAAF,SAAA,CAAAC,YAAA;IAClD,IAAC,CAAAE,iBAAmD,GACnDC,sBAAyD,CAAAC,SAAA,GAG7DC,UAAA,CAAAC,mBAAkB,GAetBf,gBAAA,CAAAgB,QAAA;;EAEG;AACH;AAkBA;;IAEG,MAAAC,OAAA,WAAAZ,KAAA,GAAAO,sBAAA,CAAAM,eAAA,QAAAhB,YAAA;IACH,MAAAiB,cAAA,SAAAZ,UAAwC,OAAAG,UAAA,EAAAU,IAAA,CAAAR,sBAAA,CAAAM,eAAA;IA8BxC,MAAAG,qBAAA,QAAAC,wBAAA;uDAGGD,qBAAA,CACH,CAAAD,IAAA,CAAAR,sBAAiC,CAAAM,eAAO;IAsCxC,Q,uCAEGK,gCAAA,EACHJ,cAAsB,CAWtB,CAAAC,IAAA,CAAAR,sBAAA,CAAAY,kBAAA;;EAEG;AACH;AAaA;;IAEG,MAAAC,YAAA,QAAAC,eAAA;IACH,MAAAC,SAAmB,GAAA7B,sBAAQ,CAAA8B,eAAA,CAAAH,YAAA;IAyB3B,MAAAI,cAAA,GAAAJ,YAAA,CAAAI,cAAA,C;IAGG,MAAAC,MAAA,GAAAL,YAAA,CAAAK,MAAA,CACmBC,KAAA,IAAAJ,SAAA,EAoCtBP,IAAA,CAAAR,sBAAA,CAAAM,eAAA;;;8CAIGN,sBAAA,CAAAoB,aAAA,GACHpB,sBAAkC,CAAAqB,cAAA;IAYlC,MAAAd,cAAA,IAAAe,UAAA,EAAAC,QAAA,EAAAf,IAAA,CAAAR,sBAAA,CAAAM,eAAA;2FAKGY,MAAA,EACHX,cAAA,CAQA,CAAAC,IAAA,CAAAR,sBAAA,CAAAY,kBAAA;;EAEG;AACH;AAGH"},"metadata":{},"sourceType":"module","externalDependencies":[]}