{"ast":null,"code":"/*! @azure/msal-browser v3.5.0 2023-11-07 */\n'use strict';\n\nimport { PerformanceEvents, ServerError, invokeAsync, CcsCredentialType } from '@azure/msal-common';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { userCancelled } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Abstract class which defines operations for a browser interaction handling class.\n */\nclass InteractionHandler {\n  constructor(authCodeModule, storageImpl, authCodeRequest, logger, performanceClient) {\n    this.authModule = authCodeModule;\n    this.browserStorage = storageImpl;\n    this.authCodeRequest = authCodeRequest;\n    this.logger = logger;\n    this.performanceClient = performanceClient;\n  }\n  /**\n   * Function to handle response parameters from hash.\n   * @param locationHash\n   */\n  async handleCodeResponse(response, request) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponse, request.correlationId);\n    let authCodeResponse;\n    try {\n      authCodeResponse = this.authModule.handleFragmentResponse(response, request.state);\n    } catch (e) {\n      if (e instanceof ServerError && e.subError === userCancelled) {\n        // Translate server error caused by user closing native prompt to corresponding first class MSAL error\n        throw createBrowserAuthError(userCancelled);\n      } else {\n        throw e;\n      }\n    }\n    return invokeAsync(this.handleCodeResponseFromServer.bind(this), PerformanceEvents.HandleCodeResponseFromServer, this.logger, this.performanceClient, request.correlationId)(authCodeResponse, request);\n  }\n  /**\n   * Process auth code response from AAD\n   * @param authCodeResponse\n   * @param state\n   * @param authority\n   * @param networkModule\n   * @returns\n   */\n  async handleCodeResponseFromServer(authCodeResponse, request, validateNonce = true) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponseFromServer, request.correlationId);\n    this.logger.trace(\"InteractionHandler.handleCodeResponseFromServer called\");\n    // Assign code to request\n    this.authCodeRequest.code = authCodeResponse.code;\n    // Check for new cloud instance\n    if (authCodeResponse.cloud_instance_host_name) {\n      await invokeAsync(this.authModule.updateAuthority.bind(this.authModule), PerformanceEvents.UpdateTokenEndpointAuthority, this.logger, this.performanceClient, request.correlationId)(authCodeResponse.cloud_instance_host_name, request.correlationId);\n    }\n    // Nonce validation not needed when redirect not involved (e.g. hybrid spa, renewing token via rt)\n    if (validateNonce) {\n      // TODO: Assigning \"response nonce\" to \"request nonce\" is confusing. Refactor the function doing validation to accept request nonce directly\n      authCodeResponse.nonce = request.nonce || undefined;\n    }\n    authCodeResponse.state = request.state;\n    // Add CCS parameters if available\n    if (authCodeResponse.client_info) {\n      this.authCodeRequest.clientInfo = authCodeResponse.client_info;\n    } else {\n      const ccsCred = this.createCcsCredentials(request);\n      if (ccsCred) {\n        this.authCodeRequest.ccsCredential = ccsCred;\n      }\n    }\n    // Acquire token with retrieved code.\n    const tokenResponse = await invokeAsync(this.authModule.acquireToken.bind(this.authModule), PerformanceEvents.AuthClientAcquireToken, this.logger, this.performanceClient, request.correlationId)(this.authCodeRequest, authCodeResponse);\n    return tokenResponse;\n  }\n  /**\n   * Build ccs creds if available\n   */\n  createCcsCredentials(request) {\n    if (request.account) {\n      return {\n        credential: request.account.homeAccountId,\n        type: CcsCredentialType.HOME_ACCOUNT_ID\n      };\n    } else if (request.loginHint) {\n      return {\n        credential: request.loginHint,\n        type: CcsCredentialType.UPN\n      };\n    }\n    return null;\n  }\n}\nexport { InteractionHandler };","map":{"version":3,"names":["InteractionHandler","constructor","authCodeModule","storageImpl","authCodeRequest","logger","performanceClient","authModule","browserStorage","e","ServerError","userCancelled"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\interaction_handler\\InteractionHandler.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AuthorizationCodePayload,\n    CommonAuthorizationCodeRequest,\n    AuthorizationCodeClient,\n    CcsCredential,\n    Logger,\n    ServerError,\n    IPerformanceClient,\n    PerformanceEvents,\n    invokeAsync,\n    CcsCredentialType,\n    ServerAuthorizationCodeResponse,\n} from \"@azure/msal-common\";\n\nimport { BrowserCacheManager } from \"../cache/BrowserCacheManager\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\nimport { AuthorizationUrlRequest } from \"../request/AuthorizationUrlRequest\";\n\n/**\n * Abstract class which defines operations for a browser interaction handling class.\n */\nexport class InteractionHandler {\n    protected authModule: AuthorizationCodeClient;\n    protected browserStorage: BrowserCacheManager;\n    protected authCodeRequest: CommonAuthorizationCodeRequest;\n    protected logger: Logger;\n    protected performanceClient: IPerformanceClient;\n\n    constructor(\n        authCodeModule: AuthorizationCodeClient,\n        storageImpl: BrowserCacheManager,\n        authCodeRequest: CommonAuthorizationCodeRequest,\n        logger: Logger,\n        performanceClient: IPerformanceClient\n    ) {\n        this.authModule = authCodeModule;\n        this.browserStorage = storageImpl;\n        this.authCodeRequest = authCodeRequest;\n        this.logger = logger;\n        this.performanceClient = performanceClient;\n    }\n\n    /**\n     * Function to handle response parameters from hash.\n     * @param locationHash\n     */\n    async handleCodeResponse(\n        response: ServerAuthorizationCodeResponse,\n        request: AuthorizationUrlRequest\n    ): Promise<AuthenticationResult> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.HandleCodeResponse,\n            request.correlationId\n        );\n\n        let authCodeResponse;\n        try {\n            authCodeResponse = this.authModule.handleFragmentResponse(\n                response,\n                request.state\n            );\n        } catch (e) {\n            if (\n                e instanceof ServerError &&\n                e.subError === BrowserAuthErrorCodes.userCancelled\n            ) {\n                // Translate server error caused by user closing native prompt to corresponding first class MSAL error\n                throw createBrowserAuthError(\n                    BrowserAuthErrorCodes.userCancelled\n                );\n            } else {\n                throw e;\n            }\n        }\n\n        return invokeAsync(\n            this.handleCodeResponseFromServer.bind(this),\n            PerformanceEvents.HandleCodeResponseFromServer,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(authCodeResponse, request);\n    }\n\n    /**\n     * Process auth code response from AAD\n     * @param authCodeResponse\n     * @param state\n     * @param authority\n     * @param networkModule\n     * @returns\n     */\n    async handleCodeResponseFromServer(\n        authCodeResponse: AuthorizationCodePayload,\n        request: AuthorizationUrlRequest,\n        validateNonce: boolean = true\n    ): Promise<AuthenticationResult> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.HandleCodeResponseFromServer,\n            request.correlationId\n        );\n        this.logger.trace(\n            \"InteractionHandler.handleCodeResponseFromServer called\"\n        );\n\n        // Assign code to request\n        this.authCodeRequest.code = authCodeResponse.code;\n\n        // Check for new cloud instance\n        if (authCodeResponse.cloud_instance_host_name) {\n            await invokeAsync(\n                this.authModule.updateAuthority.bind(this.authModule),\n                PerformanceEvents.UpdateTokenEndpointAuthority,\n                this.logger,\n                this.performanceClient,\n                request.correlationId\n            )(authCodeResponse.cloud_instance_host_name, request.correlationId);\n        }\n\n        // Nonce validation not needed when redirect not involved (e.g. hybrid spa, renewing token via rt)\n        if (validateNonce) {\n            // TODO: Assigning \"response nonce\" to \"request nonce\" is confusing. Refactor the function doing validation to accept request nonce directly\n            authCodeResponse.nonce = request.nonce || undefined;\n        }\n\n        authCodeResponse.state = request.state;\n\n        // Add CCS parameters if available\n        if (authCodeResponse.client_info) {\n            this.authCodeRequest.clientInfo = authCodeResponse.client_info;\n        } else {\n            const ccsCred = this.createCcsCredentials(request);\n            if (ccsCred) {\n                this.authCodeRequest.ccsCredential = ccsCred;\n            }\n        }\n\n        // Acquire token with retrieved code.\n        const tokenResponse = (await invokeAsync(\n            this.authModule.acquireToken.bind(this.authModule),\n            PerformanceEvents.AuthClientAcquireToken,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(this.authCodeRequest, authCodeResponse)) as AuthenticationResult;\n        return tokenResponse;\n    }\n\n    /**\n     * Build ccs creds if available\n     */\n    protected createCcsCredentials(\n        request: AuthorizationUrlRequest\n    ): CcsCredential | null {\n        if (request.account) {\n            return {\n                credential: request.account.homeAccountId,\n                type: CcsCredentialType.HOME_ACCOUNT_ID,\n            };\n        } else if (request.loginHint) {\n            return {\n                credential: request.loginHint,\n                type: CcsCredentialType.UPN,\n            };\n        }\n\n        return null;\n    }\n}\n"],"mappings":";;;;;;;AAKA;AAcA;AAKA;AACA;AAIG;AACH;AACI;AACA,MAASA,kBAAiB;EAC1BC,WAAUA,CAAAC,cAAiB,EAAAC,WAAA,EAAAC,eAAA,EAA+BC,MAAA,EAAAC,iBAAA;IAC1D,KAASC,UAAS,GAAAL,cAAO;IACzB,KAASM,cAAC,GAAAL,WAAmB;IAGzB,KAAAC,eAAA,GAAAA,eAAuC;IAa3C,KAAAC,MAAA,GAAAA,MAAA;;;EAGG;AACG;AAsCN;;;;;;;IAOG,EACG,OAAAI,CAAA;MAwDN,IAAAA,CAAA,YAAAC,WAAA,I;QAEG;oCAEU,CAAuBC,aACpB;MAenB,O"},"metadata":{},"sourceType":"module","externalDependencies":[]}