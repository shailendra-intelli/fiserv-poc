{"ast":null,"code":"/*! @azure/msal-common v14.0.3 2023-09-05 */\n'use strict';\n\nimport { AuthError } from './AuthError.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * ClientAuthErrorMessage class containing string constants used by error codes and messages.\n */\nconst ClientAuthErrorMessage = {\n  clientInfoDecodingError: {\n    code: \"client_info_decoding_error\",\n    desc: \"The client info could not be parsed/decoded correctly. Please review the trace to determine the root cause.\"\n  },\n  clientInfoEmptyError: {\n    code: \"client_info_empty_error\",\n    desc: \"The client info was empty. Please review the trace to determine the root cause.\"\n  },\n  tokenParsingError: {\n    code: \"token_parsing_error\",\n    desc: \"Token cannot be parsed. Please review stack trace to determine root cause.\"\n  },\n  nullOrEmptyToken: {\n    code: \"null_or_empty_token\",\n    desc: \"The token is null or empty. Please review the trace to determine the root cause.\"\n  },\n  endpointResolutionError: {\n    code: \"endpoints_resolution_error\",\n    desc: \"Error: could not resolve endpoints. Please check network and try again.\"\n  },\n  networkError: {\n    code: \"network_error\",\n    desc: \"Network request failed. Please check network trace to determine root cause.\"\n  },\n  unableToGetOpenidConfigError: {\n    code: \"openid_config_error\",\n    desc: \"Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints.\"\n  },\n  hashNotDeserialized: {\n    code: \"hash_not_deserialized\",\n    desc: \"The hash parameters could not be deserialized. Please review the trace to determine the root cause.\"\n  },\n  blankGuidGenerated: {\n    code: \"blank_guid_generated\",\n    desc: \"The guid generated was blank. Please review the trace to determine the root cause.\"\n  },\n  invalidStateError: {\n    code: \"invalid_state\",\n    desc: \"State was not the expected format. Please check the logs to determine whether the request was sent using ProtocolUtils.setRequestState().\"\n  },\n  stateMismatchError: {\n    code: \"state_mismatch\",\n    desc: \"State mismatch error. Please check your network. Continued requests may cause cache overflow.\"\n  },\n  stateNotFoundError: {\n    code: \"state_not_found\",\n    desc: \"State not found\"\n  },\n  nonceMismatchError: {\n    code: \"nonce_mismatch\",\n    desc: \"Nonce mismatch error. This may be caused by a race condition in concurrent requests.\"\n  },\n  nonceNotFoundError: {\n    code: \"nonce_not_found\",\n    desc: \"nonce not found\"\n  },\n  authTimeNotFoundError: {\n    code: \"auth_time_not_found\",\n    desc: \"Max Age was requested and the ID token is missing the auth_time variable.\" + \" auth_time is an optional claim and is not enabled by default - it must be enabled.\" + \" See https://aka.ms/msaljs/optional-claims for more information.\"\n  },\n  maxAgeTranspiredError: {\n    code: \"max_age_transpired\",\n    desc: \"Max Age is set to 0, or too much time has elapsed since the last end-user authentication.\"\n  },\n  noTokensFoundError: {\n    code: \"no_tokens_found\",\n    desc: \"No tokens were found for the given scopes, and no authorization code was passed to acquireToken. You must retrieve an authorization code before making a call to acquireToken().\"\n  },\n  multipleMatchingTokens: {\n    code: \"multiple_matching_tokens\",\n    desc: \"The cache contains multiple tokens satisfying the requirements. \" + \"Call AcquireToken again providing more requirements such as authority or account.\"\n  },\n  multipleMatchingAccounts: {\n    code: \"multiple_matching_accounts\",\n    desc: \"The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account\"\n  },\n  multipleMatchingAppMetadata: {\n    code: \"multiple_matching_appMetadata\",\n    desc: \"The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata\"\n  },\n  tokenRequestCannotBeMade: {\n    code: \"request_cannot_be_made\",\n    desc: \"Token request cannot be made without authorization code or refresh token.\"\n  },\n  appendEmptyScopeError: {\n    code: \"cannot_append_empty_scope\",\n    desc: \"Cannot append null or empty scope to ScopeSet. Please check the stack trace for more info.\"\n  },\n  removeEmptyScopeError: {\n    code: \"cannot_remove_empty_scope\",\n    desc: \"Cannot remove null or empty scope from ScopeSet. Please check the stack trace for more info.\"\n  },\n  appendScopeSetError: {\n    code: \"cannot_append_scopeset\",\n    desc: \"Cannot append ScopeSet due to error.\"\n  },\n  emptyInputScopeSetError: {\n    code: \"empty_input_scopeset\",\n    desc: \"Empty input ScopeSet cannot be processed.\"\n  },\n  DeviceCodePollingCancelled: {\n    code: \"device_code_polling_cancelled\",\n    desc: \"Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true.\"\n  },\n  DeviceCodeExpired: {\n    code: \"device_code_expired\",\n    desc: \"Device code is expired.\"\n  },\n  DeviceCodeUnknownError: {\n    code: \"device_code_unknown_error\",\n    desc: \"Device code stopped polling for unknown reasons.\"\n  },\n  NoAccountInSilentRequest: {\n    code: \"no_account_in_silent_request\",\n    desc: \"Please pass an account object, silent flow is not supported without account information\"\n  },\n  invalidCacheRecord: {\n    code: \"invalid_cache_record\",\n    desc: \"Cache record object was null or undefined.\"\n  },\n  invalidCacheEnvironment: {\n    code: \"invalid_cache_environment\",\n    desc: \"Invalid environment when attempting to create cache entry\"\n  },\n  noAccountFound: {\n    code: \"no_account_found\",\n    desc: \"No account found in cache for given key.\"\n  },\n  CachePluginError: {\n    code: \"no cache plugin set on CacheManager\",\n    desc: \"ICachePlugin needs to be set before using readFromStorage or writeFromStorage\"\n  },\n  noCryptoObj: {\n    code: \"no_crypto_object\",\n    desc: \"No crypto object detected. This is required for the following operation: \"\n  },\n  invalidCacheType: {\n    code: \"invalid_cache_type\",\n    desc: \"Invalid cache type\"\n  },\n  unexpectedAccountType: {\n    code: \"unexpected_account_type\",\n    desc: \"Unexpected account type.\"\n  },\n  unexpectedCredentialType: {\n    code: \"unexpected_credential_type\",\n    desc: \"Unexpected credential type.\"\n  },\n  invalidAssertion: {\n    code: \"invalid_assertion\",\n    desc: \"Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515\"\n  },\n  invalidClientCredential: {\n    code: \"invalid_client_credential\",\n    desc: \"Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential\"\n  },\n  tokenRefreshRequired: {\n    code: \"token_refresh_required\",\n    desc: \"Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired.\"\n  },\n  userTimeoutReached: {\n    code: \"user_timeout_reached\",\n    desc: \"User defined timeout for device code polling reached\"\n  },\n  tokenClaimsRequired: {\n    code: \"token_claims_cnf_required_for_signedjwt\",\n    desc: \"Cannot generate a POP jwt if the token_claims are not populated\"\n  },\n  noAuthorizationCodeFromServer: {\n    code: \"authorization_code_missing_from_server_response\",\n    desc: \"Server response does not contain an authorization code to proceed\"\n  },\n  noAzureRegionDetected: {\n    code: \"no_azure_region_detected\",\n    desc: \"No azure region was detected and no fallback was made available\"\n  },\n  accessTokenEntityNullError: {\n    code: \"access_token_entity_null\",\n    desc: \"Access token entity is null, please check logs and cache to ensure a valid access token is present.\"\n  },\n  bindingKeyNotRemovedError: {\n    code: \"binding_key_not_removed\",\n    desc: \"Could not remove the credential's binding key from storage.\"\n  },\n  logoutNotSupported: {\n    code: \"end_session_endpoint_not_supported\",\n    desc: \"Provided authority does not support logout.\"\n  },\n  keyIdMissing: {\n    code: \"key_id_missing\",\n    desc: \"A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key.\"\n  },\n  noNetworkConnectivity: {\n    code: \"no_network_connectivity\",\n    desc: \"No network connectivity. Check your internet connection.\"\n  },\n  userCanceledError: {\n    code: \"user_canceled\",\n    desc: \"User canceled the flow.\"\n  },\n  missingTenantIdError: {\n    code: \"missing_tenant_id_error\",\n    desc: \"A tenant id - not common, organizations, or consumers - must be specified when using the client_credentials flow.\"\n  }\n};\n/**\n * Error thrown when there is an error in the client code running on the browser.\n */\nclass ClientAuthError extends AuthError {\n  constructor(errorCode, errorMessage) {\n    super(errorCode, errorMessage);\n    this.name = \"ClientAuthError\";\n    Object.setPrototypeOf(this, ClientAuthError.prototype);\n  }\n  /**\n   * Creates an error thrown when client info object doesn't decode correctly.\n   * @param caughtError\n   */\n  static createClientInfoDecodingError(caughtError) {\n    return new ClientAuthError(ClientAuthErrorMessage.clientInfoDecodingError.code, `${ClientAuthErrorMessage.clientInfoDecodingError.desc} Failed with error: ${caughtError}`);\n  }\n  /**\n   * Creates an error thrown if the client info is empty.\n   * @param rawClientInfo\n   */\n  static createClientInfoEmptyError() {\n    return new ClientAuthError(ClientAuthErrorMessage.clientInfoEmptyError.code, `${ClientAuthErrorMessage.clientInfoEmptyError.desc}`);\n  }\n  /**\n   * Creates an error thrown when the id token extraction errors out.\n   * @param err\n   */\n  static createTokenParsingError(caughtExtractionError) {\n    return new ClientAuthError(ClientAuthErrorMessage.tokenParsingError.code, `${ClientAuthErrorMessage.tokenParsingError.desc} Failed with error: ${caughtExtractionError}`);\n  }\n  /**\n   * Creates an error thrown when the id token string is null or empty.\n   * @param invalidRawTokenString\n   */\n  static createTokenNullOrEmptyError(invalidRawTokenString) {\n    return new ClientAuthError(ClientAuthErrorMessage.nullOrEmptyToken.code, `${ClientAuthErrorMessage.nullOrEmptyToken.desc} Raw Token Value: ${invalidRawTokenString}`);\n  }\n  /**\n   * Creates an error thrown when the endpoint discovery doesn't complete correctly.\n   */\n  static createEndpointDiscoveryIncompleteError(errDetail) {\n    return new ClientAuthError(ClientAuthErrorMessage.endpointResolutionError.code, `${ClientAuthErrorMessage.endpointResolutionError.desc} Detail: ${errDetail}`);\n  }\n  /**\n   * Creates an error thrown when the fetch client throws\n   */\n  static createNetworkError(endpoint, errDetail) {\n    return new ClientAuthError(ClientAuthErrorMessage.networkError.code, `${ClientAuthErrorMessage.networkError.desc} | Fetch client threw: ${errDetail} | Attempted to reach: ${endpoint.split(\"?\")[0]}`);\n  }\n  /**\n   * Creates an error thrown when the openid-configuration endpoint cannot be reached or does not contain the required data\n   */\n  static createUnableToGetOpenidConfigError(errDetail) {\n    return new ClientAuthError(ClientAuthErrorMessage.unableToGetOpenidConfigError.code, `${ClientAuthErrorMessage.unableToGetOpenidConfigError.desc} Attempted to retrieve endpoints from: ${errDetail}`);\n  }\n  /**\n   * Creates an error thrown when the hash cannot be deserialized.\n   * @param hashParamObj\n   */\n  static createHashNotDeserializedError(hashParamObj) {\n    return new ClientAuthError(ClientAuthErrorMessage.hashNotDeserialized.code, `${ClientAuthErrorMessage.hashNotDeserialized.desc} Given Object: ${hashParamObj}`);\n  }\n  /**\n   * Creates an error thrown when the state cannot be parsed.\n   * @param invalidState\n   */\n  static createInvalidStateError(invalidState, errorString) {\n    return new ClientAuthError(ClientAuthErrorMessage.invalidStateError.code, `${ClientAuthErrorMessage.invalidStateError.desc} Invalid State: ${invalidState}, Root Err: ${errorString}`);\n  }\n  /**\n   * Creates an error thrown when two states do not match.\n   */\n  static createStateMismatchError() {\n    return new ClientAuthError(ClientAuthErrorMessage.stateMismatchError.code, ClientAuthErrorMessage.stateMismatchError.desc);\n  }\n  /**\n   * Creates an error thrown when the state is not present\n   * @param missingState\n   */\n  static createStateNotFoundError(missingState) {\n    return new ClientAuthError(ClientAuthErrorMessage.stateNotFoundError.code, `${ClientAuthErrorMessage.stateNotFoundError.desc}:  ${missingState}`);\n  }\n  /**\n   * Creates an error thrown when the nonce does not match.\n   */\n  static createNonceMismatchError() {\n    return new ClientAuthError(ClientAuthErrorMessage.nonceMismatchError.code, ClientAuthErrorMessage.nonceMismatchError.desc);\n  }\n  /**\n   * Creates an error thrown when max_age was provided in the request, but auth_time is not in the token claims\n   * @param missingNonce\n   */\n  static createAuthTimeNotFoundError() {\n    return new ClientAuthError(ClientAuthErrorMessage.authTimeNotFoundError.code, ClientAuthErrorMessage.authTimeNotFoundError.desc);\n  }\n  /**\n   * Creates an error thrown when too much time has elapsed since the last end-user authentication\n   */\n  static createMaxAgeTranspiredError() {\n    return new ClientAuthError(ClientAuthErrorMessage.maxAgeTranspiredError.code, ClientAuthErrorMessage.maxAgeTranspiredError.desc);\n  }\n  /**\n   * Creates an error thrown when the mnonce is not present\n   * @param missingNonce\n   */\n  static createNonceNotFoundError(missingNonce) {\n    return new ClientAuthError(ClientAuthErrorMessage.nonceNotFoundError.code, `${ClientAuthErrorMessage.nonceNotFoundError.desc}:  ${missingNonce}`);\n  }\n  /**\n   * Throws error when multiple tokens are in cache.\n   */\n  static createMultipleMatchingTokensInCacheError() {\n    return new ClientAuthError(ClientAuthErrorMessage.multipleMatchingTokens.code, `${ClientAuthErrorMessage.multipleMatchingTokens.desc}.`);\n  }\n  /**\n   * Throws error when multiple accounts are in cache for the given params\n   */\n  static createMultipleMatchingAccountsInCacheError() {\n    return new ClientAuthError(ClientAuthErrorMessage.multipleMatchingAccounts.code, ClientAuthErrorMessage.multipleMatchingAccounts.desc);\n  }\n  /**\n   * Throws error when multiple appMetada are in cache for the given clientId.\n   */\n  static createMultipleMatchingAppMetadataInCacheError() {\n    return new ClientAuthError(ClientAuthErrorMessage.multipleMatchingAppMetadata.code, ClientAuthErrorMessage.multipleMatchingAppMetadata.desc);\n  }\n  /**\n   * Throws error when no auth code or refresh token is given to ServerTokenRequestParameters.\n   */\n  static createTokenRequestCannotBeMadeError() {\n    return new ClientAuthError(ClientAuthErrorMessage.tokenRequestCannotBeMade.code, ClientAuthErrorMessage.tokenRequestCannotBeMade.desc);\n  }\n  /**\n   * Throws error when attempting to append a null, undefined or empty scope to a set\n   * @param givenScope\n   */\n  static createAppendEmptyScopeToSetError(givenScope) {\n    return new ClientAuthError(ClientAuthErrorMessage.appendEmptyScopeError.code, `${ClientAuthErrorMessage.appendEmptyScopeError.desc} Given Scope: ${givenScope}`);\n  }\n  /**\n   * Throws error when attempting to append a null, undefined or empty scope to a set\n   * @param givenScope\n   */\n  static createRemoveEmptyScopeFromSetError(givenScope) {\n    return new ClientAuthError(ClientAuthErrorMessage.removeEmptyScopeError.code, `${ClientAuthErrorMessage.removeEmptyScopeError.desc} Given Scope: ${givenScope}`);\n  }\n  /**\n   * Throws error when attempting to append null or empty ScopeSet.\n   * @param appendError\n   */\n  static createAppendScopeSetError(appendError) {\n    return new ClientAuthError(ClientAuthErrorMessage.appendScopeSetError.code, `${ClientAuthErrorMessage.appendScopeSetError.desc} Detail Error: ${appendError}`);\n  }\n  /**\n   * Throws error if ScopeSet is null or undefined.\n   * @param givenScopeSet\n   */\n  static createEmptyInputScopeSetError() {\n    return new ClientAuthError(ClientAuthErrorMessage.emptyInputScopeSetError.code, `${ClientAuthErrorMessage.emptyInputScopeSetError.desc}`);\n  }\n  /**\n   * Throws error if user sets CancellationToken.cancel = true during polling of token endpoint during device code flow\n   */\n  static createDeviceCodeCancelledError() {\n    return new ClientAuthError(ClientAuthErrorMessage.DeviceCodePollingCancelled.code, `${ClientAuthErrorMessage.DeviceCodePollingCancelled.desc}`);\n  }\n  /**\n   * Throws error if device code is expired\n   */\n  static createDeviceCodeExpiredError() {\n    return new ClientAuthError(ClientAuthErrorMessage.DeviceCodeExpired.code, `${ClientAuthErrorMessage.DeviceCodeExpired.desc}`);\n  }\n  /**\n   * Throws error if device code is expired\n   */\n  static createDeviceCodeUnknownError() {\n    return new ClientAuthError(ClientAuthErrorMessage.DeviceCodeUnknownError.code, `${ClientAuthErrorMessage.DeviceCodeUnknownError.desc}`);\n  }\n  /**\n   * Throws error when silent requests are made without an account object\n   */\n  static createNoAccountInSilentRequestError() {\n    return new ClientAuthError(ClientAuthErrorMessage.NoAccountInSilentRequest.code, `${ClientAuthErrorMessage.NoAccountInSilentRequest.desc}`);\n  }\n  /**\n   * Throws error when cache record is null or undefined.\n   */\n  static createNullOrUndefinedCacheRecord() {\n    return new ClientAuthError(ClientAuthErrorMessage.invalidCacheRecord.code, ClientAuthErrorMessage.invalidCacheRecord.desc);\n  }\n  /**\n   * Throws error when provided environment is not part of the CloudDiscoveryMetadata object\n   */\n  static createInvalidCacheEnvironmentError() {\n    return new ClientAuthError(ClientAuthErrorMessage.invalidCacheEnvironment.code, ClientAuthErrorMessage.invalidCacheEnvironment.desc);\n  }\n  /**\n   * Throws error when account is not found in cache.\n   */\n  static createNoAccountFoundError() {\n    return new ClientAuthError(ClientAuthErrorMessage.noAccountFound.code, ClientAuthErrorMessage.noAccountFound.desc);\n  }\n  /**\n   * Throws error if ICachePlugin not set on CacheManager.\n   */\n  static createCachePluginError() {\n    return new ClientAuthError(ClientAuthErrorMessage.CachePluginError.code, `${ClientAuthErrorMessage.CachePluginError.desc}`);\n  }\n  /**\n   * Throws error if crypto object not found.\n   * @param operationName\n   */\n  static createNoCryptoObjectError(operationName) {\n    return new ClientAuthError(ClientAuthErrorMessage.noCryptoObj.code, `${ClientAuthErrorMessage.noCryptoObj.desc}${operationName}`);\n  }\n  /**\n   * Throws error if cache type is invalid.\n   */\n  static createInvalidCacheTypeError() {\n    return new ClientAuthError(ClientAuthErrorMessage.invalidCacheType.code, `${ClientAuthErrorMessage.invalidCacheType.desc}`);\n  }\n  /**\n   * Throws error if unexpected account type.\n   */\n  static createUnexpectedAccountTypeError() {\n    return new ClientAuthError(ClientAuthErrorMessage.unexpectedAccountType.code, `${ClientAuthErrorMessage.unexpectedAccountType.desc}`);\n  }\n  /**\n   * Throws error if unexpected credential type.\n   */\n  static createUnexpectedCredentialTypeError() {\n    return new ClientAuthError(ClientAuthErrorMessage.unexpectedCredentialType.code, `${ClientAuthErrorMessage.unexpectedCredentialType.desc}`);\n  }\n  /**\n   * Throws error if client assertion is not valid.\n   */\n  static createInvalidAssertionError() {\n    return new ClientAuthError(ClientAuthErrorMessage.invalidAssertion.code, `${ClientAuthErrorMessage.invalidAssertion.desc}`);\n  }\n  /**\n   * Throws error if client assertion is not valid.\n   */\n  static createInvalidCredentialError() {\n    return new ClientAuthError(ClientAuthErrorMessage.invalidClientCredential.code, `${ClientAuthErrorMessage.invalidClientCredential.desc}`);\n  }\n  /**\n   * Throws error if token cannot be retrieved from cache due to refresh being required.\n   */\n  static createRefreshRequiredError() {\n    return new ClientAuthError(ClientAuthErrorMessage.tokenRefreshRequired.code, ClientAuthErrorMessage.tokenRefreshRequired.desc);\n  }\n  /**\n   * Throws error if the user defined timeout is reached.\n   */\n  static createUserTimeoutReachedError() {\n    return new ClientAuthError(ClientAuthErrorMessage.userTimeoutReached.code, ClientAuthErrorMessage.userTimeoutReached.desc);\n  }\n  /*\n   * Throws error if token claims are not populated for a signed jwt generation\n   */\n  static createTokenClaimsRequiredError() {\n    return new ClientAuthError(ClientAuthErrorMessage.tokenClaimsRequired.code, ClientAuthErrorMessage.tokenClaimsRequired.desc);\n  }\n  /**\n   * Throws error when the authorization code is missing from the server response\n   */\n  static createNoAuthCodeInServerResponseError() {\n    return new ClientAuthError(ClientAuthErrorMessage.noAuthorizationCodeFromServer.code, ClientAuthErrorMessage.noAuthorizationCodeFromServer.desc);\n  }\n  static createBindingKeyNotRemovedError() {\n    return new ClientAuthError(ClientAuthErrorMessage.bindingKeyNotRemovedError.code, ClientAuthErrorMessage.bindingKeyNotRemovedError.desc);\n  }\n  /**\n   * Thrown when logout is attempted for an authority that doesnt have an end_session_endpoint\n   */\n  static createLogoutNotSupportedError() {\n    return new ClientAuthError(ClientAuthErrorMessage.logoutNotSupported.code, ClientAuthErrorMessage.logoutNotSupported.desc);\n  }\n  /**\n   * Create an error when kid attribute is missing from a PoP token's cache record\n   */\n  static createKeyIdMissingError() {\n    return new ClientAuthError(ClientAuthErrorMessage.keyIdMissing.code, ClientAuthErrorMessage.keyIdMissing.desc);\n  }\n  /**\n   * Create an error when the client does not have network connectivity\n   */\n  static createNoNetworkConnectivityError() {\n    return new ClientAuthError(ClientAuthErrorMessage.noNetworkConnectivity.code, ClientAuthErrorMessage.noNetworkConnectivity.desc);\n  }\n  /**\n   * Create an error when the user cancels the flow\n   */\n  static createUserCanceledError() {\n    return new ClientAuthError(ClientAuthErrorMessage.userCanceledError.code, ClientAuthErrorMessage.userCanceledError.desc);\n  }\n  /**\n   * Creates an error for during acquireTokenByClientCredential when TenantId is set to \"common\" or \"organizations\"\n   */\n  static createMissingTenantIdError() {\n    return new AuthError(ClientAuthErrorMessage.missingTenantIdError.code, ClientAuthErrorMessage.missingTenantIdError.desc);\n  }\n}\nexport { ClientAuthError, ClientAuthErrorMessage };","map":{"version":3,"names":["code","desc","missingTenantIdError","ClientAuthError","AuthError","name","Object","setPrototypeOf","prototype","createClientInfoDecodingError","caughtError","createClientInfoEmptyError","ClientAuthErrorMessage","clientInfoEmptyError","tokenParsingError","caughtExtractionError","createTokenNullOrEmptyError","invalidRawTokenString","nullOrEmptyToken","createEndpointDiscoveryIncompleteError","errDetail","networkError","endpoint","split","createUnableToGetOpenidConfigError","unableToGetOpenidConfigError","hashNotDeserialized","hashParamObj","createInvalidStateError","invalidState","errorString","invalidStateError","stateMismatchError","createStateNotFoundError","missingState","nonceMismatchError","createAuthTimeNotFoundError","authTimeNotFoundError","createMaxAgeTranspiredError","createNonceNotFoundError","missingNonce","nonceNotFoundError","createMultipleMatchingTokensInCacheError","createMultipleMatchingAccountsInCacheError","multipleMatchingAccounts","createMultipleMatchingAppMetadataInCacheError","createTokenRequestCannotBeMadeError","tokenRequestCannotBeMade","createRemoveEmptyScopeFromSetError","givenScope","removeEmptyScopeError","createAppendScopeSetError","appendError","appendScopeSetError","emptyInputScopeSetError","createDeviceCodeCancelledError","DeviceCodePollingCancelled","createDeviceCodeExpiredError","DeviceCodeUnknownError","createNoAccountInSilentRequestError","NoAccountInSilentRequest","invalidCacheRecord","createInvalidCacheEnvironmentError","invalidCacheEnvironment"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-common\\src\\error\\ClientAuthError.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AuthError } from \"./AuthError\";\n\n/**\n * ClientAuthErrorMessage class containing string constants used by error codes and messages.\n */\nexport const ClientAuthErrorMessage = {\n    clientInfoDecodingError: {\n        code: \"client_info_decoding_error\",\n        desc: \"The client info could not be parsed/decoded correctly. Please review the trace to determine the root cause.\",\n    },\n    clientInfoEmptyError: {\n        code: \"client_info_empty_error\",\n        desc: \"The client info was empty. Please review the trace to determine the root cause.\",\n    },\n    tokenParsingError: {\n        code: \"token_parsing_error\",\n        desc: \"Token cannot be parsed. Please review stack trace to determine root cause.\",\n    },\n    nullOrEmptyToken: {\n        code: \"null_or_empty_token\",\n        desc: \"The token is null or empty. Please review the trace to determine the root cause.\",\n    },\n    endpointResolutionError: {\n        code: \"endpoints_resolution_error\",\n        desc: \"Error: could not resolve endpoints. Please check network and try again.\",\n    },\n    networkError: {\n        code: \"network_error\",\n        desc: \"Network request failed. Please check network trace to determine root cause.\",\n    },\n    unableToGetOpenidConfigError: {\n        code: \"openid_config_error\",\n        desc: \"Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints.\",\n    },\n    hashNotDeserialized: {\n        code: \"hash_not_deserialized\",\n        desc: \"The hash parameters could not be deserialized. Please review the trace to determine the root cause.\",\n    },\n    blankGuidGenerated: {\n        code: \"blank_guid_generated\",\n        desc: \"The guid generated was blank. Please review the trace to determine the root cause.\",\n    },\n    invalidStateError: {\n        code: \"invalid_state\",\n        desc: \"State was not the expected format. Please check the logs to determine whether the request was sent using ProtocolUtils.setRequestState().\",\n    },\n    stateMismatchError: {\n        code: \"state_mismatch\",\n        desc: \"State mismatch error. Please check your network. Continued requests may cause cache overflow.\",\n    },\n    stateNotFoundError: {\n        code: \"state_not_found\",\n        desc: \"State not found\",\n    },\n    nonceMismatchError: {\n        code: \"nonce_mismatch\",\n        desc: \"Nonce mismatch error. This may be caused by a race condition in concurrent requests.\",\n    },\n    nonceNotFoundError: {\n        code: \"nonce_not_found\",\n        desc: \"nonce not found\",\n    },\n    authTimeNotFoundError: {\n        code: \"auth_time_not_found\",\n        desc:\n            \"Max Age was requested and the ID token is missing the auth_time variable.\" +\n            \" auth_time is an optional claim and is not enabled by default - it must be enabled.\" +\n            \" See https://aka.ms/msaljs/optional-claims for more information.\",\n    },\n    maxAgeTranspiredError: {\n        code: \"max_age_transpired\",\n        desc: \"Max Age is set to 0, or too much time has elapsed since the last end-user authentication.\",\n    },\n    noTokensFoundError: {\n        code: \"no_tokens_found\",\n        desc: \"No tokens were found for the given scopes, and no authorization code was passed to acquireToken. You must retrieve an authorization code before making a call to acquireToken().\",\n    },\n    multipleMatchingTokens: {\n        code: \"multiple_matching_tokens\",\n        desc:\n            \"The cache contains multiple tokens satisfying the requirements. \" +\n            \"Call AcquireToken again providing more requirements such as authority or account.\",\n    },\n    multipleMatchingAccounts: {\n        code: \"multiple_matching_accounts\",\n        desc: \"The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account\",\n    },\n    multipleMatchingAppMetadata: {\n        code: \"multiple_matching_appMetadata\",\n        desc: \"The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata\",\n    },\n    tokenRequestCannotBeMade: {\n        code: \"request_cannot_be_made\",\n        desc: \"Token request cannot be made without authorization code or refresh token.\",\n    },\n    appendEmptyScopeError: {\n        code: \"cannot_append_empty_scope\",\n        desc: \"Cannot append null or empty scope to ScopeSet. Please check the stack trace for more info.\",\n    },\n    removeEmptyScopeError: {\n        code: \"cannot_remove_empty_scope\",\n        desc: \"Cannot remove null or empty scope from ScopeSet. Please check the stack trace for more info.\",\n    },\n    appendScopeSetError: {\n        code: \"cannot_append_scopeset\",\n        desc: \"Cannot append ScopeSet due to error.\",\n    },\n    emptyInputScopeSetError: {\n        code: \"empty_input_scopeset\",\n        desc: \"Empty input ScopeSet cannot be processed.\",\n    },\n    DeviceCodePollingCancelled: {\n        code: \"device_code_polling_cancelled\",\n        desc: \"Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true.\",\n    },\n    DeviceCodeExpired: {\n        code: \"device_code_expired\",\n        desc: \"Device code is expired.\",\n    },\n    DeviceCodeUnknownError: {\n        code: \"device_code_unknown_error\",\n        desc: \"Device code stopped polling for unknown reasons.\",\n    },\n    NoAccountInSilentRequest: {\n        code: \"no_account_in_silent_request\",\n        desc: \"Please pass an account object, silent flow is not supported without account information\",\n    },\n    invalidCacheRecord: {\n        code: \"invalid_cache_record\",\n        desc: \"Cache record object was null or undefined.\",\n    },\n    invalidCacheEnvironment: {\n        code: \"invalid_cache_environment\",\n        desc: \"Invalid environment when attempting to create cache entry\",\n    },\n    noAccountFound: {\n        code: \"no_account_found\",\n        desc: \"No account found in cache for given key.\",\n    },\n    CachePluginError: {\n        code: \"no cache plugin set on CacheManager\",\n        desc: \"ICachePlugin needs to be set before using readFromStorage or writeFromStorage\",\n    },\n    noCryptoObj: {\n        code: \"no_crypto_object\",\n        desc: \"No crypto object detected. This is required for the following operation: \",\n    },\n    invalidCacheType: {\n        code: \"invalid_cache_type\",\n        desc: \"Invalid cache type\",\n    },\n    unexpectedAccountType: {\n        code: \"unexpected_account_type\",\n        desc: \"Unexpected account type.\",\n    },\n    unexpectedCredentialType: {\n        code: \"unexpected_credential_type\",\n        desc: \"Unexpected credential type.\",\n    },\n    invalidAssertion: {\n        code: \"invalid_assertion\",\n        desc: \"Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515\",\n    },\n    invalidClientCredential: {\n        code: \"invalid_client_credential\",\n        desc: \"Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential\",\n    },\n    tokenRefreshRequired: {\n        code: \"token_refresh_required\",\n        desc: \"Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired.\",\n    },\n    userTimeoutReached: {\n        code: \"user_timeout_reached\",\n        desc: \"User defined timeout for device code polling reached\",\n    },\n    tokenClaimsRequired: {\n        code: \"token_claims_cnf_required_for_signedjwt\",\n        desc: \"Cannot generate a POP jwt if the token_claims are not populated\",\n    },\n    noAuthorizationCodeFromServer: {\n        code: \"authorization_code_missing_from_server_response\",\n        desc: \"Server response does not contain an authorization code to proceed\",\n    },\n    noAzureRegionDetected: {\n        code: \"no_azure_region_detected\",\n        desc: \"No azure region was detected and no fallback was made available\",\n    },\n    accessTokenEntityNullError: {\n        code: \"access_token_entity_null\",\n        desc: \"Access token entity is null, please check logs and cache to ensure a valid access token is present.\",\n    },\n    bindingKeyNotRemovedError: {\n        code: \"binding_key_not_removed\",\n        desc: \"Could not remove the credential's binding key from storage.\",\n    },\n    logoutNotSupported: {\n        code: \"end_session_endpoint_not_supported\",\n        desc: \"Provided authority does not support logout.\",\n    },\n    keyIdMissing: {\n        code: \"key_id_missing\",\n        desc: \"A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key.\",\n    },\n    noNetworkConnectivity: {\n        code: \"no_network_connectivity\",\n        desc: \"No network connectivity. Check your internet connection.\",\n    },\n    userCanceledError: {\n        code: \"user_canceled\",\n        desc: \"User canceled the flow.\",\n    },\n    missingTenantIdError: {\n        code: \"missing_tenant_id_error\",\n        desc: \"A tenant id - not common, organizations, or consumers - must be specified when using the client_credentials flow.\",\n    },\n};\n\n/**\n * Error thrown when there is an error in the client code running on the browser.\n */\nexport class ClientAuthError extends AuthError {\n    constructor(errorCode: string, errorMessage?: string) {\n        super(errorCode, errorMessage);\n        this.name = \"ClientAuthError\";\n\n        Object.setPrototypeOf(this, ClientAuthError.prototype);\n    }\n\n    /**\n     * Creates an error thrown when client info object doesn't decode correctly.\n     * @param caughtError\n     */\n    static createClientInfoDecodingError(caughtError: string): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.clientInfoDecodingError.code,\n            `${ClientAuthErrorMessage.clientInfoDecodingError.desc} Failed with error: ${caughtError}`\n        );\n    }\n\n    /**\n     * Creates an error thrown if the client info is empty.\n     * @param rawClientInfo\n     */\n    static createClientInfoEmptyError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.clientInfoEmptyError.code,\n            `${ClientAuthErrorMessage.clientInfoEmptyError.desc}`\n        );\n    }\n\n    /**\n     * Creates an error thrown when the id token extraction errors out.\n     * @param err\n     */\n    static createTokenParsingError(\n        caughtExtractionError: string\n    ): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.tokenParsingError.code,\n            `${ClientAuthErrorMessage.tokenParsingError.desc} Failed with error: ${caughtExtractionError}`\n        );\n    }\n\n    /**\n     * Creates an error thrown when the id token string is null or empty.\n     * @param invalidRawTokenString\n     */\n    static createTokenNullOrEmptyError(\n        invalidRawTokenString: string\n    ): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.nullOrEmptyToken.code,\n            `${ClientAuthErrorMessage.nullOrEmptyToken.desc} Raw Token Value: ${invalidRawTokenString}`\n        );\n    }\n\n    /**\n     * Creates an error thrown when the endpoint discovery doesn't complete correctly.\n     */\n    static createEndpointDiscoveryIncompleteError(\n        errDetail: string\n    ): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.endpointResolutionError.code,\n            `${ClientAuthErrorMessage.endpointResolutionError.desc} Detail: ${errDetail}`\n        );\n    }\n\n    /**\n     * Creates an error thrown when the fetch client throws\n     */\n    static createNetworkError(\n        endpoint: string,\n        errDetail: string\n    ): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.networkError.code,\n            `${\n                ClientAuthErrorMessage.networkError.desc\n            } | Fetch client threw: ${errDetail} | Attempted to reach: ${\n                endpoint.split(\"?\")[0]\n            }`\n        );\n    }\n\n    /**\n     * Creates an error thrown when the openid-configuration endpoint cannot be reached or does not contain the required data\n     */\n    static createUnableToGetOpenidConfigError(\n        errDetail: string\n    ): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.unableToGetOpenidConfigError.code,\n            `${ClientAuthErrorMessage.unableToGetOpenidConfigError.desc} Attempted to retrieve endpoints from: ${errDetail}`\n        );\n    }\n\n    /**\n     * Creates an error thrown when the hash cannot be deserialized.\n     * @param hashParamObj\n     */\n    static createHashNotDeserializedError(\n        hashParamObj: string\n    ): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.hashNotDeserialized.code,\n            `${ClientAuthErrorMessage.hashNotDeserialized.desc} Given Object: ${hashParamObj}`\n        );\n    }\n\n    /**\n     * Creates an error thrown when the state cannot be parsed.\n     * @param invalidState\n     */\n    static createInvalidStateError(\n        invalidState: string,\n        errorString?: string\n    ): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.invalidStateError.code,\n            `${ClientAuthErrorMessage.invalidStateError.desc} Invalid State: ${invalidState}, Root Err: ${errorString}`\n        );\n    }\n\n    /**\n     * Creates an error thrown when two states do not match.\n     */\n    static createStateMismatchError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.stateMismatchError.code,\n            ClientAuthErrorMessage.stateMismatchError.desc\n        );\n    }\n\n    /**\n     * Creates an error thrown when the state is not present\n     * @param missingState\n     */\n    static createStateNotFoundError(missingState: string): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.stateNotFoundError.code,\n            `${ClientAuthErrorMessage.stateNotFoundError.desc}:  ${missingState}`\n        );\n    }\n\n    /**\n     * Creates an error thrown when the nonce does not match.\n     */\n    static createNonceMismatchError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.nonceMismatchError.code,\n            ClientAuthErrorMessage.nonceMismatchError.desc\n        );\n    }\n\n    /**\n     * Creates an error thrown when max_age was provided in the request, but auth_time is not in the token claims\n     * @param missingNonce\n     */\n    static createAuthTimeNotFoundError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.authTimeNotFoundError.code,\n            ClientAuthErrorMessage.authTimeNotFoundError.desc\n        );\n    }\n\n    /**\n     * Creates an error thrown when too much time has elapsed since the last end-user authentication\n     */\n    static createMaxAgeTranspiredError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.maxAgeTranspiredError.code,\n            ClientAuthErrorMessage.maxAgeTranspiredError.desc\n        );\n    }\n\n    /**\n     * Creates an error thrown when the mnonce is not present\n     * @param missingNonce\n     */\n    static createNonceNotFoundError(missingNonce: string): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.nonceNotFoundError.code,\n            `${ClientAuthErrorMessage.nonceNotFoundError.desc}:  ${missingNonce}`\n        );\n    }\n\n    /**\n     * Throws error when multiple tokens are in cache.\n     */\n    static createMultipleMatchingTokensInCacheError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.multipleMatchingTokens.code,\n            `${ClientAuthErrorMessage.multipleMatchingTokens.desc}.`\n        );\n    }\n\n    /**\n     * Throws error when multiple accounts are in cache for the given params\n     */\n    static createMultipleMatchingAccountsInCacheError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.multipleMatchingAccounts.code,\n            ClientAuthErrorMessage.multipleMatchingAccounts.desc\n        );\n    }\n\n    /**\n     * Throws error when multiple appMetada are in cache for the given clientId.\n     */\n    static createMultipleMatchingAppMetadataInCacheError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.multipleMatchingAppMetadata.code,\n            ClientAuthErrorMessage.multipleMatchingAppMetadata.desc\n        );\n    }\n\n    /**\n     * Throws error when no auth code or refresh token is given to ServerTokenRequestParameters.\n     */\n    static createTokenRequestCannotBeMadeError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.tokenRequestCannotBeMade.code,\n            ClientAuthErrorMessage.tokenRequestCannotBeMade.desc\n        );\n    }\n\n    /**\n     * Throws error when attempting to append a null, undefined or empty scope to a set\n     * @param givenScope\n     */\n    static createAppendEmptyScopeToSetError(\n        givenScope: string\n    ): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.appendEmptyScopeError.code,\n            `${ClientAuthErrorMessage.appendEmptyScopeError.desc} Given Scope: ${givenScope}`\n        );\n    }\n\n    /**\n     * Throws error when attempting to append a null, undefined or empty scope to a set\n     * @param givenScope\n     */\n    static createRemoveEmptyScopeFromSetError(\n        givenScope: string\n    ): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.removeEmptyScopeError.code,\n            `${ClientAuthErrorMessage.removeEmptyScopeError.desc} Given Scope: ${givenScope}`\n        );\n    }\n\n    /**\n     * Throws error when attempting to append null or empty ScopeSet.\n     * @param appendError\n     */\n    static createAppendScopeSetError(appendError: string): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.appendScopeSetError.code,\n            `${ClientAuthErrorMessage.appendScopeSetError.desc} Detail Error: ${appendError}`\n        );\n    }\n\n    /**\n     * Throws error if ScopeSet is null or undefined.\n     * @param givenScopeSet\n     */\n    static createEmptyInputScopeSetError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.emptyInputScopeSetError.code,\n            `${ClientAuthErrorMessage.emptyInputScopeSetError.desc}`\n        );\n    }\n\n    /**\n     * Throws error if user sets CancellationToken.cancel = true during polling of token endpoint during device code flow\n     */\n    static createDeviceCodeCancelledError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.DeviceCodePollingCancelled.code,\n            `${ClientAuthErrorMessage.DeviceCodePollingCancelled.desc}`\n        );\n    }\n\n    /**\n     * Throws error if device code is expired\n     */\n    static createDeviceCodeExpiredError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.DeviceCodeExpired.code,\n            `${ClientAuthErrorMessage.DeviceCodeExpired.desc}`\n        );\n    }\n\n    /**\n     * Throws error if device code is expired\n     */\n    static createDeviceCodeUnknownError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.DeviceCodeUnknownError.code,\n            `${ClientAuthErrorMessage.DeviceCodeUnknownError.desc}`\n        );\n    }\n\n    /**\n     * Throws error when silent requests are made without an account object\n     */\n    static createNoAccountInSilentRequestError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.NoAccountInSilentRequest.code,\n            `${ClientAuthErrorMessage.NoAccountInSilentRequest.desc}`\n        );\n    }\n\n    /**\n     * Throws error when cache record is null or undefined.\n     */\n    static createNullOrUndefinedCacheRecord(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.invalidCacheRecord.code,\n            ClientAuthErrorMessage.invalidCacheRecord.desc\n        );\n    }\n\n    /**\n     * Throws error when provided environment is not part of the CloudDiscoveryMetadata object\n     */\n    static createInvalidCacheEnvironmentError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.invalidCacheEnvironment.code,\n            ClientAuthErrorMessage.invalidCacheEnvironment.desc\n        );\n    }\n\n    /**\n     * Throws error when account is not found in cache.\n     */\n    static createNoAccountFoundError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.noAccountFound.code,\n            ClientAuthErrorMessage.noAccountFound.desc\n        );\n    }\n\n    /**\n     * Throws error if ICachePlugin not set on CacheManager.\n     */\n    static createCachePluginError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.CachePluginError.code,\n            `${ClientAuthErrorMessage.CachePluginError.desc}`\n        );\n    }\n\n    /**\n     * Throws error if crypto object not found.\n     * @param operationName\n     */\n    static createNoCryptoObjectError(operationName: string): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.noCryptoObj.code,\n            `${ClientAuthErrorMessage.noCryptoObj.desc}${operationName}`\n        );\n    }\n\n    /**\n     * Throws error if cache type is invalid.\n     */\n    static createInvalidCacheTypeError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.invalidCacheType.code,\n            `${ClientAuthErrorMessage.invalidCacheType.desc}`\n        );\n    }\n\n    /**\n     * Throws error if unexpected account type.\n     */\n    static createUnexpectedAccountTypeError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.unexpectedAccountType.code,\n            `${ClientAuthErrorMessage.unexpectedAccountType.desc}`\n        );\n    }\n\n    /**\n     * Throws error if unexpected credential type.\n     */\n    static createUnexpectedCredentialTypeError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.unexpectedCredentialType.code,\n            `${ClientAuthErrorMessage.unexpectedCredentialType.desc}`\n        );\n    }\n\n    /**\n     * Throws error if client assertion is not valid.\n     */\n    static createInvalidAssertionError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.invalidAssertion.code,\n            `${ClientAuthErrorMessage.invalidAssertion.desc}`\n        );\n    }\n\n    /**\n     * Throws error if client assertion is not valid.\n     */\n    static createInvalidCredentialError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.invalidClientCredential.code,\n            `${ClientAuthErrorMessage.invalidClientCredential.desc}`\n        );\n    }\n\n    /**\n     * Throws error if token cannot be retrieved from cache due to refresh being required.\n     */\n    static createRefreshRequiredError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.tokenRefreshRequired.code,\n            ClientAuthErrorMessage.tokenRefreshRequired.desc\n        );\n    }\n\n    /**\n     * Throws error if the user defined timeout is reached.\n     */\n    static createUserTimeoutReachedError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.userTimeoutReached.code,\n            ClientAuthErrorMessage.userTimeoutReached.desc\n        );\n    }\n\n    /*\n     * Throws error if token claims are not populated for a signed jwt generation\n     */\n    static createTokenClaimsRequiredError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.tokenClaimsRequired.code,\n            ClientAuthErrorMessage.tokenClaimsRequired.desc\n        );\n    }\n\n    /**\n     * Throws error when the authorization code is missing from the server response\n     */\n    static createNoAuthCodeInServerResponseError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.noAuthorizationCodeFromServer.code,\n            ClientAuthErrorMessage.noAuthorizationCodeFromServer.desc\n        );\n    }\n\n    static createBindingKeyNotRemovedError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.bindingKeyNotRemovedError.code,\n            ClientAuthErrorMessage.bindingKeyNotRemovedError.desc\n        );\n    }\n\n    /**\n     * Thrown when logout is attempted for an authority that doesnt have an end_session_endpoint\n     */\n    static createLogoutNotSupportedError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.logoutNotSupported.code,\n            ClientAuthErrorMessage.logoutNotSupported.desc\n        );\n    }\n\n    /**\n     * Create an error when kid attribute is missing from a PoP token's cache record\n     */\n    static createKeyIdMissingError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.keyIdMissing.code,\n            ClientAuthErrorMessage.keyIdMissing.desc\n        );\n    }\n\n    /**\n     * Create an error when the client does not have network connectivity\n     */\n    static createNoNetworkConnectivityError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.noNetworkConnectivity.code,\n            ClientAuthErrorMessage.noNetworkConnectivity.desc\n        );\n    }\n\n    /**\n     * Create an error when the user cancels the flow\n     */\n    static createUserCanceledError(): ClientAuthError {\n        return new ClientAuthError(\n            ClientAuthErrorMessage.userCanceledError.code,\n            ClientAuthErrorMessage.userCanceledError.desc\n        );\n    }\n\n    /**\n     * Creates an error for during acquireTokenByClientCredential when TenantId is set to \"common\" or \"organizations\"\n     */\n    static createMissingTenantIdError(): ClientAuthError {\n        return new AuthError(\n            ClientAuthErrorMessage.missingTenantIdError.code,\n            ClientAuthErrorMessage.missingTenantIdError.desc\n        );\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}