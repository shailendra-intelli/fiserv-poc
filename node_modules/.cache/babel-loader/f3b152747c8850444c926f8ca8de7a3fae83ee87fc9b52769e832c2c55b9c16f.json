{"ast":null,"code":"/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\n\nimport { OIDC_DEFAULT_SCOPES, PerformanceEvents, Constants, UrlString, ThrottlingUtils, ProtocolUtils, AuthError, ProtocolMode, ServerResponseType } from '@azure/msal-common';\nimport { StandardInteractionClient } from './StandardInteractionClient.mjs';\nimport { EventType } from '../event/EventType.mjs';\nimport { ApiId, InteractionType, BrowserConstants } from '../utils/BrowserConstants.mjs';\nimport { BrowserUtils } from '../utils/BrowserUtils.mjs';\nimport { NativeInteractionClient } from './NativeInteractionClient.mjs';\nimport { NativeMessageHandler } from '../broker/nativeBroker/NativeMessageHandler.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { InteractionHandler } from '../interaction_handler/InteractionHandler.mjs';\nimport { nativeConnectionNotEstablished, emptyNavigateUri, userCancelled, hashDoesNotContainKnownProperties, monitorPopupTimeout, emptyWindowError, popupWindowError } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass PopupClient extends StandardInteractionClient {\n  constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {\n    super(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId);\n    // Properly sets this reference for the unload event.\n    this.unloadWindow = this.unloadWindow.bind(this);\n    this.nativeStorage = nativeStorageImpl;\n  }\n  /**\n   * Acquires tokens by opening a popup window to the /authorize endpoint of the authority\n   * @param request\n   */\n  acquireToken(request) {\n    try {\n      const popupName = this.generatePopupName(request.scopes || OIDC_DEFAULT_SCOPES, request.authority || this.config.auth.authority);\n      const popupWindowAttributes = request.popupWindowAttributes || {};\n      // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n      if (this.config.system.asyncPopups) {\n        this.logger.verbose(\"asyncPopups set to true, acquiring token\");\n        // Passes on popup position and dimensions if in request\n        return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes);\n      } else {\n        // asyncPopups flag is set to false. Opens popup before acquiring token.\n        this.logger.verbose(\"asyncPopup set to false, opening popup before acquiring token\");\n        const popup = this.openSizedPopup(\"about:blank\", popupName, popupWindowAttributes);\n        return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes, popup);\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server\n   * @param logoutRequest\n   */\n  logout(logoutRequest) {\n    try {\n      this.logger.verbose(\"logoutPopup called\");\n      const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\n      const popupName = this.generateLogoutPopupName(validLogoutRequest);\n      const authority = logoutRequest && logoutRequest.authority;\n      const mainWindowRedirectUri = logoutRequest && logoutRequest.mainWindowRedirectUri;\n      const popupWindowAttributes = logoutRequest?.popupWindowAttributes || {};\n      // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n      if (this.config.system.asyncPopups) {\n        this.logger.verbose(\"asyncPopups set to true\");\n        // Passes on popup position and dimensions if in request\n        return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, undefined, mainWindowRedirectUri);\n      } else {\n        // asyncPopups flag is set to false. Opens popup before logging out.\n        this.logger.verbose(\"asyncPopup set to false, opening popup\");\n        const popup = this.openSizedPopup(\"about:blank\", popupName, popupWindowAttributes);\n        return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, popup, mainWindowRedirectUri);\n      }\n    } catch (e) {\n      // Since this function is synchronous we need to reject\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Helper which obtains an access_token for your API via opening a popup window in the user's browser\n   * @param validRequest\n   * @param popupName\n   * @param popup\n   * @param popupWindowAttributes\n   *\n   * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\n   */\n  async acquireTokenPopupAsync(request, popupName, popupWindowAttributes, popup) {\n    this.logger.verbose(\"acquireTokenPopupAsync called\");\n    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenPopup);\n    this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, request.correlationId);\n    const validRequest = await this.initializeAuthorizationRequest(request, InteractionType.Popup);\n    this.browserStorage.updateCacheEntries(validRequest.state, validRequest.nonce, validRequest.authority, validRequest.loginHint || Constants.EMPTY_STRING, validRequest.account || null);\n    try {\n      // Create auth code request and generate PKCE params\n      this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, request.correlationId);\n      const authCodeRequest = await this.initializeAuthorizationCodeRequest(validRequest);\n      // Initialize the client\n      this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, request.correlationId);\n      const authClient = await this.createAuthCodeClient(serverTelemetryManager, validRequest.authority, validRequest.azureCloudOptions);\n      this.logger.verbose(\"Auth code client created\");\n      const isNativeBroker = NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeMessageHandler, request.authenticationScheme);\n      // Start measurement for server calls with native brokering enabled\n      let fetchNativeAccountIdMeasurement;\n      if (isNativeBroker) {\n        fetchNativeAccountIdMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.FetchAccountIdWithNativeBroker, request.correlationId);\n      }\n      // Create acquire token url.\n      const navigateUrl = await authClient.getAuthCodeUrl({\n        ...validRequest,\n        nativeBroker: isNativeBroker\n      });\n      // Create popup interaction handler.\n      const interactionHandler = new InteractionHandler(authClient, this.browserStorage, authCodeRequest, this.logger, this.performanceClient);\n      // Show the UI once the url has been created. Get the window handle for the popup.\n      const popupParameters = {\n        popup,\n        popupName,\n        popupWindowAttributes\n      };\n      const popupWindow = this.initiateAuthRequest(navigateUrl, popupParameters);\n      this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {\n        popupWindow\n      }, null);\n      // Monitor the window for the hash. Return the string value and close the popup when the hash is received. Default timeout is 60 seconds.\n      const hash = await this.monitorPopupForHash(popupWindow);\n      // Deserialize hash fragment response parameters.\n      const serverParams = UrlString.getDeserializedHash(hash);\n      const state = this.validateAndExtractStateFromHash(serverParams, InteractionType.Popup, validRequest.correlationId);\n      // Remove throttle if it exists\n      ThrottlingUtils.removeThrottle(this.browserStorage, this.config.auth.clientId, authCodeRequest);\n      if (serverParams.accountId) {\n        this.logger.verbose(\"Account id found in hash, calling WAM for token\");\n        // end measurement for server call with native brokering enabled\n        if (fetchNativeAccountIdMeasurement) {\n          fetchNativeAccountIdMeasurement.end({\n            success: true,\n            isNativeBroker: true\n          });\n        }\n        if (!this.nativeMessageHandler) {\n          throw createBrowserAuthError(nativeConnectionNotEstablished);\n        }\n        const nativeInteractionClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenPopup, this.performanceClient, this.nativeMessageHandler, serverParams.accountId, this.nativeStorage, validRequest.correlationId);\n        const {\n          userRequestState\n        } = ProtocolUtils.parseRequestState(this.browserCrypto, state);\n        return nativeInteractionClient.acquireToken({\n          ...validRequest,\n          state: userRequestState,\n          prompt: undefined // Server should handle the prompt, ideally native broker can do this part silently\n        }).finally(() => {\n          this.browserStorage.cleanRequestByState(state);\n        });\n      }\n      // Handle response from hash string.\n      const result = await interactionHandler.handleCodeResponseFromHash(hash, state, authClient.authority, this.networkClient);\n      return result;\n    } catch (e) {\n      if (popup) {\n        // Close the synchronous popup if an error is thrown before the window unload event is registered\n        popup.close();\n      }\n      if (e instanceof AuthError) {\n        e.setCorrelationId(this.correlationId);\n        serverTelemetryManager.cacheFailedRequest(e);\n      }\n      this.browserStorage.cleanRequestByState(validRequest.state);\n      throw e;\n    }\n  }\n  /**\n   *\n   * @param validRequest\n   * @param popupName\n   * @param requestAuthority\n   * @param popup\n   * @param mainWindowRedirectUri\n   * @param popupWindowAttributes\n   */\n  async logoutPopupAsync(validRequest, popupName, popupWindowAttributes, requestAuthority, popup, mainWindowRedirectUri) {\n    this.logger.verbose(\"logoutPopupAsync called\");\n    this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Popup, validRequest);\n    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logoutPopup);\n    try {\n      // Clear cache on logout\n      await this.clearCacheOnLogout(validRequest.account);\n      // Initialize the client\n      this.performanceClient.setPreQueueTime(PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, validRequest.correlationId);\n      const authClient = await this.createAuthCodeClient(serverTelemetryManager, requestAuthority);\n      this.logger.verbose(\"Auth code client created\");\n      try {\n        authClient.authority.endSessionEndpoint;\n      } catch {\n        if (validRequest.account?.homeAccountId && validRequest.postLogoutRedirectUri && authClient.authority.protocolMode === ProtocolMode.OIDC) {\n          void this.browserStorage.removeAccount(validRequest.account?.homeAccountId);\n          this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);\n          if (mainWindowRedirectUri) {\n            const navigationOptions = {\n              apiId: ApiId.logoutPopup,\n              timeout: this.config.system.redirectNavigationTimeout,\n              noHistory: false\n            };\n            const absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, BrowserUtils.getCurrentUri());\n            await this.navigationClient.navigateInternal(absoluteUrl, navigationOptions);\n          }\n          if (popup) {\n            popup.close();\n          }\n          return;\n        }\n      }\n      // Create logout string and navigate user window to logout.\n      const logoutUri = authClient.getLogoutUri(validRequest);\n      this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);\n      // Open the popup window to requestUrl.\n      const popupWindow = this.openPopup(logoutUri, {\n        popupName,\n        popupWindowAttributes,\n        popup\n      });\n      this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {\n        popupWindow\n      }, null);\n      await this.waitForLogoutPopup(popupWindow);\n      if (mainWindowRedirectUri) {\n        const navigationOptions = {\n          apiId: ApiId.logoutPopup,\n          timeout: this.config.system.redirectNavigationTimeout,\n          noHistory: false\n        };\n        const absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, BrowserUtils.getCurrentUri());\n        this.logger.verbose(\"Redirecting main window to url specified in the request\");\n        this.logger.verbosePii(`Redirecting main window to: ${absoluteUrl}`);\n        await this.navigationClient.navigateInternal(absoluteUrl, navigationOptions);\n      } else {\n        this.logger.verbose(\"No main window navigation requested\");\n      }\n    } catch (e) {\n      if (popup) {\n        // Close the synchronous popup if an error is thrown before the window unload event is registered\n        popup.close();\n      }\n      if (e instanceof AuthError) {\n        e.setCorrelationId(this.correlationId);\n        serverTelemetryManager.cacheFailedRequest(e);\n      }\n      this.browserStorage.setInteractionInProgress(false);\n      this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Popup, null, e);\n      this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);\n      throw e;\n    }\n    this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);\n  }\n  /**\n   * Opens a popup window with given request Url.\n   * @param requestUrl\n   */\n  initiateAuthRequest(requestUrl, params) {\n    // Check that request url is not empty.\n    if (requestUrl) {\n      this.logger.infoPii(`Navigate to: ${requestUrl}`);\n      // Open the popup window to requestUrl.\n      return this.openPopup(requestUrl, params);\n    } else {\n      // Throw error if request URL is empty.\n      this.logger.error(\"Navigate url is empty\");\n      throw createBrowserAuthError(emptyNavigateUri);\n    }\n  }\n  /**\n   * Monitors a window until it loads a url with the same origin.\n   * @param popupWindow - window that is being monitored\n   * @param timeout - timeout for processing hash once popup is redirected back to application\n   */\n  monitorPopupForHash(popupWindow) {\n    return new Promise((resolve, reject) => {\n      /*\n       * Polling for popups needs to be tick-based,\n       * since a non-trivial amount of time can be spent on interaction (which should not count against the timeout).\n       */\n      const maxTicks = this.config.system.windowHashTimeout / this.config.system.pollIntervalMilliseconds;\n      let ticks = 0;\n      this.logger.verbose(\"PopupHandler.monitorPopupForHash - polling started\");\n      const intervalId = setInterval(() => {\n        // Window is closed\n        if (popupWindow.closed) {\n          this.logger.error(\"PopupHandler.monitorPopupForHash - window closed\");\n          this.cleanPopup();\n          clearInterval(intervalId);\n          reject(createBrowserAuthError(userCancelled));\n          return;\n        }\n        let href = Constants.EMPTY_STRING;\n        let serverResponseString = Constants.EMPTY_STRING;\n        try {\n          /*\n           * Will throw if cross origin,\n           * which should be caught and ignored\n           * since we need the interval to keep running while on STS UI.\n           */\n          href = popupWindow.location.href;\n          serverResponseString = this.extractServerResponseStringFromPopup(popupWindow, href);\n        } catch (e) {}\n        // Don't process blank pages or cross domain\n        if (!href || href === \"about:blank\") {\n          return;\n        }\n        this.logger.verbose(\"PopupHandler.monitorPopupForHash - popup window is on same origin as caller\");\n        /*\n         * Only run clock when we are on same domain for popups\n         * as popup operations can take a long time.\n         */\n        ticks++;\n        if (serverResponseString) {\n          this.logger.verbose(\"PopupHandler.monitorPopupForHash - found hash in url\");\n          clearInterval(intervalId);\n          this.cleanPopup(popupWindow);\n          if (UrlString.hashContainsKnownProperties(serverResponseString)) {\n            this.logger.verbose(\"PopupHandler.monitorPopupForHash - hash contains known properties, returning.\");\n            resolve(serverResponseString);\n          } else {\n            this.logger.error(\"PopupHandler.monitorPopupForHash - found hash in url but it does not contain known properties. Check that your router is not changing the hash prematurely.\");\n            this.logger.errorPii(`PopupHandler.monitorPopupForHash - hash found: ${serverResponseString}`);\n            reject(createBrowserAuthError(hashDoesNotContainKnownProperties));\n          }\n        } else if (ticks > maxTicks) {\n          this.logger.error(\"PopupHandler.monitorPopupForHash - unable to find hash in url, timing out\");\n          clearInterval(intervalId);\n          reject(createBrowserAuthError(monitorPopupTimeout));\n        }\n      }, this.config.system.pollIntervalMilliseconds);\n    });\n  }\n  /**\n   * Waits for user interaction in logout popup window\n   * @param popupWindow\n   * @returns\n   */\n  waitForLogoutPopup(popupWindow) {\n    return new Promise(resolve => {\n      this.logger.verbose(\"PopupHandler.waitForLogoutPopup - polling started\");\n      const intervalId = setInterval(() => {\n        // Window is closed\n        if (popupWindow.closed) {\n          this.logger.error(\"PopupHandler.waitForLogoutPopup - window closed\");\n          this.cleanPopup();\n          clearInterval(intervalId);\n          resolve();\n        }\n        let href = Constants.EMPTY_STRING;\n        try {\n          /*\n           * Will throw if cross origin,\n           * which should be caught and ignored\n           * since we need the interval to keep running while on STS UI.\n           */\n          href = popupWindow.location.href;\n        } catch (e) {}\n        // Don't process blank pages or cross domain\n        if (!href || href === \"about:blank\") {\n          return;\n        }\n        this.logger.verbose(\"PopupHandler.waitForLogoutPopup - popup window is on same origin as caller, closing.\");\n        clearInterval(intervalId);\n        this.cleanPopup(popupWindow);\n        resolve();\n      }, this.config.system.pollIntervalMilliseconds);\n    });\n  }\n  /**\n   * @hidden\n   *\n   * Configures popup window for login.\n   *\n   * @param urlNavigate\n   * @param title\n   * @param popUpWidth\n   * @param popUpHeight\n   * @param popupWindowAttributes\n   * @ignore\n   * @hidden\n   */\n  openPopup(urlNavigate, popupParams) {\n    try {\n      let popupWindow;\n      // Popup window passed in, setting url to navigate to\n      if (popupParams.popup) {\n        popupWindow = popupParams.popup;\n        this.logger.verbosePii(`Navigating popup window to: ${urlNavigate}`);\n        popupWindow.location.assign(urlNavigate);\n      } else if (typeof popupParams.popup === \"undefined\") {\n        // Popup will be undefined if it was not passed in\n        this.logger.verbosePii(`Opening popup window to: ${urlNavigate}`);\n        popupWindow = this.openSizedPopup(urlNavigate, popupParams.popupName, popupParams.popupWindowAttributes);\n      }\n      // Popup will be null if popups are blocked\n      if (!popupWindow) {\n        throw createBrowserAuthError(emptyWindowError);\n      }\n      if (popupWindow.focus) {\n        popupWindow.focus();\n      }\n      this.currentWindow = popupWindow;\n      window.addEventListener(\"beforeunload\", this.unloadWindow);\n      return popupWindow;\n    } catch (e) {\n      this.logger.error(\"error opening popup \" + e.message);\n      this.browserStorage.setInteractionInProgress(false);\n      throw createBrowserAuthError(popupWindowError);\n    }\n  }\n  /**\n   * Helper function to set popup window dimensions and position\n   * @param urlNavigate\n   * @param popupName\n   * @param popupWindowAttributes\n   * @returns\n   */\n  openSizedPopup(urlNavigate, popupName, popupWindowAttributes) {\n    /**\n     * adding winLeft and winTop to account for dual monitor\n     * using screenLeft and screenTop for IE8 and earlier\n     */\n    const winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n    const winTop = window.screenTop ? window.screenTop : window.screenY;\n    /**\n     * window.innerWidth displays browser window\"s height and width excluding toolbars\n     * using document.documentElement.clientWidth for IE8 and earlier\n     */\n    const winWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n    const winHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n    let width = popupWindowAttributes.popupSize?.width;\n    let height = popupWindowAttributes.popupSize?.height;\n    let top = popupWindowAttributes.popupPosition?.top;\n    let left = popupWindowAttributes.popupPosition?.left;\n    if (!width || width < 0 || width > winWidth) {\n      this.logger.verbose(\"Default popup window width used. Window width not configured or invalid.\");\n      width = BrowserConstants.POPUP_WIDTH;\n    }\n    if (!height || height < 0 || height > winHeight) {\n      this.logger.verbose(\"Default popup window height used. Window height not configured or invalid.\");\n      height = BrowserConstants.POPUP_HEIGHT;\n    }\n    if (!top || top < 0 || top > winHeight) {\n      this.logger.verbose(\"Default popup window top position used. Window top not configured or invalid.\");\n      top = Math.max(0, winHeight / 2 - BrowserConstants.POPUP_HEIGHT / 2 + winTop);\n    }\n    if (!left || left < 0 || left > winWidth) {\n      this.logger.verbose(\"Default popup window left position used. Window left not configured or invalid.\");\n      left = Math.max(0, winWidth / 2 - BrowserConstants.POPUP_WIDTH / 2 + winLeft);\n    }\n    return window.open(urlNavigate, popupName, `width=${width}, height=${height}, top=${top}, left=${left}, scrollbars=yes`);\n  }\n  /**\n   * Event callback to unload main window.\n   */\n  unloadWindow(e) {\n    this.browserStorage.cleanRequestByInteractionType(InteractionType.Popup);\n    if (this.currentWindow) {\n      this.currentWindow.close();\n    }\n    // Guarantees browser unload will happen, so no other errors will be thrown.\n    e.preventDefault();\n  }\n  /**\n   * Closes popup, removes any state vars created during popup calls.\n   * @param popupWindow\n   */\n  cleanPopup(popupWindow) {\n    if (popupWindow) {\n      // Close window.\n      popupWindow.close();\n    }\n    // Remove window unload function\n    window.removeEventListener(\"beforeunload\", this.unloadWindow);\n    // Interaction is completed - remove interaction status.\n    this.browserStorage.setInteractionInProgress(false);\n  }\n  /**\n   * Generates the name for the popup based on the client id and request\n   * @param clientId\n   * @param request\n   */\n  generatePopupName(scopes, authority) {\n    return `${BrowserConstants.POPUP_NAME_PREFIX}.${this.config.auth.clientId}.${scopes.join(\"-\")}.${authority}.${this.correlationId}`;\n  }\n  /**\n   * Generates the name for the popup based on the client id and request for logouts\n   * @param clientId\n   * @param request\n   */\n  generateLogoutPopupName(request) {\n    const homeAccountId = request.account && request.account.homeAccountId;\n    return `${BrowserConstants.POPUP_NAME_PREFIX}.${this.config.auth.clientId}.${homeAccountId}.${this.correlationId}`;\n  }\n  /**\n   * Extracts the server response from the popup window\n   */\n  extractServerResponseStringFromPopup(popupWindow, href) {\n    let serverResponseString;\n    if (this.config.auth.OIDCOptions?.serverResponseType === ServerResponseType.QUERY) {\n      serverResponseString = UrlString.parseQueryServerResponse(href);\n    } else {\n      serverResponseString = popupWindow.location.hash;\n    }\n    return serverResponseString;\n  }\n}\nexport { PopupClient };","map":{"version":3,"names":["PopupClient","StandardInteractionClient","constructor","config","storageImpl","browserCrypto","logger","eventHandler","navigationClient","performanceClient","nativeStorageImpl","nativeMessageHandler","correlationId","unloadWindow","bind","nativeStorage","acquireToken","request","popupName","generatePopupName","scopes","OIDC_DEFAULT_SCOPES","authority","auth","system","asyncPopups","verbose","e","logout","logoutRequest","mainWindowRedirectUri","popupWindowAttributes","logoutPopupAsync","validLogoutRequest","undefined","popup","openSizedPopup","validRequest","initializeAuthorizationRequest","InteractionType","Popup","browserStorage","updateCacheEntries","state","nonce","loginHint","Constants","EMPTY_STRING","account","setPreQueueTime","PerformanceEvents","StandardInteractionClientInitializeAuthorizationCodeRequest","authCodeRequest","initializeAuthorizationCodeRequest","isNativeBroker","NativeMessageHandler","isNativeAvailable","authenticationScheme","startMeasurement","FetchAccountIdWithNativeBroker","interactionHandler","InteractionHandler","authClient","popupParameters"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\interaction_client\\PopupClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    CommonAuthorizationCodeRequest,\n    AuthorizationCodeClient,\n    ThrottlingUtils,\n    CommonEndSessionRequest,\n    UrlString,\n    AuthError,\n    OIDC_DEFAULT_SCOPES,\n    Constants,\n    ProtocolUtils,\n    ServerAuthorizationCodeResponse,\n    PerformanceEvents,\n    IPerformanceClient,\n    Logger,\n    ICrypto,\n    ProtocolMode,\n    ServerResponseType,\n} from \"@azure/msal-common\";\nimport { StandardInteractionClient } from \"./StandardInteractionClient\";\nimport { EventType } from \"../event/EventType\";\nimport {\n    InteractionType,\n    ApiId,\n    BrowserConstants,\n} from \"../utils/BrowserConstants\";\nimport { EndSessionPopupRequest } from \"../request/EndSessionPopupRequest\";\nimport { NavigationOptions } from \"../navigation/NavigationOptions\";\nimport { BrowserUtils } from \"../utils/BrowserUtils\";\nimport { PopupRequest } from \"../request/PopupRequest\";\nimport { NativeInteractionClient } from \"./NativeInteractionClient\";\nimport { NativeMessageHandler } from \"../broker/nativeBroker/NativeMessageHandler\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError\";\nimport { INavigationClient } from \"../navigation/INavigationClient\";\nimport { EventHandler } from \"../event/EventHandler\";\nimport { BrowserCacheManager } from \"../cache/BrowserCacheManager\";\nimport { BrowserConfiguration } from \"../config/Configuration\";\nimport {\n    InteractionHandler,\n    InteractionParams,\n} from \"../interaction_handler/InteractionHandler\";\nimport { PopupWindowAttributes } from \"../request/PopupWindowAttributes\";\nimport { EventError } from \"../event/EventMessage\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\n\nexport type PopupParams = InteractionParams & {\n    popup?: Window | null;\n    popupName: string;\n    popupWindowAttributes: PopupWindowAttributes;\n};\n\nexport class PopupClient extends StandardInteractionClient {\n    private currentWindow: Window | undefined;\n    protected nativeStorage: BrowserCacheManager;\n\n    constructor(\n        config: BrowserConfiguration,\n        storageImpl: BrowserCacheManager,\n        browserCrypto: ICrypto,\n        logger: Logger,\n        eventHandler: EventHandler,\n        navigationClient: INavigationClient,\n        performanceClient: IPerformanceClient,\n        nativeStorageImpl: BrowserCacheManager,\n        nativeMessageHandler?: NativeMessageHandler,\n        correlationId?: string\n    ) {\n        super(\n            config,\n            storageImpl,\n            browserCrypto,\n            logger,\n            eventHandler,\n            navigationClient,\n            performanceClient,\n            nativeMessageHandler,\n            correlationId\n        );\n        // Properly sets this reference for the unload event.\n        this.unloadWindow = this.unloadWindow.bind(this);\n        this.nativeStorage = nativeStorageImpl;\n    }\n\n    /**\n     * Acquires tokens by opening a popup window to the /authorize endpoint of the authority\n     * @param request\n     */\n    acquireToken(request: PopupRequest): Promise<AuthenticationResult> {\n        try {\n            const popupName = this.generatePopupName(\n                request.scopes || OIDC_DEFAULT_SCOPES,\n                request.authority || this.config.auth.authority\n            );\n            const popupWindowAttributes = request.popupWindowAttributes || {};\n\n            // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n            if (this.config.system.asyncPopups) {\n                this.logger.verbose(\"asyncPopups set to true, acquiring token\");\n                // Passes on popup position and dimensions if in request\n                return this.acquireTokenPopupAsync(\n                    request,\n                    popupName,\n                    popupWindowAttributes\n                );\n            } else {\n                // asyncPopups flag is set to false. Opens popup before acquiring token.\n                this.logger.verbose(\n                    \"asyncPopup set to false, opening popup before acquiring token\"\n                );\n                const popup = this.openSizedPopup(\n                    \"about:blank\",\n                    popupName,\n                    popupWindowAttributes\n                );\n                return this.acquireTokenPopupAsync(\n                    request,\n                    popupName,\n                    popupWindowAttributes,\n                    popup\n                );\n            }\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }\n\n    /**\n     * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server\n     * @param logoutRequest\n     */\n    logout(logoutRequest?: EndSessionPopupRequest): Promise<void> {\n        try {\n            this.logger.verbose(\"logoutPopup called\");\n            const validLogoutRequest =\n                this.initializeLogoutRequest(logoutRequest);\n\n            const popupName = this.generateLogoutPopupName(validLogoutRequest);\n            const authority = logoutRequest && logoutRequest.authority;\n            const mainWindowRedirectUri =\n                logoutRequest && logoutRequest.mainWindowRedirectUri;\n            const popupWindowAttributes =\n                logoutRequest?.popupWindowAttributes || {};\n\n            // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n            if (this.config.system.asyncPopups) {\n                this.logger.verbose(\"asyncPopups set to true\");\n                // Passes on popup position and dimensions if in request\n                return this.logoutPopupAsync(\n                    validLogoutRequest,\n                    popupName,\n                    popupWindowAttributes,\n                    authority,\n                    undefined,\n                    mainWindowRedirectUri\n                );\n            } else {\n                // asyncPopups flag is set to false. Opens popup before logging out.\n                this.logger.verbose(\"asyncPopup set to false, opening popup\");\n                const popup = this.openSizedPopup(\n                    \"about:blank\",\n                    popupName,\n                    popupWindowAttributes\n                );\n                return this.logoutPopupAsync(\n                    validLogoutRequest,\n                    popupName,\n                    popupWindowAttributes,\n                    authority,\n                    popup,\n                    mainWindowRedirectUri\n                );\n            }\n        } catch (e) {\n            // Since this function is synchronous we need to reject\n            return Promise.reject(e);\n        }\n    }\n\n    /**\n     * Helper which obtains an access_token for your API via opening a popup window in the user's browser\n     * @param validRequest\n     * @param popupName\n     * @param popup\n     * @param popupWindowAttributes\n     *\n     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\n     */\n    protected async acquireTokenPopupAsync(\n        request: PopupRequest,\n        popupName: string,\n        popupWindowAttributes: PopupWindowAttributes,\n        popup?: Window | null\n    ): Promise<AuthenticationResult> {\n        this.logger.verbose(\"acquireTokenPopupAsync called\");\n        const serverTelemetryManager = this.initializeServerTelemetryManager(\n            ApiId.acquireTokenPopup\n        );\n\n        this.performanceClient.setPreQueueTime(\n            PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest,\n            request.correlationId\n        );\n        const validRequest = await this.initializeAuthorizationRequest(\n            request,\n            InteractionType.Popup\n        );\n        this.browserStorage.updateCacheEntries(\n            validRequest.state,\n            validRequest.nonce,\n            validRequest.authority,\n            validRequest.loginHint || Constants.EMPTY_STRING,\n            validRequest.account || null\n        );\n\n        try {\n            // Create auth code request and generate PKCE params\n            this.performanceClient.setPreQueueTime(\n                PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest,\n                request.correlationId\n            );\n            const authCodeRequest: CommonAuthorizationCodeRequest =\n                await this.initializeAuthorizationCodeRequest(validRequest);\n\n            // Initialize the client\n            this.performanceClient.setPreQueueTime(\n                PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,\n                request.correlationId\n            );\n            const authClient: AuthorizationCodeClient =\n                await this.createAuthCodeClient(\n                    serverTelemetryManager,\n                    validRequest.authority,\n                    validRequest.azureCloudOptions\n                );\n            this.logger.verbose(\"Auth code client created\");\n\n            const isNativeBroker = NativeMessageHandler.isNativeAvailable(\n                this.config,\n                this.logger,\n                this.nativeMessageHandler,\n                request.authenticationScheme\n            );\n            // Start measurement for server calls with native brokering enabled\n            let fetchNativeAccountIdMeasurement;\n            if (isNativeBroker) {\n                fetchNativeAccountIdMeasurement =\n                    this.performanceClient.startMeasurement(\n                        PerformanceEvents.FetchAccountIdWithNativeBroker,\n                        request.correlationId\n                    );\n            }\n\n            // Create acquire token url.\n            const navigateUrl = await authClient.getAuthCodeUrl({\n                ...validRequest,\n                nativeBroker: isNativeBroker,\n            });\n\n            // Create popup interaction handler.\n            const interactionHandler = new InteractionHandler(\n                authClient,\n                this.browserStorage,\n                authCodeRequest,\n                this.logger,\n                this.performanceClient\n            );\n\n            // Show the UI once the url has been created. Get the window handle for the popup.\n            const popupParameters: PopupParams = {\n                popup,\n                popupName,\n                popupWindowAttributes,\n            };\n            const popupWindow: Window = this.initiateAuthRequest(\n                navigateUrl,\n                popupParameters\n            );\n            this.eventHandler.emitEvent(\n                EventType.POPUP_OPENED,\n                InteractionType.Popup,\n                { popupWindow },\n                null\n            );\n\n            // Monitor the window for the hash. Return the string value and close the popup when the hash is received. Default timeout is 60 seconds.\n            const hash = await this.monitorPopupForHash(popupWindow);\n            // Deserialize hash fragment response parameters.\n            const serverParams: ServerAuthorizationCodeResponse =\n                UrlString.getDeserializedHash(hash);\n            const state = this.validateAndExtractStateFromHash(\n                serverParams,\n                InteractionType.Popup,\n                validRequest.correlationId\n            );\n            // Remove throttle if it exists\n            ThrottlingUtils.removeThrottle(\n                this.browserStorage,\n                this.config.auth.clientId,\n                authCodeRequest\n            );\n\n            if (serverParams.accountId) {\n                this.logger.verbose(\n                    \"Account id found in hash, calling WAM for token\"\n                );\n                // end measurement for server call with native brokering enabled\n                if (fetchNativeAccountIdMeasurement) {\n                    fetchNativeAccountIdMeasurement.end({\n                        success: true,\n                        isNativeBroker: true,\n                    });\n                }\n\n                if (!this.nativeMessageHandler) {\n                    throw createBrowserAuthError(\n                        BrowserAuthErrorCodes.nativeConnectionNotEstablished\n                    );\n                }\n                const nativeInteractionClient = new NativeInteractionClient(\n                    this.config,\n                    this.browserStorage,\n                    this.browserCrypto,\n                    this.logger,\n                    this.eventHandler,\n                    this.navigationClient,\n                    ApiId.acquireTokenPopup,\n                    this.performanceClient,\n                    this.nativeMessageHandler,\n                    serverParams.accountId,\n                    this.nativeStorage,\n                    validRequest.correlationId\n                );\n                const { userRequestState } = ProtocolUtils.parseRequestState(\n                    this.browserCrypto,\n                    state\n                );\n                return nativeInteractionClient\n                    .acquireToken({\n                        ...validRequest,\n                        state: userRequestState,\n                        prompt: undefined, // Server should handle the prompt, ideally native broker can do this part silently\n                    })\n                    .finally(() => {\n                        this.browserStorage.cleanRequestByState(state);\n                    });\n            }\n\n            // Handle response from hash string.\n            const result = await interactionHandler.handleCodeResponseFromHash(\n                hash,\n                state,\n                authClient.authority,\n                this.networkClient\n            );\n\n            return result;\n        } catch (e) {\n            if (popup) {\n                // Close the synchronous popup if an error is thrown before the window unload event is registered\n                popup.close();\n            }\n\n            if (e instanceof AuthError) {\n                (e as AuthError).setCorrelationId(this.correlationId);\n                serverTelemetryManager.cacheFailedRequest(e);\n            }\n            this.browserStorage.cleanRequestByState(validRequest.state);\n            throw e;\n        }\n    }\n\n    /**\n     *\n     * @param validRequest\n     * @param popupName\n     * @param requestAuthority\n     * @param popup\n     * @param mainWindowRedirectUri\n     * @param popupWindowAttributes\n     */\n    protected async logoutPopupAsync(\n        validRequest: CommonEndSessionRequest,\n        popupName: string,\n        popupWindowAttributes: PopupWindowAttributes,\n        requestAuthority?: string,\n        popup?: Window | null,\n        mainWindowRedirectUri?: string\n    ): Promise<void> {\n        this.logger.verbose(\"logoutPopupAsync called\");\n        this.eventHandler.emitEvent(\n            EventType.LOGOUT_START,\n            InteractionType.Popup,\n            validRequest\n        );\n\n        const serverTelemetryManager = this.initializeServerTelemetryManager(\n            ApiId.logoutPopup\n        );\n\n        try {\n            // Clear cache on logout\n            await this.clearCacheOnLogout(validRequest.account);\n\n            // Initialize the client\n            this.performanceClient.setPreQueueTime(\n                PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,\n                validRequest.correlationId\n            );\n            const authClient = await this.createAuthCodeClient(\n                serverTelemetryManager,\n                requestAuthority\n            );\n            this.logger.verbose(\"Auth code client created\");\n\n            try {\n                authClient.authority.endSessionEndpoint;\n            } catch {\n                if (\n                    validRequest.account?.homeAccountId &&\n                    validRequest.postLogoutRedirectUri &&\n                    authClient.authority.protocolMode === ProtocolMode.OIDC\n                ) {\n                    void this.browserStorage.removeAccount(\n                        validRequest.account?.homeAccountId\n                    );\n\n                    this.eventHandler.emitEvent(\n                        EventType.LOGOUT_SUCCESS,\n                        InteractionType.Popup,\n                        validRequest\n                    );\n\n                    if (mainWindowRedirectUri) {\n                        const navigationOptions: NavigationOptions = {\n                            apiId: ApiId.logoutPopup,\n                            timeout:\n                                this.config.system.redirectNavigationTimeout,\n                            noHistory: false,\n                        };\n                        const absoluteUrl = UrlString.getAbsoluteUrl(\n                            mainWindowRedirectUri,\n                            BrowserUtils.getCurrentUri()\n                        );\n                        await this.navigationClient.navigateInternal(\n                            absoluteUrl,\n                            navigationOptions\n                        );\n                    }\n\n                    if (popup) {\n                        popup.close();\n                    }\n\n                    return;\n                }\n            }\n\n            // Create logout string and navigate user window to logout.\n            const logoutUri: string = authClient.getLogoutUri(validRequest);\n\n            this.eventHandler.emitEvent(\n                EventType.LOGOUT_SUCCESS,\n                InteractionType.Popup,\n                validRequest\n            );\n\n            // Open the popup window to requestUrl.\n            const popupWindow = this.openPopup(logoutUri, {\n                popupName,\n                popupWindowAttributes,\n                popup,\n            });\n            this.eventHandler.emitEvent(\n                EventType.POPUP_OPENED,\n                InteractionType.Popup,\n                { popupWindow },\n                null\n            );\n\n            await this.waitForLogoutPopup(popupWindow);\n\n            if (mainWindowRedirectUri) {\n                const navigationOptions: NavigationOptions = {\n                    apiId: ApiId.logoutPopup,\n                    timeout: this.config.system.redirectNavigationTimeout,\n                    noHistory: false,\n                };\n                const absoluteUrl = UrlString.getAbsoluteUrl(\n                    mainWindowRedirectUri,\n                    BrowserUtils.getCurrentUri()\n                );\n\n                this.logger.verbose(\n                    \"Redirecting main window to url specified in the request\"\n                );\n                this.logger.verbosePii(\n                    `Redirecting main window to: ${absoluteUrl}`\n                );\n                await this.navigationClient.navigateInternal(\n                    absoluteUrl,\n                    navigationOptions\n                );\n            } else {\n                this.logger.verbose(\"No main window navigation requested\");\n            }\n        } catch (e) {\n            if (popup) {\n                // Close the synchronous popup if an error is thrown before the window unload event is registered\n                popup.close();\n            }\n\n            if (e instanceof AuthError) {\n                (e as AuthError).setCorrelationId(this.correlationId);\n                serverTelemetryManager.cacheFailedRequest(e);\n            }\n            this.browserStorage.setInteractionInProgress(false);\n            this.eventHandler.emitEvent(\n                EventType.LOGOUT_FAILURE,\n                InteractionType.Popup,\n                null,\n                e as EventError\n            );\n            this.eventHandler.emitEvent(\n                EventType.LOGOUT_END,\n                InteractionType.Popup\n            );\n            throw e;\n        }\n\n        this.eventHandler.emitEvent(\n            EventType.LOGOUT_END,\n            InteractionType.Popup\n        );\n    }\n\n    /**\n     * Opens a popup window with given request Url.\n     * @param requestUrl\n     */\n    initiateAuthRequest(requestUrl: string, params: PopupParams): Window {\n        // Check that request url is not empty.\n        if (requestUrl) {\n            this.logger.infoPii(`Navigate to: ${requestUrl}`);\n            // Open the popup window to requestUrl.\n            return this.openPopup(requestUrl, params);\n        } else {\n            // Throw error if request URL is empty.\n            this.logger.error(\"Navigate url is empty\");\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.emptyNavigateUri\n            );\n        }\n    }\n\n    /**\n     * Monitors a window until it loads a url with the same origin.\n     * @param popupWindow - window that is being monitored\n     * @param timeout - timeout for processing hash once popup is redirected back to application\n     */\n    monitorPopupForHash(popupWindow: Window): Promise<string> {\n        return new Promise((resolve, reject) => {\n            /*\n             * Polling for popups needs to be tick-based,\n             * since a non-trivial amount of time can be spent on interaction (which should not count against the timeout).\n             */\n            const maxTicks =\n                this.config.system.windowHashTimeout /\n                this.config.system.pollIntervalMilliseconds;\n            let ticks = 0;\n\n            this.logger.verbose(\n                \"PopupHandler.monitorPopupForHash - polling started\"\n            );\n\n            const intervalId = setInterval(() => {\n                // Window is closed\n                if (popupWindow.closed) {\n                    this.logger.error(\n                        \"PopupHandler.monitorPopupForHash - window closed\"\n                    );\n                    this.cleanPopup();\n                    clearInterval(intervalId);\n                    reject(\n                        createBrowserAuthError(\n                            BrowserAuthErrorCodes.userCancelled\n                        )\n                    );\n                    return;\n                }\n\n                let href = Constants.EMPTY_STRING;\n                let serverResponseString = Constants.EMPTY_STRING;\n                try {\n                    /*\n                     * Will throw if cross origin,\n                     * which should be caught and ignored\n                     * since we need the interval to keep running while on STS UI.\n                     */\n                    href = popupWindow.location.href;\n                    serverResponseString =\n                        this.extractServerResponseStringFromPopup(\n                            popupWindow,\n                            href\n                        );\n                } catch (e) {}\n\n                // Don't process blank pages or cross domain\n                if (!href || href === \"about:blank\") {\n                    return;\n                }\n\n                this.logger.verbose(\n                    \"PopupHandler.monitorPopupForHash - popup window is on same origin as caller\"\n                );\n\n                /*\n                 * Only run clock when we are on same domain for popups\n                 * as popup operations can take a long time.\n                 */\n                ticks++;\n\n                if (serverResponseString) {\n                    this.logger.verbose(\n                        \"PopupHandler.monitorPopupForHash - found hash in url\"\n                    );\n                    clearInterval(intervalId);\n                    this.cleanPopup(popupWindow);\n\n                    if (\n                        UrlString.hashContainsKnownProperties(\n                            serverResponseString\n                        )\n                    ) {\n                        this.logger.verbose(\n                            \"PopupHandler.monitorPopupForHash - hash contains known properties, returning.\"\n                        );\n                        resolve(serverResponseString);\n                    } else {\n                        this.logger.error(\n                            \"PopupHandler.monitorPopupForHash - found hash in url but it does not contain known properties. Check that your router is not changing the hash prematurely.\"\n                        );\n                        this.logger.errorPii(\n                            `PopupHandler.monitorPopupForHash - hash found: ${serverResponseString}`\n                        );\n                        reject(\n                            createBrowserAuthError(\n                                BrowserAuthErrorCodes.hashDoesNotContainKnownProperties\n                            )\n                        );\n                    }\n                } else if (ticks > maxTicks) {\n                    this.logger.error(\n                        \"PopupHandler.monitorPopupForHash - unable to find hash in url, timing out\"\n                    );\n                    clearInterval(intervalId);\n                    reject(\n                        createBrowserAuthError(\n                            BrowserAuthErrorCodes.monitorPopupTimeout\n                        )\n                    );\n                }\n            }, this.config.system.pollIntervalMilliseconds);\n        });\n    }\n\n    /**\n     * Waits for user interaction in logout popup window\n     * @param popupWindow\n     * @returns\n     */\n    waitForLogoutPopup(popupWindow: Window): Promise<void> {\n        return new Promise((resolve) => {\n            this.logger.verbose(\n                \"PopupHandler.waitForLogoutPopup - polling started\"\n            );\n\n            const intervalId = setInterval(() => {\n                // Window is closed\n                if (popupWindow.closed) {\n                    this.logger.error(\n                        \"PopupHandler.waitForLogoutPopup - window closed\"\n                    );\n                    this.cleanPopup();\n                    clearInterval(intervalId);\n                    resolve();\n                }\n\n                let href: string = Constants.EMPTY_STRING;\n                try {\n                    /*\n                     * Will throw if cross origin,\n                     * which should be caught and ignored\n                     * since we need the interval to keep running while on STS UI.\n                     */\n                    href = popupWindow.location.href;\n                } catch (e) {}\n\n                // Don't process blank pages or cross domain\n                if (!href || href === \"about:blank\") {\n                    return;\n                }\n\n                this.logger.verbose(\n                    \"PopupHandler.waitForLogoutPopup - popup window is on same origin as caller, closing.\"\n                );\n\n                clearInterval(intervalId);\n                this.cleanPopup(popupWindow);\n                resolve();\n            }, this.config.system.pollIntervalMilliseconds);\n        });\n    }\n\n    /**\n     * @hidden\n     *\n     * Configures popup window for login.\n     *\n     * @param urlNavigate\n     * @param title\n     * @param popUpWidth\n     * @param popUpHeight\n     * @param popupWindowAttributes\n     * @ignore\n     * @hidden\n     */\n    openPopup(urlNavigate: string, popupParams: PopupParams): Window {\n        try {\n            let popupWindow;\n            // Popup window passed in, setting url to navigate to\n            if (popupParams.popup) {\n                popupWindow = popupParams.popup;\n                this.logger.verbosePii(\n                    `Navigating popup window to: ${urlNavigate}`\n                );\n                popupWindow.location.assign(urlNavigate);\n            } else if (typeof popupParams.popup === \"undefined\") {\n                // Popup will be undefined if it was not passed in\n                this.logger.verbosePii(\n                    `Opening popup window to: ${urlNavigate}`\n                );\n                popupWindow = this.openSizedPopup(\n                    urlNavigate,\n                    popupParams.popupName,\n                    popupParams.popupWindowAttributes\n                );\n            }\n\n            // Popup will be null if popups are blocked\n            if (!popupWindow) {\n                throw createBrowserAuthError(\n                    BrowserAuthErrorCodes.emptyWindowError\n                );\n            }\n            if (popupWindow.focus) {\n                popupWindow.focus();\n            }\n            this.currentWindow = popupWindow;\n            window.addEventListener(\"beforeunload\", this.unloadWindow);\n\n            return popupWindow;\n        } catch (e) {\n            this.logger.error(\n                \"error opening popup \" + (e as AuthError).message\n            );\n            this.browserStorage.setInteractionInProgress(false);\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.popupWindowError\n            );\n        }\n    }\n\n    /**\n     * Helper function to set popup window dimensions and position\n     * @param urlNavigate\n     * @param popupName\n     * @param popupWindowAttributes\n     * @returns\n     */\n    openSizedPopup(\n        urlNavigate: string,\n        popupName: string,\n        popupWindowAttributes: PopupWindowAttributes\n    ): Window | null {\n        /**\n         * adding winLeft and winTop to account for dual monitor\n         * using screenLeft and screenTop for IE8 and earlier\n         */\n        const winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n        const winTop = window.screenTop ? window.screenTop : window.screenY;\n        /**\n         * window.innerWidth displays browser window\"s height and width excluding toolbars\n         * using document.documentElement.clientWidth for IE8 and earlier\n         */\n        const winWidth =\n            window.innerWidth ||\n            document.documentElement.clientWidth ||\n            document.body.clientWidth;\n        const winHeight =\n            window.innerHeight ||\n            document.documentElement.clientHeight ||\n            document.body.clientHeight;\n\n        let width = popupWindowAttributes.popupSize?.width;\n        let height = popupWindowAttributes.popupSize?.height;\n        let top = popupWindowAttributes.popupPosition?.top;\n        let left = popupWindowAttributes.popupPosition?.left;\n\n        if (!width || width < 0 || width > winWidth) {\n            this.logger.verbose(\n                \"Default popup window width used. Window width not configured or invalid.\"\n            );\n            width = BrowserConstants.POPUP_WIDTH;\n        }\n\n        if (!height || height < 0 || height > winHeight) {\n            this.logger.verbose(\n                \"Default popup window height used. Window height not configured or invalid.\"\n            );\n            height = BrowserConstants.POPUP_HEIGHT;\n        }\n\n        if (!top || top < 0 || top > winHeight) {\n            this.logger.verbose(\n                \"Default popup window top position used. Window top not configured or invalid.\"\n            );\n            top = Math.max(\n                0,\n                winHeight / 2 - BrowserConstants.POPUP_HEIGHT / 2 + winTop\n            );\n        }\n\n        if (!left || left < 0 || left > winWidth) {\n            this.logger.verbose(\n                \"Default popup window left position used. Window left not configured or invalid.\"\n            );\n            left = Math.max(\n                0,\n                winWidth / 2 - BrowserConstants.POPUP_WIDTH / 2 + winLeft\n            );\n        }\n\n        return window.open(\n            urlNavigate,\n            popupName,\n            `width=${width}, height=${height}, top=${top}, left=${left}, scrollbars=yes`\n        );\n    }\n\n    /**\n     * Event callback to unload main window.\n     */\n    unloadWindow(e: Event): void {\n        this.browserStorage.cleanRequestByInteractionType(\n            InteractionType.Popup\n        );\n        if (this.currentWindow) {\n            this.currentWindow.close();\n        }\n        // Guarantees browser unload will happen, so no other errors will be thrown.\n        e.preventDefault();\n    }\n\n    /**\n     * Closes popup, removes any state vars created during popup calls.\n     * @param popupWindow\n     */\n    cleanPopup(popupWindow?: Window): void {\n        if (popupWindow) {\n            // Close window.\n            popupWindow.close();\n        }\n        // Remove window unload function\n        window.removeEventListener(\"beforeunload\", this.unloadWindow);\n\n        // Interaction is completed - remove interaction status.\n        this.browserStorage.setInteractionInProgress(false);\n    }\n\n    /**\n     * Generates the name for the popup based on the client id and request\n     * @param clientId\n     * @param request\n     */\n    generatePopupName(scopes: Array<string>, authority: string): string {\n        return `${BrowserConstants.POPUP_NAME_PREFIX}.${\n            this.config.auth.clientId\n        }.${scopes.join(\"-\")}.${authority}.${this.correlationId}`;\n    }\n\n    /**\n     * Generates the name for the popup based on the client id and request for logouts\n     * @param clientId\n     * @param request\n     */\n    generateLogoutPopupName(request: CommonEndSessionRequest): string {\n        const homeAccountId = request.account && request.account.homeAccountId;\n        return `${BrowserConstants.POPUP_NAME_PREFIX}.${this.config.auth.clientId}.${homeAccountId}.${this.correlationId}`;\n    }\n\n    /**\n     * Extracts the server response from the popup window\n     */\n    extractServerResponseStringFromPopup(\n        popupWindow: Window,\n        href: string\n    ): string {\n        let serverResponseString;\n        if (\n            this.config.auth.OIDCOptions?.serverResponseType ===\n            ServerResponseType.QUERY\n        ) {\n            serverResponseString = UrlString.parseQueryServerResponse(href);\n        } else {\n            serverResponseString = popupWindow.location.hash;\n        }\n        return serverResponseString;\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;AAKA;AAkBA;AAOA;AAGA;AAoBI,MAAcA,WAAA,SAAQC,yBAAA;EACtBC,WAAWA,CAAAC,MAAO,EAAAC,WAAA,EAAAC,aAAA,EAAAC,MAAA,EAAAC,YAAA,EAAAC,gBAAA,EAAAC,iBAAA,EAAAC,iBAAA,EAAAC,oBAAA,EAAAC,aAAA;IACG,MAAAT,MAAA,EAAAC,WAAA,EAAAC,aAAuB,EAACC,MAAA,EAAAC,YAAA,EAAAC,gBAAA,EAAAC,iBAAA,EAAAE,oBAAA,EAAAC,aAAA;;IAGpC,KAAAC,YAAA,OAAY,CAAAA,YAAiC,CAAAC,IAAA;IAC/C,IAAC,CAAAC,aAAkC,GAAAL,iBAAA;EAC1C;EAGI;AA2BJ;;;EAGGM,aAAAC,OAAA;IACS;MAuCZ,MAAAC,SAAA,QAAAC,iBAAA,CAAAF,OAAA,CAAAG,MAAA,IAAAC,mBAAA,EAAAJ,OAAA,CAAAK,SAAA,SAAAnB,MAAA,CAAAoB,IAAA,CAAAD,SAAA;;;MAGG,SAAAnB,MAAA,CAAAqB,MAAA,CAAAC,WAAA;mBACoB,CAAAC,OAAA,2CAAsC;QAgD7D;;;;;;;MAQG;MAyLH,OAAAC,CAAA;;;;;;;;EAQGC,OAAAC,aAAA;IACa;MA2JhB,KAAAvB,MAAA,CAAAoB,OAAA;;;MAGG,MAAAJ,SAAA,GAAAO,aAAA,IAAAA,aAAA,CAAAP,SAAA;MACgB,MAAAQ,qBAAa,GAAMD,aAAqB,IAAAA,aAAS,CAAAC,qBAAA;MAepE,MAAAC,qBAAA,GAAAF,aAAA,EAAAE,qBAAA;;;;QAIG;QACgB,YAAAC,gBAAA,CAAAC,kBAAsC,EAAAf,SAAA,EAAAa,qBAAA,EAAAT,SAAA,EAAAY,SAAA,EAAAJ,qBAAA;MA0GzD,O;;;QAIG,MAAAK,KAAA,QAAAC,cAAA,gBAAAlB,SAAA,EAAAa,qBAAA;QACe,OAAC,KAAAC,gBAAA,CAAsBC,kBAAa,EAAAf,SAAA,EAAAa,qBAAA,EAAAT,SAAA,EAAAa,KAAA,EAAAL,qBAAA;MA2CtD;;;;;;;;;;;AAYG;;AA+CH;;;;;;IAMG,MAAAO,YAAA,cAAAC,8BAAA,CAAArB,OAAA,EAAAsB,eAAA,CAAAC,KAAA;IACH,KAAAC,cACI,CAAAC,kBACS,CAAAL,YACT,CAAAM,KAAA,EAAAN,YAAA,CAAqBO,KAAE,EAAAP,YAAA,CAAAf,SACxB,EAAAe,YAAa,CAAAQ,SAAA,IAAAC,SAAA,CAAAC,YAAA,EAAAV,YAAA,CAAAW,OAAA;IAkEhB;;MAEG,KAAAvC,iBAAA,CAAAwC,eAAA,CAAAC,iBAAA,CAAAC,2DAAA,EAAAlC,OAAA,CAAAL,aAAA;MACH,MAAcwC,eAAc,cAAAC,kCAAA,CAAAhB,YAAA;MAW5B;;;MAGG,KAAA/B,MAAA,CAAAoB,OAAA;MACH,MAAsB4B,cAAG,GAAMC,oBAAO,CAAAC,iBAAA,MAAArD,MAAA,OAAAG,MAAA,OAAAK,oBAAA,EAAAM,OAAA,CAAAwC,oBAAA;MAYtC;;;0CAIG,KAAAhD,iBAAA,CAAAiD,gBAAA,CAAAR,iBAAA,CAAAS,8BAAA,EAAA1C,OAAA,CAAAL,aAAA;MACH;MAMA;;;;MAIG;MACH;MAKA,MAAAgD,kBAAA,OAAAC,kBAAA,CAAAC,UAAA,OAAArB,cAAA,EAAAW,eAAA,OAAA9C,MAAA,OAAAG,iBAAA;;MAEG,MAAAsD,eAAA;QACiC5B,KAAA;QAevCjB,SAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}