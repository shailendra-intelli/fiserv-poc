{"ast":null,"code":"/*! @azure/msal-common v14.4.0 2023-11-07 */\n'use strict';\n\nimport { Separators, CacheAccountType, Constants } from '../../utils/Constants.mjs';\nimport { buildClientInfo } from '../../account/ClientInfo.mjs';\nimport { createClientAuthError } from '../../error/ClientAuthError.mjs';\nimport { AuthorityType } from '../../authority/AuthorityType.mjs';\nimport { ProtocolMode } from '../../authority/ProtocolMode.mjs';\nimport { invalidCacheEnvironment } from '../../error/ClientAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\n *\n * Key : Value Schema\n *\n * Key: <home_account_id>-<environment>-<realm*>\n *\n * Value Schema:\n * {\n *      homeAccountId: home account identifier for the auth scheme,\n *      environment: entity that issued the token, represented as a full host\n *      realm: Full tenant or organizational identifier that the account belongs to\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\n *      authorityType: Accounts authority type as a string\n *      name: Full name for the account, including given name and family name,\n *      lastModificationTime: last time this entity was modified in the cache\n *      lastModificationApp:\n *      idTokenClaims: Object containing claims parsed from ID token\n *      nativeAccountId: Account identifier on the native device\n * }\n * @internal\n */\nclass AccountEntity {\n  /**\n   * Generate Account Id key component as per the schema: <home_account_id>-<environment>\n   */\n  generateAccountId() {\n    const accountId = [this.homeAccountId, this.environment];\n    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  }\n  /**\n   * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>\n   */\n  generateAccountKey() {\n    return AccountEntity.generateAccountCacheKey({\n      homeAccountId: this.homeAccountId,\n      environment: this.environment,\n      tenantId: this.realm,\n      username: this.username,\n      localAccountId: this.localAccountId\n    });\n  }\n  /**\n   * Returns the AccountInfo interface for this account.\n   */\n  getAccountInfo() {\n    return {\n      homeAccountId: this.homeAccountId,\n      environment: this.environment,\n      tenantId: this.realm,\n      username: this.username,\n      localAccountId: this.localAccountId,\n      name: this.name,\n      idTokenClaims: this.idTokenClaims,\n      nativeAccountId: this.nativeAccountId,\n      authorityType: this.authorityType\n    };\n  }\n  /**\n   * Generates account key from interface\n   * @param accountInterface\n   */\n  static generateAccountCacheKey(accountInterface) {\n    const accountKey = [accountInterface.homeAccountId, accountInterface.environment || Constants.EMPTY_STRING, accountInterface.tenantId || Constants.EMPTY_STRING];\n    return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  }\n  /**\n   * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.\n   * @param accountDetails\n   */\n  static createAccount(accountDetails, authority) {\n    const account = new AccountEntity();\n    if (authority.authorityType === AuthorityType.Adfs) {\n      account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;\n    } else if (authority.protocolMode === ProtocolMode.AAD) {\n      account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\n    } else {\n      account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;\n    }\n    account.clientInfo = accountDetails.clientInfo;\n    account.homeAccountId = accountDetails.homeAccountId;\n    account.nativeAccountId = accountDetails.nativeAccountId;\n    const env = accountDetails.environment || authority && authority.getPreferredCache();\n    if (!env) {\n      throw createClientAuthError(invalidCacheEnvironment);\n    }\n    account.environment = env;\n    // non AAD scenarios can have empty realm\n    account.realm = accountDetails.idTokenClaims.tid || Constants.EMPTY_STRING;\n    // How do you account for MSA CID here?\n    account.localAccountId = accountDetails.idTokenClaims.oid || accountDetails.idTokenClaims.sub || Constants.EMPTY_STRING;\n    /*\n     * In B2C scenarios the emails claim is used instead of preferred_username and it is an array.\n     * In most cases it will contain a single email. This field should not be relied upon if a custom\n     * policy is configured to return more than 1 email.\n     */\n    const preferredUsername = accountDetails.idTokenClaims.preferred_username || accountDetails.idTokenClaims.upn;\n    const email = accountDetails.idTokenClaims.emails ? accountDetails.idTokenClaims.emails[0] : null;\n    account.username = preferredUsername || email || Constants.EMPTY_STRING;\n    account.name = accountDetails.idTokenClaims.name;\n    account.cloudGraphHostName = accountDetails.cloudGraphHostName;\n    account.msGraphHost = accountDetails.msGraphHost;\n    return account;\n  }\n  /**\n   * Creates an AccountEntity object from AccountInfo\n   * @param accountInfo\n   * @param cloudGraphHostName\n   * @param msGraphHost\n   * @returns\n   */\n  static createFromAccountInfo(accountInfo, cloudGraphHostName, msGraphHost) {\n    const account = new AccountEntity();\n    account.authorityType = accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;\n    account.homeAccountId = accountInfo.homeAccountId;\n    account.localAccountId = accountInfo.localAccountId;\n    account.nativeAccountId = accountInfo.nativeAccountId;\n    account.realm = accountInfo.tenantId;\n    account.environment = accountInfo.environment;\n    account.username = accountInfo.username;\n    account.name = accountInfo.name;\n    account.cloudGraphHostName = cloudGraphHostName;\n    account.msGraphHost = msGraphHost;\n    return account;\n  }\n  /**\n   * Generate HomeAccountId from server response\n   * @param serverClientInfo\n   * @param authType\n   */\n  static generateHomeAccountId(serverClientInfo, authType, logger, cryptoObj, idTokenClaims) {\n    const accountId = idTokenClaims?.sub ? idTokenClaims.sub : Constants.EMPTY_STRING;\n    // since ADFS does not have tid and does not set client_info\n    if (authType === AuthorityType.Adfs || authType === AuthorityType.Dsts) {\n      return accountId;\n    }\n    // for cases where there is clientInfo\n    if (serverClientInfo) {\n      try {\n        const clientInfo = buildClientInfo(serverClientInfo, cryptoObj);\n        if (clientInfo.uid && clientInfo.utid) {\n          return `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`;\n        }\n      } catch (e) {}\n    }\n    // default to \"sub\" claim\n    logger.verbose(\"No client info in response\");\n    return accountId;\n  }\n  /**\n   * Validates an entity: checks for all expected params\n   * @param entity\n   */\n  static isAccountEntity(entity) {\n    if (!entity) {\n      return false;\n    }\n    return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"localAccountId\") && entity.hasOwnProperty(\"username\") && entity.hasOwnProperty(\"authorityType\");\n  }\n  /**\n   * Helper function to determine whether 2 accountInfo objects represent the same account\n   * @param accountA\n   * @param accountB\n   * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality\n   */\n  static accountInfoIsEqual(accountA, accountB, compareClaims) {\n    if (!accountA || !accountB) {\n      return false;\n    }\n    let claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false\n    if (compareClaims) {\n      const accountAClaims = accountA.idTokenClaims || {};\n      const accountBClaims = accountB.idTokenClaims || {};\n      // issued at timestamp and nonce are expected to change each time a new id token is acquired\n      claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;\n    }\n    return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;\n  }\n}\nexport { AccountEntity };","map":{"version":3,"names":["AccountEntity","generateAccountId","accountId","homeAccountId","environment","join","Separators","CACHE_KEY_SEPARATOR","toLowerCase","generateAccountKey","generateAccountCacheKey","tenantId","realm","username","getAccountInfo","localAccountId","nativeAccountId","authorityType","accountInterface","accountKey","authority","AuthorityType","Adfs","account","CacheAccountType","ADFS_ACCOUNT_TYPE","GENERIC_ACCOUNT_TYPE","env","accountDetails","getPreferredCache"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-common\\src\\cache\\entities\\AccountEntity.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Separators, CacheAccountType, Constants } from \"../../utils/Constants\";\nimport { Authority } from \"../../authority/Authority\";\nimport { ICrypto } from \"../../crypto/ICrypto\";\nimport { buildClientInfo } from \"../../account/ClientInfo\";\nimport { AccountInfo } from \"../../account/AccountInfo\";\nimport {\n    createClientAuthError,\n    ClientAuthErrorCodes,\n} from \"../../error/ClientAuthError\";\nimport { AuthorityType } from \"../../authority/AuthorityType\";\nimport { Logger } from \"../../logger/Logger\";\nimport { TokenClaims } from \"../../account/TokenClaims\";\nimport { ProtocolMode } from \"../../authority/ProtocolMode\";\n\n/**\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\n *\n * Key : Value Schema\n *\n * Key: <home_account_id>-<environment>-<realm*>\n *\n * Value Schema:\n * {\n *      homeAccountId: home account identifier for the auth scheme,\n *      environment: entity that issued the token, represented as a full host\n *      realm: Full tenant or organizational identifier that the account belongs to\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\n *      authorityType: Accounts authority type as a string\n *      name: Full name for the account, including given name and family name,\n *      lastModificationTime: last time this entity was modified in the cache\n *      lastModificationApp:\n *      idTokenClaims: Object containing claims parsed from ID token\n *      nativeAccountId: Account identifier on the native device\n * }\n * @internal\n */\nexport class AccountEntity {\n    homeAccountId: string;\n    environment: string;\n    realm: string;\n    localAccountId: string;\n    username: string;\n    authorityType: string;\n    clientInfo?: string;\n    name?: string;\n    lastModificationTime?: string;\n    lastModificationApp?: string;\n    cloudGraphHostName?: string;\n    msGraphHost?: string;\n    idTokenClaims?: TokenClaims;\n    nativeAccountId?: string;\n\n    /**\n     * Generate Account Id key component as per the schema: <home_account_id>-<environment>\n     */\n    generateAccountId(): string {\n        const accountId: Array<string> = [this.homeAccountId, this.environment];\n        return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n    }\n\n    /**\n     * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>\n     */\n    generateAccountKey(): string {\n        return AccountEntity.generateAccountCacheKey({\n            homeAccountId: this.homeAccountId,\n            environment: this.environment,\n            tenantId: this.realm,\n            username: this.username,\n            localAccountId: this.localAccountId,\n        });\n    }\n\n    /**\n     * Returns the AccountInfo interface for this account.\n     */\n    getAccountInfo(): AccountInfo {\n        return {\n            homeAccountId: this.homeAccountId,\n            environment: this.environment,\n            tenantId: this.realm,\n            username: this.username,\n            localAccountId: this.localAccountId,\n            name: this.name,\n            idTokenClaims: this.idTokenClaims,\n            nativeAccountId: this.nativeAccountId,\n            authorityType: this.authorityType,\n        };\n    }\n\n    /**\n     * Generates account key from interface\n     * @param accountInterface\n     */\n    static generateAccountCacheKey(accountInterface: AccountInfo): string {\n        const accountKey = [\n            accountInterface.homeAccountId,\n            accountInterface.environment || Constants.EMPTY_STRING,\n            accountInterface.tenantId || Constants.EMPTY_STRING,\n        ];\n\n        return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n    }\n\n    /**\n     * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.\n     * @param accountDetails\n     */\n    static createAccount(\n        accountDetails: {\n            homeAccountId: string;\n            idTokenClaims: TokenClaims;\n            clientInfo?: string;\n            cloudGraphHostName?: string;\n            msGraphHost?: string;\n            environment?: string;\n            nativeAccountId?: string;\n        },\n        authority: Authority\n    ): AccountEntity {\n        const account: AccountEntity = new AccountEntity();\n\n        if (authority.authorityType === AuthorityType.Adfs) {\n            account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;\n        } else if (authority.protocolMode === ProtocolMode.AAD) {\n            account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\n        } else {\n            account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;\n        }\n\n        account.clientInfo = accountDetails.clientInfo;\n        account.homeAccountId = accountDetails.homeAccountId;\n        account.nativeAccountId = accountDetails.nativeAccountId;\n\n        const env =\n            accountDetails.environment ||\n            (authority && authority.getPreferredCache());\n\n        if (!env) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.invalidCacheEnvironment\n            );\n        }\n\n        account.environment = env;\n        // non AAD scenarios can have empty realm\n        account.realm =\n            accountDetails.idTokenClaims.tid || Constants.EMPTY_STRING;\n\n        // How do you account for MSA CID here?\n        account.localAccountId =\n            accountDetails.idTokenClaims.oid ||\n            accountDetails.idTokenClaims.sub ||\n            Constants.EMPTY_STRING;\n\n        /*\n         * In B2C scenarios the emails claim is used instead of preferred_username and it is an array.\n         * In most cases it will contain a single email. This field should not be relied upon if a custom\n         * policy is configured to return more than 1 email.\n         */\n        const preferredUsername =\n            accountDetails.idTokenClaims.preferred_username ||\n            accountDetails.idTokenClaims.upn;\n        const email = accountDetails.idTokenClaims.emails\n            ? accountDetails.idTokenClaims.emails[0]\n            : null;\n\n        account.username = preferredUsername || email || Constants.EMPTY_STRING;\n        account.name = accountDetails.idTokenClaims.name;\n\n        account.cloudGraphHostName = accountDetails.cloudGraphHostName;\n        account.msGraphHost = accountDetails.msGraphHost;\n\n        return account;\n    }\n\n    /**\n     * Creates an AccountEntity object from AccountInfo\n     * @param accountInfo\n     * @param cloudGraphHostName\n     * @param msGraphHost\n     * @returns\n     */\n    static createFromAccountInfo(\n        accountInfo: AccountInfo,\n        cloudGraphHostName?: string,\n        msGraphHost?: string\n    ): AccountEntity {\n        const account: AccountEntity = new AccountEntity();\n\n        account.authorityType =\n            accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;\n        account.homeAccountId = accountInfo.homeAccountId;\n        account.localAccountId = accountInfo.localAccountId;\n        account.nativeAccountId = accountInfo.nativeAccountId;\n\n        account.realm = accountInfo.tenantId;\n        account.environment = accountInfo.environment;\n\n        account.username = accountInfo.username;\n        account.name = accountInfo.name;\n\n        account.cloudGraphHostName = cloudGraphHostName;\n        account.msGraphHost = msGraphHost;\n\n        return account;\n    }\n\n    /**\n     * Generate HomeAccountId from server response\n     * @param serverClientInfo\n     * @param authType\n     */\n    static generateHomeAccountId(\n        serverClientInfo: string,\n        authType: AuthorityType,\n        logger: Logger,\n        cryptoObj: ICrypto,\n        idTokenClaims?: TokenClaims\n    ): string {\n        const accountId = idTokenClaims?.sub\n            ? idTokenClaims.sub\n            : Constants.EMPTY_STRING;\n\n        // since ADFS does not have tid and does not set client_info\n        if (\n            authType === AuthorityType.Adfs ||\n            authType === AuthorityType.Dsts\n        ) {\n            return accountId;\n        }\n\n        // for cases where there is clientInfo\n        if (serverClientInfo) {\n            try {\n                const clientInfo = buildClientInfo(serverClientInfo, cryptoObj);\n                if (clientInfo.uid && clientInfo.utid) {\n                    return `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`;\n                }\n            } catch (e) {}\n        }\n\n        // default to \"sub\" claim\n        logger.verbose(\"No client info in response\");\n        return accountId;\n    }\n\n    /**\n     * Validates an entity: checks for all expected params\n     * @param entity\n     */\n    static isAccountEntity(entity: object): boolean {\n        if (!entity) {\n            return false;\n        }\n\n        return (\n            entity.hasOwnProperty(\"homeAccountId\") &&\n            entity.hasOwnProperty(\"environment\") &&\n            entity.hasOwnProperty(\"realm\") &&\n            entity.hasOwnProperty(\"localAccountId\") &&\n            entity.hasOwnProperty(\"username\") &&\n            entity.hasOwnProperty(\"authorityType\")\n        );\n    }\n\n    /**\n     * Helper function to determine whether 2 accountInfo objects represent the same account\n     * @param accountA\n     * @param accountB\n     * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality\n     */\n    static accountInfoIsEqual(\n        accountA: AccountInfo | null,\n        accountB: AccountInfo | null,\n        compareClaims?: boolean\n    ): boolean {\n        if (!accountA || !accountB) {\n            return false;\n        }\n\n        let claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false\n        if (compareClaims) {\n            const accountAClaims = (accountA.idTokenClaims ||\n                {}) as TokenClaims;\n            const accountBClaims = (accountB.idTokenClaims ||\n                {}) as TokenClaims;\n\n            // issued at timestamp and nonce are expected to change each time a new id token is acquired\n            claimsMatch =\n                accountAClaims.iat === accountBClaims.iat &&\n                accountAClaims.nonce === accountBClaims.nonce;\n        }\n\n        return (\n            accountA.homeAccountId === accountB.homeAccountId &&\n            accountA.localAccountId === accountB.localAccountId &&\n            accountA.username === accountB.username &&\n            accountA.tenantId === accountB.tenantId &&\n            accountA.environment === accountB.environment &&\n            accountA.nativeAccountId === accountB.nativeAccountId &&\n            claimsMatch\n        );\n    }\n}\n"],"mappings":";;;;;;;;;;AAMA;AACA;AAEA;AAKA;;;;;;;;;;;;;;;;;;;;AA2BG;AACH;;;AAGS,MAAAA,aAAS;;;;EAIdC,iBAAaA,CAAA,EAAO;IAChB,MAAGC,SAAO,SAAAC,aAAA,OAAAC,WAAA;IACM,OAAAF,SAAA,CAACG,IAAE,CAAAC,UAAO,CAAAC,mBAAA,EAAAC,WAAA;;;;;EAK9BC,kBAAkBA,CAAA;IAElB,OAAAT,aAAA,CAAAU,uBAAA;;MAEGN,WAAA,OAAAA,WAAA;MACHO,QAAA,MAA2B,CAAAC,KAAA;MAK3BC,QAAA,OAAAA,QAAA;;IAEG;EACH;EAUA;;AAEG;EACHC,cAAcA,CAAA;IAcd;;;MAGGH,QAAA,OAAAC,KAAA;MAC2BC,QAAA,OAAAA,QAAC;MAU/BE,cAAA,OAAAA,cAAA;;;MAGGC,eAAA,OAAAA,eAAA;MACIC,aACH,OAAAA;KACiB;;;;;;SAMEP,uBAAUA,CAAAQ,gBAAA;IAEpB,MAAAC,UAAW,IA0DxBD,gBAAA,CAAAf,aAAA,E;;;EAMG;AACH;AAyBA;;;;IAIG,IAAAiB,SAAA,CAAAH,aAAA,KAAAI,aAAA,CAAAC,IAAA;MACyBC,OAAA,CAAAN,aACxB,GAAgBO,gBAAA,CAAAC,iBACN;IAgCd,O;;IAGG,OACmB;MAetBF,OAAA,CAAAN,aAAA,GAAAO,gBAAA,CAAAE,oBAAA;;;;;IAKG,MAAAC,GAAA,GAAAC,cAAA,CAAAxB,WAAA,I,sBAEC,CAAAyB,iBAAqB;IA+B5B,KAAAF,GAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}