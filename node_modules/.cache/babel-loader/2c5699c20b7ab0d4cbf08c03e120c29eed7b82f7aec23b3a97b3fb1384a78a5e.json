{"ast":null,"code":"/*! @azure/msal-common v14.0.3 2023-09-05 */\n'use strict';\n\nimport { isOidcProtocolMode } from '../config/ClientConfiguration.mjs';\nimport { BaseClient } from './BaseClient.mjs';\nimport { RequestParameterBuilder } from '../request/RequestParameterBuilder.mjs';\nimport { GrantType, AuthenticationScheme, HeaderNames, Errors } from '../utils/Constants.mjs';\nimport { ResponseHandler } from '../response/ResponseHandler.mjs';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.mjs';\nimport { StringUtils } from '../utils/StringUtils.mjs';\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.mjs';\nimport { ClientAuthError } from '../error/ClientAuthError.mjs';\nimport { ServerError } from '../error/ServerError.mjs';\nimport { TimeUtils } from '../utils/TimeUtils.mjs';\nimport { UrlString } from '../url/UrlString.mjs';\nimport { CcsCredentialType } from '../account/CcsCredential.mjs';\nimport { buildClientInfoFromHomeAccountId } from '../account/ClientInfo.mjs';\nimport { InteractionRequiredAuthError, InteractionRequiredAuthErrorMessage } from '../error/InteractionRequiredAuthError.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * OAuth2.0 refresh token client\n * @internal\n */\nclass RefreshTokenClient extends BaseClient {\n  constructor(configuration, performanceClient) {\n    super(configuration, performanceClient);\n  }\n  async acquireToken(request) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request.correlationId);\n    const atsMeasurement = this.performanceClient?.startMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request.correlationId);\n    this.logger.verbose(\"RefreshTokenClientAcquireToken called\", request.correlationId);\n    const reqTimestamp = TimeUtils.nowSeconds();\n    this.performanceClient?.setPreQueueTime(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);\n    const response = await this.executeTokenRequest(request, this.authority);\n    // Retrieve requestId from response headers\n    const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];\n    const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);\n    responseHandler.validateTokenResponse(response.body);\n    this.performanceClient?.setPreQueueTime(PerformanceEvents.HandleServerTokenResponse, request.correlationId);\n    return responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, undefined, undefined, true, request.forceCache, requestId).then(result => {\n      atsMeasurement?.end({\n        success: true\n      });\n      return result;\n    }).catch(error => {\n      this.logger.verbose(\"Error in fetching refresh token\", request.correlationId);\n      atsMeasurement?.end({\n        errorCode: error.errorCode,\n        subErrorCode: error.subError,\n        success: false\n      });\n      throw error;\n    });\n  }\n  /**\n   * Gets cached refresh token and attaches to request, then calls acquireToken API\n   * @param request\n   */\n  async acquireTokenByRefreshToken(request) {\n    // Cannot renew token if no request object is given.\n    if (!request) {\n      throw ClientConfigurationError.createEmptyTokenRequestError();\n    }\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, request.correlationId);\n    // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n    if (!request.account) {\n      throw ClientAuthError.createNoAccountInSilentRequestError();\n    }\n    // try checking if FOCI is enabled for the given application\n    const isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment);\n    // if the app is part of the family, retrive a Family refresh token if present and make a refreshTokenRequest\n    if (isFOCI) {\n      try {\n        this.performanceClient?.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);\n        return this.acquireTokenWithCachedRefreshToken(request, true);\n      } catch (e) {\n        const noFamilyRTInCache = e instanceof InteractionRequiredAuthError && e.errorCode === InteractionRequiredAuthErrorMessage.noTokensFoundError.code;\n        const clientMismatchErrorWithFamilyRT = e instanceof ServerError && e.errorCode === Errors.INVALID_GRANT_ERROR && e.subError === Errors.CLIENT_MISMATCH_ERROR;\n        // if family Refresh Token (FRT) cache acquisition fails or if client_mismatch error is seen with FRT, reattempt with application Refresh Token (ART)\n        if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {\n          this.performanceClient?.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);\n          return this.acquireTokenWithCachedRefreshToken(request, false);\n          // throw in all other cases\n        } else {\n          throw e;\n        }\n      }\n    }\n    // fall back to application refresh token acquisition\n    this.performanceClient?.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);\n    return this.acquireTokenWithCachedRefreshToken(request, false);\n  }\n  /**\n   * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached\n   * @param request\n   */\n  async acquireTokenWithCachedRefreshToken(request, foci) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);\n    // fetches family RT or application RT based on FOCI value\n    const atsMeasurement = this.performanceClient?.startMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);\n    this.logger.verbose(\"RefreshTokenClientAcquireTokenWithCachedRefreshToken called\", request.correlationId);\n    const refreshToken = this.cacheManager.getRefreshToken(request.account, foci);\n    if (!refreshToken) {\n      atsMeasurement?.discard();\n      throw InteractionRequiredAuthError.createNoTokensFoundError();\n    }\n    // attach cached RT size to the current measurement\n    atsMeasurement?.end({\n      success: true\n    });\n    const refreshTokenRequest = {\n      ...request,\n      refreshToken: refreshToken.secret,\n      authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,\n      ccsCredential: {\n        credential: request.account.homeAccountId,\n        type: CcsCredentialType.HOME_ACCOUNT_ID\n      }\n    };\n    this.performanceClient?.setPreQueueTime(PerformanceEvents.RefreshTokenClientAcquireToken, request.correlationId);\n    return this.acquireToken(refreshTokenRequest);\n  }\n  /**\n   * Constructs the network message and makes a NW call to the underlying secure token service\n   * @param request\n   * @param authority\n   */\n  async executeTokenRequest(request, authority) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);\n    const acquireTokenMeasurement = this.performanceClient?.startMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);\n    this.performanceClient?.setPreQueueTime(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, request.correlationId);\n    const queryParametersString = this.createTokenQueryParameters(request);\n    const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\n    const requestBody = await this.createTokenRequestBody(request);\n    const headers = this.createTokenRequestHeaders(request.ccsCredential);\n    const thumbprint = {\n      clientId: this.config.authOptions.clientId,\n      authority: authority.canonicalAuthority,\n      scopes: request.scopes,\n      claims: request.claims,\n      authenticationScheme: request.authenticationScheme,\n      resourceRequestMethod: request.resourceRequestMethod,\n      resourceRequestUri: request.resourceRequestUri,\n      shrClaims: request.shrClaims,\n      sshKid: request.sshKid\n    };\n    return this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId).then(result => {\n      acquireTokenMeasurement?.end({\n        success: true\n      });\n      return result;\n    }).catch(error => {\n      acquireTokenMeasurement?.end({\n        success: false\n      });\n      throw error;\n    });\n  }\n  /**\n   * Helper function to create the token request body\n   * @param request\n   */\n  async createTokenRequestBody(request) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, request.correlationId);\n    const correlationId = request.correlationId;\n    const acquireTokenMeasurement = this.performanceClient?.startMeasurement(PerformanceEvents.BaseClientCreateTokenRequestHeaders, correlationId);\n    const parameterBuilder = new RequestParameterBuilder();\n    parameterBuilder.addClientId(this.config.authOptions.clientId);\n    parameterBuilder.addScopes(request.scopes, true, this.config.authOptions.authority.options.OIDCOptions?.defaultScopes);\n    parameterBuilder.addGrantType(GrantType.REFRESH_TOKEN_GRANT);\n    parameterBuilder.addClientInfo();\n    parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n    parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\n    parameterBuilder.addThrottling();\n    if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {\n      parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n    }\n    parameterBuilder.addCorrelationId(correlationId);\n    parameterBuilder.addRefreshToken(request.refreshToken);\n    if (this.config.clientCredentials.clientSecret) {\n      parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\n    }\n    if (this.config.clientCredentials.clientAssertion) {\n      const clientAssertion = this.config.clientCredentials.clientAssertion;\n      parameterBuilder.addClientAssertion(clientAssertion.assertion);\n      parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\n    }\n    if (request.authenticationScheme === AuthenticationScheme.POP) {\n      const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);\n      this.performanceClient?.setPreQueueTime(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);\n      const reqCnfData = await popTokenGenerator.generateCnf(request);\n      // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\n      parameterBuilder.addPopToken(reqCnfData.reqCnfString);\n    } else if (request.authenticationScheme === AuthenticationScheme.SSH) {\n      if (request.sshJwk) {\n        parameterBuilder.addSshJwk(request.sshJwk);\n      } else {\n        acquireTokenMeasurement?.end({\n          success: false\n        });\n        throw ClientConfigurationError.createMissingSshJwkError();\n      }\n    }\n    if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n      parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n    }\n    if (this.config.systemOptions.preventCorsPreflight && request.ccsCredential) {\n      switch (request.ccsCredential.type) {\n        case CcsCredentialType.HOME_ACCOUNT_ID:\n          try {\n            const clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);\n            parameterBuilder.addCcsOid(clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n          }\n          break;\n        case CcsCredentialType.UPN:\n          parameterBuilder.addCcsUpn(request.ccsCredential.credential);\n          break;\n      }\n    }\n    acquireTokenMeasurement?.end({\n      success: true\n    });\n    return parameterBuilder.createQueryString();\n  }\n}\nexport { RefreshTokenClient };","map":{"version":3,"names":["acquireToken","request","performanceClient","addQueueMeasurement","PerformanceEvents","RefreshTokenClientAcquireToken","correlationId","reqTimestamp","TimeUtils","nowSeconds","setPreQueueTime","RefreshTokenClientExecuteTokenRequest","response","executeTokenRequest","authority"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-common\\src\\client\\RefreshTokenClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    ClientConfiguration,\n    isOidcProtocolMode,\n} from \"../config/ClientConfiguration\";\nimport { BaseClient } from \"./BaseClient\";\nimport { CommonRefreshTokenRequest } from \"../request/CommonRefreshTokenRequest\";\nimport { Authority } from \"../authority/Authority\";\nimport { ServerAuthorizationTokenResponse } from \"../response/ServerAuthorizationTokenResponse\";\nimport { RequestParameterBuilder } from \"../request/RequestParameterBuilder\";\nimport {\n    GrantType,\n    AuthenticationScheme,\n    Errors,\n    HeaderNames,\n} from \"../utils/Constants\";\nimport { ResponseHandler } from \"../response/ResponseHandler\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator\";\nimport { StringUtils } from \"../utils/StringUtils\";\nimport { RequestThumbprint } from \"../network/RequestThumbprint\";\nimport { NetworkResponse } from \"../network/NetworkManager\";\nimport { CommonSilentFlowRequest } from \"../request/CommonSilentFlowRequest\";\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\nimport { ServerError } from \"../error/ServerError\";\nimport { TimeUtils } from \"../utils/TimeUtils\";\nimport { UrlString } from \"../url/UrlString\";\nimport { CcsCredentialType } from \"../account/CcsCredential\";\nimport { buildClientInfoFromHomeAccountId } from \"../account/ClientInfo\";\nimport {\n    InteractionRequiredAuthError,\n    InteractionRequiredAuthErrorMessage,\n} from \"../error/InteractionRequiredAuthError\";\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\n/**\n * OAuth2.0 refresh token client\n * @internal\n */\nexport class RefreshTokenClient extends BaseClient {\n    constructor(\n        configuration: ClientConfiguration,\n        performanceClient?: IPerformanceClient\n    ) {\n        super(configuration, performanceClient);\n    }\n    public async acquireToken(\n        request: CommonRefreshTokenRequest\n    ): Promise<AuthenticationResult> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RefreshTokenClientAcquireToken,\n            request.correlationId\n        );\n\n        const atsMeasurement = this.performanceClient?.startMeasurement(\n            PerformanceEvents.RefreshTokenClientAcquireToken,\n            request.correlationId\n        );\n        this.logger.verbose(\n            \"RefreshTokenClientAcquireToken called\",\n            request.correlationId\n        );\n        const reqTimestamp = TimeUtils.nowSeconds();\n        this.performanceClient?.setPreQueueTime(\n            PerformanceEvents.RefreshTokenClientExecuteTokenRequest,\n            request.correlationId\n        );\n        const response = await this.executeTokenRequest(\n            request,\n            this.authority\n        );\n\n        // Retrieve requestId from response headers\n        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];\n        const responseHandler = new ResponseHandler(\n            this.config.authOptions.clientId,\n            this.cacheManager,\n            this.cryptoUtils,\n            this.logger,\n            this.config.serializableCache,\n            this.config.persistencePlugin\n        );\n        responseHandler.validateTokenResponse(response.body);\n\n        this.performanceClient?.setPreQueueTime(\n            PerformanceEvents.HandleServerTokenResponse,\n            request.correlationId\n        );\n        return responseHandler\n            .handleServerTokenResponse(\n                response.body,\n                this.authority,\n                reqTimestamp,\n                request,\n                undefined,\n                undefined,\n                true,\n                request.forceCache,\n                requestId\n            )\n            .then((result: AuthenticationResult) => {\n                atsMeasurement?.end({\n                    success: true,\n                });\n                return result;\n            })\n            .catch((error) => {\n                this.logger.verbose(\n                    \"Error in fetching refresh token\",\n                    request.correlationId\n                );\n                atsMeasurement?.end({\n                    errorCode: error.errorCode,\n                    subErrorCode: error.subError,\n                    success: false,\n                });\n                throw error;\n            });\n    }\n\n    /**\n     * Gets cached refresh token and attaches to request, then calls acquireToken API\n     * @param request\n     */\n    public async acquireTokenByRefreshToken(\n        request: CommonSilentFlowRequest\n    ): Promise<AuthenticationResult> {\n        // Cannot renew token if no request object is given.\n        if (!request) {\n            throw ClientConfigurationError.createEmptyTokenRequestError();\n        }\n\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken,\n            request.correlationId\n        );\n\n        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n        if (!request.account) {\n            throw ClientAuthError.createNoAccountInSilentRequestError();\n        }\n\n        // try checking if FOCI is enabled for the given application\n        const isFOCI = this.cacheManager.isAppMetadataFOCI(\n            request.account.environment\n        );\n\n        // if the app is part of the family, retrive a Family refresh token if present and make a refreshTokenRequest\n        if (isFOCI) {\n            try {\n                this.performanceClient?.setPreQueueTime(\n                    PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,\n                    request.correlationId\n                );\n                return this.acquireTokenWithCachedRefreshToken(request, true);\n            } catch (e) {\n                const noFamilyRTInCache =\n                    e instanceof InteractionRequiredAuthError &&\n                    e.errorCode ===\n                        InteractionRequiredAuthErrorMessage.noTokensFoundError\n                            .code;\n                const clientMismatchErrorWithFamilyRT =\n                    e instanceof ServerError &&\n                    e.errorCode === Errors.INVALID_GRANT_ERROR &&\n                    e.subError === Errors.CLIENT_MISMATCH_ERROR;\n\n                // if family Refresh Token (FRT) cache acquisition fails or if client_mismatch error is seen with FRT, reattempt with application Refresh Token (ART)\n                if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {\n                    this.performanceClient?.setPreQueueTime(\n                        PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,\n                        request.correlationId\n                    );\n                    return this.acquireTokenWithCachedRefreshToken(\n                        request,\n                        false\n                    );\n                    // throw in all other cases\n                } else {\n                    throw e;\n                }\n            }\n        }\n        // fall back to application refresh token acquisition\n        this.performanceClient?.setPreQueueTime(\n            PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,\n            request.correlationId\n        );\n        return this.acquireTokenWithCachedRefreshToken(request, false);\n    }\n\n    /**\n     * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached\n     * @param request\n     */\n    private async acquireTokenWithCachedRefreshToken(\n        request: CommonSilentFlowRequest,\n        foci: boolean\n    ) {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,\n            request.correlationId\n        );\n\n        // fetches family RT or application RT based on FOCI value\n\n        const atsMeasurement = this.performanceClient?.startMeasurement(\n            PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,\n            request.correlationId\n        );\n        this.logger.verbose(\n            \"RefreshTokenClientAcquireTokenWithCachedRefreshToken called\",\n            request.correlationId\n        );\n        const refreshToken = this.cacheManager.getRefreshToken(\n            request.account,\n            foci\n        );\n\n        if (!refreshToken) {\n            atsMeasurement?.discard();\n            throw InteractionRequiredAuthError.createNoTokensFoundError();\n        }\n        // attach cached RT size to the current measurement\n        atsMeasurement?.end({\n            success: true,\n        });\n\n        const refreshTokenRequest: CommonRefreshTokenRequest = {\n            ...request,\n            refreshToken: refreshToken.secret,\n            authenticationScheme:\n                request.authenticationScheme || AuthenticationScheme.BEARER,\n            ccsCredential: {\n                credential: request.account.homeAccountId,\n                type: CcsCredentialType.HOME_ACCOUNT_ID,\n            },\n        };\n\n        this.performanceClient?.setPreQueueTime(\n            PerformanceEvents.RefreshTokenClientAcquireToken,\n            request.correlationId\n        );\n        return this.acquireToken(refreshTokenRequest);\n    }\n\n    /**\n     * Constructs the network message and makes a NW call to the underlying secure token service\n     * @param request\n     * @param authority\n     */\n    private async executeTokenRequest(\n        request: CommonRefreshTokenRequest,\n        authority: Authority\n    ): Promise<NetworkResponse<ServerAuthorizationTokenResponse>> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RefreshTokenClientExecuteTokenRequest,\n            request.correlationId\n        );\n        const acquireTokenMeasurement =\n            this.performanceClient?.startMeasurement(\n                PerformanceEvents.RefreshTokenClientExecuteTokenRequest,\n                request.correlationId\n            );\n        this.performanceClient?.setPreQueueTime(\n            PerformanceEvents.RefreshTokenClientCreateTokenRequestBody,\n            request.correlationId\n        );\n\n        const queryParametersString = this.createTokenQueryParameters(request);\n        const endpoint = UrlString.appendQueryString(\n            authority.tokenEndpoint,\n            queryParametersString\n        );\n\n        const requestBody = await this.createTokenRequestBody(request);\n        const headers: Record<string, string> = this.createTokenRequestHeaders(\n            request.ccsCredential\n        );\n        const thumbprint: RequestThumbprint = {\n            clientId: this.config.authOptions.clientId,\n            authority: authority.canonicalAuthority,\n            scopes: request.scopes,\n            claims: request.claims,\n            authenticationScheme: request.authenticationScheme,\n            resourceRequestMethod: request.resourceRequestMethod,\n            resourceRequestUri: request.resourceRequestUri,\n            shrClaims: request.shrClaims,\n            sshKid: request.sshKid,\n        };\n\n        return this.executePostToTokenEndpoint(\n            endpoint,\n            requestBody,\n            headers,\n            thumbprint,\n            request.correlationId\n        )\n            .then((result) => {\n                acquireTokenMeasurement?.end({\n                    success: true,\n                });\n                return result;\n            })\n            .catch((error) => {\n                acquireTokenMeasurement?.end({\n                    success: false,\n                });\n                throw error;\n            });\n    }\n\n    /**\n     * Helper function to create the token request body\n     * @param request\n     */\n    private async createTokenRequestBody(\n        request: CommonRefreshTokenRequest\n    ): Promise<string> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.RefreshTokenClientCreateTokenRequestBody,\n            request.correlationId\n        );\n\n        const correlationId = request.correlationId;\n        const acquireTokenMeasurement =\n            this.performanceClient?.startMeasurement(\n                PerformanceEvents.BaseClientCreateTokenRequestHeaders,\n                correlationId\n            );\n        const parameterBuilder = new RequestParameterBuilder();\n\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\n\n        parameterBuilder.addScopes(\n            request.scopes,\n            true,\n            this.config.authOptions.authority.options.OIDCOptions?.defaultScopes\n        );\n\n        parameterBuilder.addGrantType(GrantType.REFRESH_TOKEN_GRANT);\n\n        parameterBuilder.addClientInfo();\n\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n        parameterBuilder.addApplicationTelemetry(\n            this.config.telemetry.application\n        );\n        parameterBuilder.addThrottling();\n\n        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {\n            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n        }\n\n        parameterBuilder.addCorrelationId(correlationId);\n\n        parameterBuilder.addRefreshToken(request.refreshToken);\n\n        if (this.config.clientCredentials.clientSecret) {\n            parameterBuilder.addClientSecret(\n                this.config.clientCredentials.clientSecret\n            );\n        }\n\n        if (this.config.clientCredentials.clientAssertion) {\n            const clientAssertion =\n                this.config.clientCredentials.clientAssertion;\n            parameterBuilder.addClientAssertion(clientAssertion.assertion);\n            parameterBuilder.addClientAssertionType(\n                clientAssertion.assertionType\n            );\n        }\n\n        if (request.authenticationScheme === AuthenticationScheme.POP) {\n            const popTokenGenerator = new PopTokenGenerator(\n                this.cryptoUtils,\n                this.performanceClient\n            );\n            this.performanceClient?.setPreQueueTime(\n                PerformanceEvents.PopTokenGenerateCnf,\n                request.correlationId\n            );\n            const reqCnfData = await popTokenGenerator.generateCnf(request);\n            // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)\n            parameterBuilder.addPopToken(reqCnfData.reqCnfString);\n        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {\n            if (request.sshJwk) {\n                parameterBuilder.addSshJwk(request.sshJwk);\n            } else {\n                acquireTokenMeasurement?.end({\n                    success: false,\n                });\n                throw ClientConfigurationError.createMissingSshJwkError();\n            }\n        }\n\n        if (\n            !StringUtils.isEmptyObj(request.claims) ||\n            (this.config.authOptions.clientCapabilities &&\n                this.config.authOptions.clientCapabilities.length > 0)\n        ) {\n            parameterBuilder.addClaims(\n                request.claims,\n                this.config.authOptions.clientCapabilities\n            );\n        }\n\n        if (\n            this.config.systemOptions.preventCorsPreflight &&\n            request.ccsCredential\n        ) {\n            switch (request.ccsCredential.type) {\n                case CcsCredentialType.HOME_ACCOUNT_ID:\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(\n                            request.ccsCredential.credential\n                        );\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\n                            \"Could not parse home account ID for CCS Header: \" +\n                                e\n                        );\n                    }\n                    break;\n                case CcsCredentialType.UPN:\n                    parameterBuilder.addCcsUpn(\n                        request.ccsCredential.credential\n                    );\n                    break;\n            }\n        }\n        acquireTokenMeasurement?.end({\n            success: true,\n        });\n        return parameterBuilder.createQueryString();\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAKA;AAIA;AACA;AAWA;;AAiLO;;AAoDH;;;;EAIG;oBAC8BA,CAAAC,OAAA;IA6DjC,KAAAC,iBAAA,EAAAC,mBAAA,CAAAC,iBAAA,CAAAC,8BAAA,EAAAJ,OAAA,CAAAK,aAAA;;;IAGG,MAAAC,YAAA,GAAAC,SAAA,CAAAC,UAAA;QACW,CAAsBP,iBAAA,EAAAQ,eAAA,CAAAN,iBAAA,CAAAO,qCAAA,EAAAV,OAAA,CAAAK,aAAA;IAyHvC,MAAAM,QAAA,cAAAC,mBAAA,CAAAZ,OAAA,OAAAa,SAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}