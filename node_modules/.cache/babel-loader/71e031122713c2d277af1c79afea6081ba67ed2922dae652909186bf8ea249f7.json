{"ast":null,"code":"/*! @azure/msal-browser v3.9.0 2024-02-07 */\n'use strict';\n\nimport { PerformanceEvents, ServerError, invokeAsync, CcsCredentialType } from '@azure/msal-common';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { userCancelled } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Abstract class which defines operations for a browser interaction handling class.\n */\nclass InteractionHandler {\n  constructor(authCodeModule, storageImpl, authCodeRequest, logger, performanceClient) {\n    this.authModule = authCodeModule;\n    this.browserStorage = storageImpl;\n    this.authCodeRequest = authCodeRequest;\n    this.logger = logger;\n    this.performanceClient = performanceClient;\n  }\n  /**\n   * Function to handle response parameters from hash.\n   * @param locationHash\n   */\n  async handleCodeResponse(response, request) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponse, request.correlationId);\n    let authCodeResponse;\n    try {\n      authCodeResponse = this.authModule.handleFragmentResponse(response, request.state);\n    } catch (e) {\n      if (e instanceof ServerError && e.subError === userCancelled) {\n        // Translate server error caused by user closing native prompt to corresponding first class MSAL error\n        throw createBrowserAuthError(userCancelled);\n      } else {\n        throw e;\n      }\n    }\n    return invokeAsync(this.handleCodeResponseFromServer.bind(this), PerformanceEvents.HandleCodeResponseFromServer, this.logger, this.performanceClient, request.correlationId)(authCodeResponse, request);\n  }\n  /**\n   * Process auth code response from AAD\n   * @param authCodeResponse\n   * @param state\n   * @param authority\n   * @param networkModule\n   * @returns\n   */\n  async handleCodeResponseFromServer(authCodeResponse, request, validateNonce = true) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponseFromServer, request.correlationId);\n    this.logger.trace(\"InteractionHandler.handleCodeResponseFromServer called\");\n    // Assign code to request\n    this.authCodeRequest.code = authCodeResponse.code;\n    // Check for new cloud instance\n    if (authCodeResponse.cloud_instance_host_name) {\n      await invokeAsync(this.authModule.updateAuthority.bind(this.authModule), PerformanceEvents.UpdateTokenEndpointAuthority, this.logger, this.performanceClient, request.correlationId)(authCodeResponse.cloud_instance_host_name, request.correlationId);\n    }\n    // Nonce validation not needed when redirect not involved (e.g. hybrid spa, renewing token via rt)\n    if (validateNonce) {\n      // TODO: Assigning \"response nonce\" to \"request nonce\" is confusing. Refactor the function doing validation to accept request nonce directly\n      authCodeResponse.nonce = request.nonce || undefined;\n    }\n    authCodeResponse.state = request.state;\n    // Add CCS parameters if available\n    if (authCodeResponse.client_info) {\n      this.authCodeRequest.clientInfo = authCodeResponse.client_info;\n    } else {\n      const ccsCred = this.createCcsCredentials(request);\n      if (ccsCred) {\n        this.authCodeRequest.ccsCredential = ccsCred;\n      }\n    }\n    // Acquire token with retrieved code.\n    const tokenResponse = await invokeAsync(this.authModule.acquireToken.bind(this.authModule), PerformanceEvents.AuthClientAcquireToken, this.logger, this.performanceClient, request.correlationId)(this.authCodeRequest, authCodeResponse);\n    return tokenResponse;\n  }\n  /**\n   * Build ccs creds if available\n   */\n  createCcsCredentials(request) {\n    if (request.account) {\n      return {\n        credential: request.account.homeAccountId,\n        type: CcsCredentialType.HOME_ACCOUNT_ID\n      };\n    } else if (request.loginHint) {\n      return {\n        credential: request.loginHint,\n        type: CcsCredentialType.UPN\n      };\n    }\n    return null;\n  }\n}\nexport { InteractionHandler };","map":{"version":3,"names":["InteractionHandler","constructor","authCodeModule","storageImpl","authCodeRequest","logger","performanceClient","authModule","browserStorage","handleCodeResponse","response","request","addQueueMeasurement","PerformanceEvents","HandleCodeResponse","correlationId","authCodeResponse","handleFragmentResponse","state","e","ServerError","subError","userCancelled","createBrowserAuthError","invokeAsync","handleCodeResponseFromServer","bind","HandleCodeResponseFromServer","validateNonce","trace","code","cloud_instance_host_name","updateAuthority","UpdateTokenEndpointAuthority","nonce","undefined","client_info","clientInfo","ccsCred","createCcsCredentials","ccsCredential","tokenResponse","acquireToken","AuthClientAcquireToken","account","credential","homeAccountId","type","CcsCredentialType","HOME_ACCOUNT_ID","loginHint","UPN"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\interaction_handler\\InteractionHandler.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AuthorizationCodePayload,\n    CommonAuthorizationCodeRequest,\n    AuthorizationCodeClient,\n    CcsCredential,\n    Logger,\n    ServerError,\n    IPerformanceClient,\n    PerformanceEvents,\n    invokeAsync,\n    CcsCredentialType,\n    ServerAuthorizationCodeResponse,\n} from \"@azure/msal-common\";\n\nimport { BrowserCacheManager } from \"../cache/BrowserCacheManager\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\nimport { AuthorizationUrlRequest } from \"../request/AuthorizationUrlRequest\";\n\n/**\n * Abstract class which defines operations for a browser interaction handling class.\n */\nexport class InteractionHandler {\n    protected authModule: AuthorizationCodeClient;\n    protected browserStorage: BrowserCacheManager;\n    protected authCodeRequest: CommonAuthorizationCodeRequest;\n    protected logger: Logger;\n    protected performanceClient: IPerformanceClient;\n\n    constructor(\n        authCodeModule: AuthorizationCodeClient,\n        storageImpl: BrowserCacheManager,\n        authCodeRequest: CommonAuthorizationCodeRequest,\n        logger: Logger,\n        performanceClient: IPerformanceClient\n    ) {\n        this.authModule = authCodeModule;\n        this.browserStorage = storageImpl;\n        this.authCodeRequest = authCodeRequest;\n        this.logger = logger;\n        this.performanceClient = performanceClient;\n    }\n\n    /**\n     * Function to handle response parameters from hash.\n     * @param locationHash\n     */\n    async handleCodeResponse(\n        response: ServerAuthorizationCodeResponse,\n        request: AuthorizationUrlRequest\n    ): Promise<AuthenticationResult> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.HandleCodeResponse,\n            request.correlationId\n        );\n\n        let authCodeResponse;\n        try {\n            authCodeResponse = this.authModule.handleFragmentResponse(\n                response,\n                request.state\n            );\n        } catch (e) {\n            if (\n                e instanceof ServerError &&\n                e.subError === BrowserAuthErrorCodes.userCancelled\n            ) {\n                // Translate server error caused by user closing native prompt to corresponding first class MSAL error\n                throw createBrowserAuthError(\n                    BrowserAuthErrorCodes.userCancelled\n                );\n            } else {\n                throw e;\n            }\n        }\n\n        return invokeAsync(\n            this.handleCodeResponseFromServer.bind(this),\n            PerformanceEvents.HandleCodeResponseFromServer,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(authCodeResponse, request);\n    }\n\n    /**\n     * Process auth code response from AAD\n     * @param authCodeResponse\n     * @param state\n     * @param authority\n     * @param networkModule\n     * @returns\n     */\n    async handleCodeResponseFromServer(\n        authCodeResponse: AuthorizationCodePayload,\n        request: AuthorizationUrlRequest,\n        validateNonce: boolean = true\n    ): Promise<AuthenticationResult> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.HandleCodeResponseFromServer,\n            request.correlationId\n        );\n        this.logger.trace(\n            \"InteractionHandler.handleCodeResponseFromServer called\"\n        );\n\n        // Assign code to request\n        this.authCodeRequest.code = authCodeResponse.code;\n\n        // Check for new cloud instance\n        if (authCodeResponse.cloud_instance_host_name) {\n            await invokeAsync(\n                this.authModule.updateAuthority.bind(this.authModule),\n                PerformanceEvents.UpdateTokenEndpointAuthority,\n                this.logger,\n                this.performanceClient,\n                request.correlationId\n            )(authCodeResponse.cloud_instance_host_name, request.correlationId);\n        }\n\n        // Nonce validation not needed when redirect not involved (e.g. hybrid spa, renewing token via rt)\n        if (validateNonce) {\n            // TODO: Assigning \"response nonce\" to \"request nonce\" is confusing. Refactor the function doing validation to accept request nonce directly\n            authCodeResponse.nonce = request.nonce || undefined;\n        }\n\n        authCodeResponse.state = request.state;\n\n        // Add CCS parameters if available\n        if (authCodeResponse.client_info) {\n            this.authCodeRequest.clientInfo = authCodeResponse.client_info;\n        } else {\n            const ccsCred = this.createCcsCredentials(request);\n            if (ccsCred) {\n                this.authCodeRequest.ccsCredential = ccsCred;\n            }\n        }\n\n        // Acquire token with retrieved code.\n        const tokenResponse = (await invokeAsync(\n            this.authModule.acquireToken.bind(this.authModule),\n            PerformanceEvents.AuthClientAcquireToken,\n            this.logger,\n            this.performanceClient,\n            request.correlationId\n        )(this.authCodeRequest, authCodeResponse)) as AuthenticationResult;\n        return tokenResponse;\n    }\n\n    /**\n     * Build ccs creds if available\n     */\n    protected createCcsCredentials(\n        request: AuthorizationUrlRequest\n    ): CcsCredential | null {\n        if (request.account) {\n            return {\n                credential: request.account.homeAccountId,\n                type: CcsCredentialType.HOME_ACCOUNT_ID,\n            };\n        } else if (request.loginHint) {\n            return {\n                credential: request.loginHint,\n                type: CcsCredentialType.UPN,\n            };\n        }\n\n        return null;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}