{"ast":null,"code":"/*! @azure/msal-browser v3.5.0 2023-11-07 */\n'use strict';\n\nimport { invokeAsync, PerformanceEvents, AuthError, Constants, UrlString, UrlUtils, ProtocolUtils, ThrottlingUtils, ProtocolMode, ServerResponseType } from '@azure/msal-common';\nimport { StandardInteractionClient } from './StandardInteractionClient.mjs';\nimport { InteractionType, ApiId, TemporaryCacheKeys } from '../utils/BrowserConstants.mjs';\nimport { RedirectHandler } from '../interaction_handler/RedirectHandler.mjs';\nimport { replaceHash, isInIframe, getHomepage, clearHash, getCurrentUri } from '../utils/BrowserUtils.mjs';\nimport { EventType } from '../event/EventType.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { NativeInteractionClient } from './NativeInteractionClient.mjs';\nimport { NativeMessageHandler } from '../broker/nativeBroker/NativeMessageHandler.mjs';\nimport { validateInteractionType } from '../response/ResponseHandler.mjs';\nimport { noStateInHash, nativeConnectionNotEstablished, noCachedAuthorityError } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass RedirectClient extends StandardInteractionClient {\n  constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeStorageImpl, nativeMessageHandler, correlationId) {\n    super(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId);\n    this.nativeStorage = nativeStorageImpl;\n  }\n  /**\n   * Redirects the page to the /authorize endpoint of the IDP\n   * @param request\n   */\n  async acquireToken(request) {\n    const validRequest = await invokeAsync(this.initializeAuthorizationRequest.bind(this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest, this.logger, this.performanceClient, this.correlationId)(request, InteractionType.Redirect);\n    this.browserStorage.updateCacheEntries(validRequest.state, validRequest.nonce, validRequest.authority, validRequest.loginHint || \"\", validRequest.account || null);\n    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenRedirect);\n    const handleBackButton = event => {\n      // Clear temporary cache if the back button is clicked during the redirect flow.\n      if (event.persisted) {\n        this.logger.verbose(\"Page was restored from back/forward cache. Clearing temporary cache.\");\n        this.browserStorage.cleanRequestByState(validRequest.state);\n        this.eventHandler.emitEvent(EventType.RESTORE_FROM_BFCACHE, InteractionType.Redirect);\n      }\n    };\n    try {\n      // Create auth code request and generate PKCE params\n      const authCodeRequest = await invokeAsync(this.initializeAuthorizationCodeRequest.bind(this), PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest, this.logger, this.performanceClient, this.correlationId)(validRequest);\n      // Initialize the client\n      const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, this.correlationId)(serverTelemetryManager, validRequest.authority, validRequest.azureCloudOptions);\n      // Create redirect interaction handler.\n      const interactionHandler = new RedirectHandler(authClient, this.browserStorage, authCodeRequest, this.logger, this.performanceClient);\n      // Create acquire token url.\n      const navigateUrl = await authClient.getAuthCodeUrl({\n        ...validRequest,\n        nativeBroker: NativeMessageHandler.isNativeAvailable(this.config, this.logger, this.nativeMessageHandler, request.authenticationScheme)\n      });\n      const redirectStartPage = this.getRedirectStartPage(request.redirectStartPage);\n      this.logger.verbosePii(`Redirect start page: ${redirectStartPage}`);\n      // Clear temporary cache if the back button is clicked during the redirect flow.\n      window.addEventListener(\"pageshow\", handleBackButton);\n      // Show the UI once the url has been created. Response will come back in the hash, which will be handled in the handleRedirectCallback function.\n      return await interactionHandler.initiateAuthRequest(navigateUrl, {\n        navigationClient: this.navigationClient,\n        redirectTimeout: this.config.system.redirectNavigationTimeout,\n        redirectStartPage: redirectStartPage,\n        onRedirectNavigate: request.onRedirectNavigate\n      });\n    } catch (e) {\n      if (e instanceof AuthError) {\n        e.setCorrelationId(this.correlationId);\n        serverTelemetryManager.cacheFailedRequest(e);\n      }\n      window.removeEventListener(\"pageshow\", handleBackButton);\n      this.browserStorage.cleanRequestByState(validRequest.state);\n      throw e;\n    }\n  }\n  /**\n   * Checks if navigateToLoginRequestUrl is set, and:\n   * - if true, performs logic to cache and navigate\n   * - if false, handles hash string and parses response\n   * @param hash\n   */\n  async handleRedirectPromise(hash) {\n    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.handleRedirectPromise);\n    try {\n      if (!this.browserStorage.isInteractionInProgress(true)) {\n        this.logger.info(\"handleRedirectPromise called but there is no interaction in progress, returning null.\");\n        return null;\n      }\n      const [serverParams, responseString] = this.getRedirectResponse(hash || \"\");\n      if (!serverParams) {\n        // Not a recognized server response hash or hash not associated with a redirect request\n        this.logger.info(\"handleRedirectPromise did not detect a response as a result of a redirect. Cleaning temporary cache.\");\n        this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n        return null;\n      }\n      // If navigateToLoginRequestUrl is true, get the url where the redirect request was initiated\n      const loginRequestUrl = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, true) || Constants.EMPTY_STRING;\n      const loginRequestUrlNormalized = UrlString.removeHashFromUrl(loginRequestUrl);\n      const currentUrlNormalized = UrlString.removeHashFromUrl(window.location.href);\n      if (loginRequestUrlNormalized === currentUrlNormalized && this.config.auth.navigateToLoginRequestUrl) {\n        // We are on the page we need to navigate to - handle hash\n        this.logger.verbose(\"Current page is loginRequestUrl, handling response\");\n        if (loginRequestUrl.indexOf(\"#\") > -1) {\n          // Replace current hash with non-msal hash, if present\n          replaceHash(loginRequestUrl);\n        }\n        const handleHashResult = await this.handleResponse(serverParams, serverTelemetryManager);\n        return handleHashResult;\n      } else if (!this.config.auth.navigateToLoginRequestUrl) {\n        this.logger.verbose(\"NavigateToLoginRequestUrl set to false, handling response\");\n        return this.handleResponse(serverParams, serverTelemetryManager);\n      } else if (!isInIframe() || this.config.system.allowRedirectInIframe) {\n        /*\n         * Returned from authority using redirect - need to perform navigation before processing response\n         * Cache the hash to be retrieved after the next redirect\n         */\n        this.browserStorage.setTemporaryCache(TemporaryCacheKeys.URL_HASH, responseString, true);\n        const navigationOptions = {\n          apiId: ApiId.handleRedirectPromise,\n          timeout: this.config.system.redirectNavigationTimeout,\n          noHistory: true\n        };\n        /**\n         * Default behavior is to redirect to the start page and not process the hash now.\n         * The start page is expected to also call handleRedirectPromise which will process the hash in one of the checks above.\n         */\n        let processHashOnRedirect = true;\n        if (!loginRequestUrl || loginRequestUrl === \"null\") {\n          // Redirect to home page if login request url is null (real null or the string null)\n          const homepage = getHomepage();\n          // Cache the homepage under ORIGIN_URI to ensure cached hash is processed on homepage\n          this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, homepage, true);\n          this.logger.warning(\"Unable to get valid login request url from cache, redirecting to home page\");\n          processHashOnRedirect = await this.navigationClient.navigateInternal(homepage, navigationOptions);\n        } else {\n          // Navigate to page that initiated the redirect request\n          this.logger.verbose(`Navigating to loginRequestUrl: ${loginRequestUrl}`);\n          processHashOnRedirect = await this.navigationClient.navigateInternal(loginRequestUrl, navigationOptions);\n        }\n        // If navigateInternal implementation returns false, handle the hash now\n        if (!processHashOnRedirect) {\n          return this.handleResponse(serverParams, serverTelemetryManager);\n        }\n      }\n      return null;\n    } catch (e) {\n      if (e instanceof AuthError) {\n        e.setCorrelationId(this.correlationId);\n        serverTelemetryManager.cacheFailedRequest(e);\n      }\n      this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n      throw e;\n    }\n  }\n  /**\n   * Gets the response hash for a redirect request\n   * Returns null if interactionType in the state value is not \"redirect\" or the hash does not contain known properties\n   * @param hash\n   */\n  getRedirectResponse(userProvidedResponse) {\n    this.logger.verbose(\"getRedirectResponseHash called\");\n    // Get current location hash from window or cache.\n    let responseString = userProvidedResponse;\n    if (!responseString) {\n      if (this.config.auth.OIDCOptions.serverResponseType === ServerResponseType.QUERY) {\n        responseString = window.location.search;\n      } else {\n        responseString = window.location.hash;\n      }\n    }\n    let response = UrlUtils.getDeserializedResponse(responseString);\n    if (response) {\n      try {\n        validateInteractionType(response, this.browserCrypto, InteractionType.Redirect);\n      } catch (e) {\n        if (e instanceof AuthError) {\n          this.logger.error(`Interaction type validation failed due to ${e.errorCode}: ${e.errorMessage}`);\n        }\n        return [null, \"\"];\n      }\n      clearHash(window);\n      this.logger.verbose(\"Hash contains known properties, returning response hash\");\n      return [response, responseString];\n    }\n    const cachedHash = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.URL_HASH, true);\n    this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    if (cachedHash) {\n      response = UrlUtils.getDeserializedResponse(cachedHash);\n      if (response) {\n        this.logger.verbose(\"Hash does not contain known properties, returning cached hash\");\n        return [response, cachedHash];\n      }\n    }\n    return [null, \"\"];\n  }\n  /**\n   * Checks if hash exists and handles in window.\n   * @param hash\n   * @param state\n   */\n  async handleResponse(serverParams, serverTelemetryManager) {\n    const state = serverParams.state;\n    if (!state) {\n      throw createBrowserAuthError(noStateInHash);\n    }\n    const cachedRequest = this.browserStorage.getCachedRequest(state);\n    this.logger.verbose(\"handleResponse called, retrieved cached request\");\n    if (serverParams.accountId) {\n      this.logger.verbose(\"Account id found in hash, calling WAM for token\");\n      if (!this.nativeMessageHandler) {\n        throw createBrowserAuthError(nativeConnectionNotEstablished);\n      }\n      const nativeInteractionClient = new NativeInteractionClient(this.config, this.browserStorage, this.browserCrypto, this.logger, this.eventHandler, this.navigationClient, ApiId.acquireTokenPopup, this.performanceClient, this.nativeMessageHandler, serverParams.accountId, this.nativeStorage, cachedRequest.correlationId);\n      const {\n        userRequestState\n      } = ProtocolUtils.parseRequestState(this.browserCrypto, state);\n      return nativeInteractionClient.acquireToken({\n        ...cachedRequest,\n        state: userRequestState,\n        prompt: undefined // Server should handle the prompt, ideally native broker can do this part silently\n      }).finally(() => {\n        this.browserStorage.cleanRequestByState(state);\n      });\n    }\n    // Hash contains known properties - handle and return in callback\n    const currentAuthority = this.browserStorage.getCachedAuthority(state);\n    if (!currentAuthority) {\n      throw createBrowserAuthError(noCachedAuthorityError);\n    }\n    const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, this.correlationId)(serverTelemetryManager, currentAuthority);\n    ThrottlingUtils.removeThrottle(this.browserStorage, this.config.auth.clientId, cachedRequest);\n    const interactionHandler = new RedirectHandler(authClient, this.browserStorage, cachedRequest, this.logger, this.performanceClient);\n    return await interactionHandler.handleCodeResponse(serverParams, state);\n  }\n  /**\n   * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\n   * Default behaviour is to redirect the user to `window.location.href`.\n   * @param logoutRequest\n   */\n  async logout(logoutRequest) {\n    this.logger.verbose(\"logoutRedirect called\");\n    const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\n    const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logout);\n    try {\n      this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Redirect, logoutRequest);\n      // Clear cache on logout\n      await this.clearCacheOnLogout(validLogoutRequest.account);\n      const navigationOptions = {\n        apiId: ApiId.logout,\n        timeout: this.config.system.redirectNavigationTimeout,\n        noHistory: false\n      };\n      const authClient = await invokeAsync(this.createAuthCodeClient.bind(this), PerformanceEvents.StandardInteractionClientCreateAuthCodeClient, this.logger, this.performanceClient, this.correlationId)(serverTelemetryManager, logoutRequest && logoutRequest.authority);\n      if (authClient.authority.protocolMode === ProtocolMode.OIDC) {\n        try {\n          authClient.authority.endSessionEndpoint;\n        } catch {\n          if (validLogoutRequest.account?.homeAccountId) {\n            void this.browserStorage.removeAccount(validLogoutRequest.account?.homeAccountId);\n            this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);\n            return;\n          }\n        }\n      }\n      // Create logout string and navigate user window to logout.\n      const logoutUri = authClient.getLogoutUri(validLogoutRequest);\n      this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);\n      // Check if onRedirectNavigate is implemented, and invoke it if so\n      if (logoutRequest && typeof logoutRequest.onRedirectNavigate === \"function\") {\n        const navigate = logoutRequest.onRedirectNavigate(logoutUri);\n        if (navigate !== false) {\n          this.logger.verbose(\"Logout onRedirectNavigate did not return false, navigating\");\n          // Ensure interaction is in progress\n          if (!this.browserStorage.getInteractionInProgress()) {\n            this.browserStorage.setInteractionInProgress(true);\n          }\n          await this.navigationClient.navigateExternal(logoutUri, navigationOptions);\n          return;\n        } else {\n          // Ensure interaction is not in progress\n          this.browserStorage.setInteractionInProgress(false);\n          this.logger.verbose(\"Logout onRedirectNavigate returned false, stopping navigation\");\n        }\n      } else {\n        // Ensure interaction is in progress\n        if (!this.browserStorage.getInteractionInProgress()) {\n          this.browserStorage.setInteractionInProgress(true);\n        }\n        await this.navigationClient.navigateExternal(logoutUri, navigationOptions);\n        return;\n      }\n    } catch (e) {\n      if (e instanceof AuthError) {\n        e.setCorrelationId(this.correlationId);\n        serverTelemetryManager.cacheFailedRequest(e);\n      }\n      this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Redirect, null, e);\n      this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);\n      throw e;\n    }\n    this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);\n  }\n  /**\n   * Use to get the redirectStartPage either from request or use current window\n   * @param requestStartPage\n   */\n  getRedirectStartPage(requestStartPage) {\n    const redirectStartPage = requestStartPage || window.location.href;\n    return UrlString.getAbsoluteUrl(redirectStartPage, getCurrentUri());\n  }\n}\nexport { RedirectClient };","map":{"version":3,"names":["config","storageImpl","browserCrypto","logger","eventHandler","navigationClient","performanceClient","nativeMessageHandler","correlationId","nativeStorage","nativeStorageImpl","acquireToken","request","validRequest","invokeAsync","initializeAuthorizationRequest","bind","PerformanceEvents","StandardInteractionClientInitializeAuthorizationRequest","InteractionType","Redirect","browserStorage","updateCacheEntries","state","nonce","authority","loginHint","account","event","persisted","verbose","cleanRequestByState","authCodeRequest","initializeAuthorizationCodeRequest","StandardInteractionClientInitializeAuthorizationCodeRequest","interactionHandler","RedirectHandler","authClient","navigateUrl","getAuthCodeUrl","redirectStartPage","getRedirectStartPage","verbosePii"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\interaction_client\\RedirectClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    CommonAuthorizationCodeRequest,\n    AuthorizationCodeClient,\n    UrlString,\n    AuthError,\n    ServerTelemetryManager,\n    Constants,\n    ProtocolUtils,\n    ServerAuthorizationCodeResponse,\n    ThrottlingUtils,\n    ICrypto,\n    Logger,\n    IPerformanceClient,\n    PerformanceEvents,\n    ProtocolMode,\n    invokeAsync,\n    ServerResponseType,\n    UrlUtils,\n} from \"@azure/msal-common\";\nimport { StandardInteractionClient } from \"./StandardInteractionClient\";\nimport {\n    ApiId,\n    InteractionType,\n    TemporaryCacheKeys,\n} from \"../utils/BrowserConstants\";\nimport { RedirectHandler } from \"../interaction_handler/RedirectHandler\";\nimport * as BrowserUtils from \"../utils/BrowserUtils\";\nimport { EndSessionRequest } from \"../request/EndSessionRequest\";\nimport { EventType } from \"../event/EventType\";\nimport { NavigationOptions } from \"../navigation/NavigationOptions\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError\";\nimport { RedirectRequest } from \"../request/RedirectRequest\";\nimport { NativeInteractionClient } from \"./NativeInteractionClient\";\nimport { NativeMessageHandler } from \"../broker/nativeBroker/NativeMessageHandler\";\nimport { BrowserConfiguration } from \"../config/Configuration\";\nimport { BrowserCacheManager } from \"../cache/BrowserCacheManager\";\nimport { EventHandler } from \"../event/EventHandler\";\nimport { INavigationClient } from \"../navigation/INavigationClient\";\nimport { EventError } from \"../event/EventMessage\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\nimport * as ResponseHandler from \"../response/ResponseHandler\";\n\nexport class RedirectClient extends StandardInteractionClient {\n    protected nativeStorage: BrowserCacheManager;\n\n    constructor(\n        config: BrowserConfiguration,\n        storageImpl: BrowserCacheManager,\n        browserCrypto: ICrypto,\n        logger: Logger,\n        eventHandler: EventHandler,\n        navigationClient: INavigationClient,\n        performanceClient: IPerformanceClient,\n        nativeStorageImpl: BrowserCacheManager,\n        nativeMessageHandler?: NativeMessageHandler,\n        correlationId?: string\n    ) {\n        super(\n            config,\n            storageImpl,\n            browserCrypto,\n            logger,\n            eventHandler,\n            navigationClient,\n            performanceClient,\n            nativeMessageHandler,\n            correlationId\n        );\n        this.nativeStorage = nativeStorageImpl;\n    }\n\n    /**\n     * Redirects the page to the /authorize endpoint of the IDP\n     * @param request\n     */\n    async acquireToken(request: RedirectRequest): Promise<void> {\n        const validRequest = await invokeAsync(\n            this.initializeAuthorizationRequest.bind(this),\n            PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest,\n            this.logger,\n            this.performanceClient,\n            this.correlationId\n        )(request, InteractionType.Redirect);\n\n        this.browserStorage.updateCacheEntries(\n            validRequest.state,\n            validRequest.nonce,\n            validRequest.authority,\n            validRequest.loginHint || \"\",\n            validRequest.account || null\n        );\n        const serverTelemetryManager = this.initializeServerTelemetryManager(\n            ApiId.acquireTokenRedirect\n        );\n\n        const handleBackButton = (event: PageTransitionEvent) => {\n            // Clear temporary cache if the back button is clicked during the redirect flow.\n            if (event.persisted) {\n                this.logger.verbose(\n                    \"Page was restored from back/forward cache. Clearing temporary cache.\"\n                );\n                this.browserStorage.cleanRequestByState(validRequest.state);\n                this.eventHandler.emitEvent(\n                    EventType.RESTORE_FROM_BFCACHE,\n                    InteractionType.Redirect\n                );\n            }\n        };\n\n        try {\n            // Create auth code request and generate PKCE params\n            const authCodeRequest: CommonAuthorizationCodeRequest =\n                await invokeAsync(\n                    this.initializeAuthorizationCodeRequest.bind(this),\n                    PerformanceEvents.StandardInteractionClientInitializeAuthorizationCodeRequest,\n                    this.logger,\n                    this.performanceClient,\n                    this.correlationId\n                )(validRequest);\n\n            // Initialize the client\n            const authClient: AuthorizationCodeClient = await invokeAsync(\n                this.createAuthCodeClient.bind(this),\n                PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,\n                this.logger,\n                this.performanceClient,\n                this.correlationId\n            )(\n                serverTelemetryManager,\n                validRequest.authority,\n                validRequest.azureCloudOptions\n            );\n\n            // Create redirect interaction handler.\n            const interactionHandler = new RedirectHandler(\n                authClient,\n                this.browserStorage,\n                authCodeRequest,\n                this.logger,\n                this.performanceClient\n            );\n\n            // Create acquire token url.\n            const navigateUrl = await authClient.getAuthCodeUrl({\n                ...validRequest,\n                nativeBroker: NativeMessageHandler.isNativeAvailable(\n                    this.config,\n                    this.logger,\n                    this.nativeMessageHandler,\n                    request.authenticationScheme\n                ),\n            });\n\n            const redirectStartPage = this.getRedirectStartPage(\n                request.redirectStartPage\n            );\n            this.logger.verbosePii(`Redirect start page: ${redirectStartPage}`);\n\n            // Clear temporary cache if the back button is clicked during the redirect flow.\n            window.addEventListener(\"pageshow\", handleBackButton);\n\n            // Show the UI once the url has been created. Response will come back in the hash, which will be handled in the handleRedirectCallback function.\n            return await interactionHandler.initiateAuthRequest(navigateUrl, {\n                navigationClient: this.navigationClient,\n                redirectTimeout: this.config.system.redirectNavigationTimeout,\n                redirectStartPage: redirectStartPage,\n                onRedirectNavigate: request.onRedirectNavigate,\n            });\n        } catch (e) {\n            if (e instanceof AuthError) {\n                e.setCorrelationId(this.correlationId);\n                serverTelemetryManager.cacheFailedRequest(e);\n            }\n            window.removeEventListener(\"pageshow\", handleBackButton);\n            this.browserStorage.cleanRequestByState(validRequest.state);\n            throw e;\n        }\n    }\n\n    /**\n     * Checks if navigateToLoginRequestUrl is set, and:\n     * - if true, performs logic to cache and navigate\n     * - if false, handles hash string and parses response\n     * @param hash\n     */\n    async handleRedirectPromise(\n        hash?: string\n    ): Promise<AuthenticationResult | null> {\n        const serverTelemetryManager = this.initializeServerTelemetryManager(\n            ApiId.handleRedirectPromise\n        );\n        try {\n            if (!this.browserStorage.isInteractionInProgress(true)) {\n                this.logger.info(\n                    \"handleRedirectPromise called but there is no interaction in progress, returning null.\"\n                );\n                return null;\n            }\n            const [serverParams, responseString] = this.getRedirectResponse(\n                hash || \"\"\n            );\n            if (!serverParams) {\n                // Not a recognized server response hash or hash not associated with a redirect request\n                this.logger.info(\n                    \"handleRedirectPromise did not detect a response as a result of a redirect. Cleaning temporary cache.\"\n                );\n                this.browserStorage.cleanRequestByInteractionType(\n                    InteractionType.Redirect\n                );\n                return null;\n            }\n\n            // If navigateToLoginRequestUrl is true, get the url where the redirect request was initiated\n            const loginRequestUrl =\n                this.browserStorage.getTemporaryCache(\n                    TemporaryCacheKeys.ORIGIN_URI,\n                    true\n                ) || Constants.EMPTY_STRING;\n            const loginRequestUrlNormalized =\n                UrlString.removeHashFromUrl(loginRequestUrl);\n            const currentUrlNormalized = UrlString.removeHashFromUrl(\n                window.location.href\n            );\n\n            if (\n                loginRequestUrlNormalized === currentUrlNormalized &&\n                this.config.auth.navigateToLoginRequestUrl\n            ) {\n                // We are on the page we need to navigate to - handle hash\n                this.logger.verbose(\n                    \"Current page is loginRequestUrl, handling response\"\n                );\n\n                if (loginRequestUrl.indexOf(\"#\") > -1) {\n                    // Replace current hash with non-msal hash, if present\n                    BrowserUtils.replaceHash(loginRequestUrl);\n                }\n\n                const handleHashResult = await this.handleResponse(\n                    serverParams,\n                    serverTelemetryManager\n                );\n\n                return handleHashResult;\n            } else if (!this.config.auth.navigateToLoginRequestUrl) {\n                this.logger.verbose(\n                    \"NavigateToLoginRequestUrl set to false, handling response\"\n                );\n                return this.handleResponse(\n                    serverParams,\n                    serverTelemetryManager\n                );\n            } else if (\n                !BrowserUtils.isInIframe() ||\n                this.config.system.allowRedirectInIframe\n            ) {\n                /*\n                 * Returned from authority using redirect - need to perform navigation before processing response\n                 * Cache the hash to be retrieved after the next redirect\n                 */\n                this.browserStorage.setTemporaryCache(\n                    TemporaryCacheKeys.URL_HASH,\n                    responseString,\n                    true\n                );\n                const navigationOptions: NavigationOptions = {\n                    apiId: ApiId.handleRedirectPromise,\n                    timeout: this.config.system.redirectNavigationTimeout,\n                    noHistory: true,\n                };\n\n                /**\n                 * Default behavior is to redirect to the start page and not process the hash now.\n                 * The start page is expected to also call handleRedirectPromise which will process the hash in one of the checks above.\n                 */\n                let processHashOnRedirect: boolean = true;\n                if (!loginRequestUrl || loginRequestUrl === \"null\") {\n                    // Redirect to home page if login request url is null (real null or the string null)\n                    const homepage = BrowserUtils.getHomepage();\n                    // Cache the homepage under ORIGIN_URI to ensure cached hash is processed on homepage\n                    this.browserStorage.setTemporaryCache(\n                        TemporaryCacheKeys.ORIGIN_URI,\n                        homepage,\n                        true\n                    );\n                    this.logger.warning(\n                        \"Unable to get valid login request url from cache, redirecting to home page\"\n                    );\n                    processHashOnRedirect =\n                        await this.navigationClient.navigateInternal(\n                            homepage,\n                            navigationOptions\n                        );\n                } else {\n                    // Navigate to page that initiated the redirect request\n                    this.logger.verbose(\n                        `Navigating to loginRequestUrl: ${loginRequestUrl}`\n                    );\n                    processHashOnRedirect =\n                        await this.navigationClient.navigateInternal(\n                            loginRequestUrl,\n                            navigationOptions\n                        );\n                }\n\n                // If navigateInternal implementation returns false, handle the hash now\n                if (!processHashOnRedirect) {\n                    return this.handleResponse(\n                        serverParams,\n                        serverTelemetryManager\n                    );\n                }\n            }\n\n            return null;\n        } catch (e) {\n            if (e instanceof AuthError) {\n                (e as AuthError).setCorrelationId(this.correlationId);\n                serverTelemetryManager.cacheFailedRequest(e);\n            }\n            this.browserStorage.cleanRequestByInteractionType(\n                InteractionType.Redirect\n            );\n            throw e;\n        }\n    }\n\n    /**\n     * Gets the response hash for a redirect request\n     * Returns null if interactionType in the state value is not \"redirect\" or the hash does not contain known properties\n     * @param hash\n     */\n    protected getRedirectResponse(\n        userProvidedResponse: string\n    ): [ServerAuthorizationCodeResponse | null, string] {\n        this.logger.verbose(\"getRedirectResponseHash called\");\n        // Get current location hash from window or cache.\n        let responseString = userProvidedResponse;\n        if (!responseString) {\n            if (\n                this.config.auth.OIDCOptions.serverResponseType ===\n                ServerResponseType.QUERY\n            ) {\n                responseString = window.location.search;\n            } else {\n                responseString = window.location.hash;\n            }\n        }\n        let response = UrlUtils.getDeserializedResponse(responseString);\n\n        if (response) {\n            try {\n                ResponseHandler.validateInteractionType(\n                    response,\n                    this.browserCrypto,\n                    InteractionType.Redirect\n                );\n            } catch (e) {\n                if (e instanceof AuthError) {\n                    this.logger.error(\n                        `Interaction type validation failed due to ${e.errorCode}: ${e.errorMessage}`\n                    );\n                }\n                return [null, \"\"];\n            }\n\n            BrowserUtils.clearHash(window);\n            this.logger.verbose(\n                \"Hash contains known properties, returning response hash\"\n            );\n            return [response, responseString];\n        }\n\n        const cachedHash = this.browserStorage.getTemporaryCache(\n            TemporaryCacheKeys.URL_HASH,\n            true\n        );\n        this.browserStorage.removeItem(\n            this.browserStorage.generateCacheKey(TemporaryCacheKeys.URL_HASH)\n        );\n\n        if (cachedHash) {\n            response = UrlUtils.getDeserializedResponse(cachedHash);\n            if (response) {\n                this.logger.verbose(\n                    \"Hash does not contain known properties, returning cached hash\"\n                );\n                return [response, cachedHash];\n            }\n        }\n\n        return [null, \"\"];\n    }\n\n    /**\n     * Checks if hash exists and handles in window.\n     * @param hash\n     * @param state\n     */\n    protected async handleResponse(\n        serverParams: ServerAuthorizationCodeResponse,\n        serverTelemetryManager: ServerTelemetryManager\n    ): Promise<AuthenticationResult> {\n        const state = serverParams.state;\n        if (!state) {\n            throw createBrowserAuthError(BrowserAuthErrorCodes.noStateInHash);\n        }\n\n        const cachedRequest = this.browserStorage.getCachedRequest(state);\n        this.logger.verbose(\"handleResponse called, retrieved cached request\");\n\n        if (serverParams.accountId) {\n            this.logger.verbose(\n                \"Account id found in hash, calling WAM for token\"\n            );\n            if (!this.nativeMessageHandler) {\n                throw createBrowserAuthError(\n                    BrowserAuthErrorCodes.nativeConnectionNotEstablished\n                );\n            }\n            const nativeInteractionClient = new NativeInteractionClient(\n                this.config,\n                this.browserStorage,\n                this.browserCrypto,\n                this.logger,\n                this.eventHandler,\n                this.navigationClient,\n                ApiId.acquireTokenPopup,\n                this.performanceClient,\n                this.nativeMessageHandler,\n                serverParams.accountId,\n                this.nativeStorage,\n                cachedRequest.correlationId\n            );\n            const { userRequestState } = ProtocolUtils.parseRequestState(\n                this.browserCrypto,\n                state\n            );\n            return nativeInteractionClient\n                .acquireToken({\n                    ...cachedRequest,\n                    state: userRequestState,\n                    prompt: undefined, // Server should handle the prompt, ideally native broker can do this part silently\n                })\n                .finally(() => {\n                    this.browserStorage.cleanRequestByState(state);\n                });\n        }\n\n        // Hash contains known properties - handle and return in callback\n        const currentAuthority = this.browserStorage.getCachedAuthority(state);\n        if (!currentAuthority) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.noCachedAuthorityError\n            );\n        }\n\n        const authClient = await invokeAsync(\n            this.createAuthCodeClient.bind(this),\n            PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,\n            this.logger,\n            this.performanceClient,\n            this.correlationId\n        )(serverTelemetryManager, currentAuthority);\n\n        ThrottlingUtils.removeThrottle(\n            this.browserStorage,\n            this.config.auth.clientId,\n            cachedRequest\n        );\n        const interactionHandler = new RedirectHandler(\n            authClient,\n            this.browserStorage,\n            cachedRequest,\n            this.logger,\n            this.performanceClient\n        );\n        return await interactionHandler.handleCodeResponse(serverParams, state);\n    }\n\n    /**\n     * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\n     * Default behaviour is to redirect the user to `window.location.href`.\n     * @param logoutRequest\n     */\n    async logout(logoutRequest?: EndSessionRequest): Promise<void> {\n        this.logger.verbose(\"logoutRedirect called\");\n        const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\n        const serverTelemetryManager = this.initializeServerTelemetryManager(\n            ApiId.logout\n        );\n\n        try {\n            this.eventHandler.emitEvent(\n                EventType.LOGOUT_START,\n                InteractionType.Redirect,\n                logoutRequest\n            );\n\n            // Clear cache on logout\n            await this.clearCacheOnLogout(validLogoutRequest.account);\n\n            const navigationOptions: NavigationOptions = {\n                apiId: ApiId.logout,\n                timeout: this.config.system.redirectNavigationTimeout,\n                noHistory: false,\n            };\n\n            const authClient = await invokeAsync(\n                this.createAuthCodeClient.bind(this),\n                PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,\n                this.logger,\n                this.performanceClient,\n                this.correlationId\n            )(serverTelemetryManager, logoutRequest && logoutRequest.authority);\n\n            if (authClient.authority.protocolMode === ProtocolMode.OIDC) {\n                try {\n                    authClient.authority.endSessionEndpoint;\n                } catch {\n                    if (validLogoutRequest.account?.homeAccountId) {\n                        void this.browserStorage.removeAccount(\n                            validLogoutRequest.account?.homeAccountId\n                        );\n\n                        this.eventHandler.emitEvent(\n                            EventType.LOGOUT_SUCCESS,\n                            InteractionType.Redirect,\n                            validLogoutRequest\n                        );\n\n                        return;\n                    }\n                }\n            }\n\n            // Create logout string and navigate user window to logout.\n            const logoutUri: string =\n                authClient.getLogoutUri(validLogoutRequest);\n\n            this.eventHandler.emitEvent(\n                EventType.LOGOUT_SUCCESS,\n                InteractionType.Redirect,\n                validLogoutRequest\n            );\n            // Check if onRedirectNavigate is implemented, and invoke it if so\n            if (\n                logoutRequest &&\n                typeof logoutRequest.onRedirectNavigate === \"function\"\n            ) {\n                const navigate = logoutRequest.onRedirectNavigate(logoutUri);\n\n                if (navigate !== false) {\n                    this.logger.verbose(\n                        \"Logout onRedirectNavigate did not return false, navigating\"\n                    );\n                    // Ensure interaction is in progress\n                    if (!this.browserStorage.getInteractionInProgress()) {\n                        this.browserStorage.setInteractionInProgress(true);\n                    }\n                    await this.navigationClient.navigateExternal(\n                        logoutUri,\n                        navigationOptions\n                    );\n                    return;\n                } else {\n                    // Ensure interaction is not in progress\n                    this.browserStorage.setInteractionInProgress(false);\n                    this.logger.verbose(\n                        \"Logout onRedirectNavigate returned false, stopping navigation\"\n                    );\n                }\n            } else {\n                // Ensure interaction is in progress\n                if (!this.browserStorage.getInteractionInProgress()) {\n                    this.browserStorage.setInteractionInProgress(true);\n                }\n                await this.navigationClient.navigateExternal(\n                    logoutUri,\n                    navigationOptions\n                );\n                return;\n            }\n        } catch (e) {\n            if (e instanceof AuthError) {\n                (e as AuthError).setCorrelationId(this.correlationId);\n                serverTelemetryManager.cacheFailedRequest(e);\n            }\n            this.eventHandler.emitEvent(\n                EventType.LOGOUT_FAILURE,\n                InteractionType.Redirect,\n                null,\n                e as EventError\n            );\n            this.eventHandler.emitEvent(\n                EventType.LOGOUT_END,\n                InteractionType.Redirect\n            );\n            throw e;\n        }\n\n        this.eventHandler.emitEvent(\n            EventType.LOGOUT_END,\n            InteractionType.Redirect\n        );\n    }\n\n    /**\n     * Use to get the redirectStartPage either from request or use current window\n     * @param requestStartPage\n     */\n    protected getRedirectStartPage(requestStartPage?: string): string {\n        const redirectStartPage = requestStartPage || window.location.href;\n        return UrlString.getAbsoluteUrl(\n            redirectStartPage,\n            BrowserUtils.getCurrentUri()\n        );\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;AAKA;AAmBA;AAQA;AAOA;;;IA2CO,MAAAA,MAAA,EAAAC,WAAA,EAAAC,aAAA,EAAAC,MAAA,EAAAC,YAAA,EAAAC,gBAAA,EAAAC,iBAAA,EAAAC,oBAAA,EAAAC,aAAA;IACe,KAAAC,aAAU,GAAAC,iBAAyB;EAwGrD;;;;;EAKG,MAAAC,aAAAC,OAAA;IACwB,MAAAC,YACvB,GAAI,MAAGC,WACR,KAAQ,CAAAC,8BAA4B,CAAAC,IAAA,QAAAC,iBAAA,CAAAC,uDAAA,OAAAf,MAAA,OAAAG,iBAAA,OAAAE,aAAA,EAAAI,OAAA,EAAAO,eAAA,CAAAC,QAAA;IA4IvC,KAAAC,cAAA,CAAAC,kBAAA,CAAAT,YAAA,CAAAU,KAAA,EAAAV,YAAA,CAAAW,KAAA,EAAAX,YAAA,CAAAY,SAAA,EAAAZ,YAAA,CAAAa,SAAA,QAAAb,YAAA,CAAAc,OAAA;;;;MAIG,IAAAC,KAAA,CAAAC,SAAA;QACO,KAAA1B,MAAA,CAAA2B,OACN,uEACwC;QA4D5C,KAAAT,cAAA,CAAAU,mBAAA,CAAAlB,YAAA,CAAAU,KAAA;;;;IAIG;MACa;MAiFhB,MAAAS,eAAA,SAAAlB,WAAA,MAAAmB,kCAAA,CAAAjB,IAAA,QAAAC,iBAAA,CAAAiB,2DAAA,OAAA/B,MAAA,OAAAG,iBAAA,OAAAE,aAAA,EAAAK,YAAA;;;;MAIG,MAAAsB,kBAAA,OAAAC,eAAA,CAAAC,UAAA,OAAAhB,cAAA,EAAAW,eAAA,OAAA7B,MAAA,OAAAG,iBAAA;;MA2HH,MAAAgC,WAAA,SAAAD,UAAA,CAAAE,cAAA;;;MAGG;MACM,MAAAC,iBAAsB,QAAAC,oBAA4B,CAAM7B,OAAA,CAAA4B,iBAAA;MAOpE,KAAArC,MAAA,CAAAuC,UAAA,yBAAAF,iBAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}