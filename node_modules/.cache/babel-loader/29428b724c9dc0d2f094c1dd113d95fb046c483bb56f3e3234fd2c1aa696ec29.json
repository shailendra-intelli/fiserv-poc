{"ast":null,"code":"/*! @azure/msal-browser v3.9.0 2024-02-07 */\n'use strict';\n\nimport { PerformanceEvents, JoseHeader } from '@azure/msal-common';\nimport { base64Encode, urlEncode, urlEncodeArr } from '../encode/Base64Encode.mjs';\nimport { base64Decode } from '../encode/Base64Decode.mjs';\nimport { validateCryptoAvailable, createNewGuid, generateKeyPair, exportJwk, importJwk, sign, sha256Digest } from './BrowserCrypto.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { CryptoKeyStore } from '../cache/CryptoKeyStore.mjs';\nimport { cryptoKeyNotFound } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * This class implements MSAL's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and\n * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).\n */\nclass CryptoOps {\n  constructor(logger, performanceClient) {\n    this.logger = logger;\n    // Browser crypto needs to be validated first before any other classes can be set.\n    validateCryptoAvailable(logger);\n    this.cache = new CryptoKeyStore(this.logger);\n    this.performanceClient = performanceClient;\n  }\n  /**\n   * Creates a new random GUID - used to populate state and nonce.\n   * @returns string (GUID)\n   */\n  createNewGuid() {\n    return createNewGuid();\n  }\n  /**\n   * Encodes input string to base64.\n   * @param input\n   */\n  base64Encode(input) {\n    return base64Encode(input);\n  }\n  /**\n   * Decodes input string from base64.\n   * @param input\n   */\n  base64Decode(input) {\n    return base64Decode(input);\n  }\n  /**\n   * Generates a keypair, stores it and returns a thumbprint\n   * @param request\n   */\n  async getPublicKeyThumbprint(request) {\n    const publicKeyThumbMeasurement = this.performanceClient?.startMeasurement(PerformanceEvents.CryptoOptsGetPublicKeyThumbprint, request.correlationId);\n    // Generate Keypair\n    const keyPair = await generateKeyPair(CryptoOps.EXTRACTABLE, CryptoOps.POP_KEY_USAGES);\n    // Generate Thumbprint for Public Key\n    const publicKeyJwk = await exportJwk(keyPair.publicKey);\n    const pubKeyThumprintObj = {\n      e: publicKeyJwk.e,\n      kty: publicKeyJwk.kty,\n      n: publicKeyJwk.n\n    };\n    const publicJwkString = getSortedObjectString(pubKeyThumprintObj);\n    const publicJwkHash = await this.hashString(publicJwkString);\n    // Generate Thumbprint for Private Key\n    const privateKeyJwk = await exportJwk(keyPair.privateKey);\n    // Re-import private key to make it unextractable\n    const unextractablePrivateKey = await importJwk(privateKeyJwk, false, [\"sign\"]);\n    // Store Keypair data in keystore\n    await this.cache.asymmetricKeys.setItem(publicJwkHash, {\n      privateKey: unextractablePrivateKey,\n      publicKey: keyPair.publicKey,\n      requestMethod: request.resourceRequestMethod,\n      requestUri: request.resourceRequestUri\n    });\n    if (publicKeyThumbMeasurement) {\n      publicKeyThumbMeasurement.end({\n        success: true\n      });\n    }\n    return publicJwkHash;\n  }\n  /**\n   * Removes cryptographic keypair from key store matching the keyId passed in\n   * @param kid\n   */\n  async removeTokenBindingKey(kid) {\n    await this.cache.asymmetricKeys.removeItem(kid);\n    const keyFound = await this.cache.asymmetricKeys.containsKey(kid);\n    return !keyFound;\n  }\n  /**\n   * Removes all cryptographic keys from IndexedDB storage\n   */\n  async clearKeystore() {\n    return this.cache.clear();\n  }\n  /**\n   * Signs the given object as a jwt payload with private key retrieved by given kid.\n   * @param payload\n   * @param kid\n   */\n  async signJwt(payload, kid, shrOptions, correlationId) {\n    const signJwtMeasurement = this.performanceClient?.startMeasurement(PerformanceEvents.CryptoOptsSignJwt, correlationId);\n    const cachedKeyPair = await this.cache.asymmetricKeys.getItem(kid);\n    if (!cachedKeyPair) {\n      throw createBrowserAuthError(cryptoKeyNotFound);\n    }\n    // Get public key as JWK\n    const publicKeyJwk = await exportJwk(cachedKeyPair.publicKey);\n    const publicKeyJwkString = getSortedObjectString(publicKeyJwk);\n    // Base64URL encode public key thumbprint with keyId only: BASE64URL({ kid: \"FULL_PUBLIC_KEY_HASH\" })\n    const encodedKeyIdThumbprint = urlEncode(JSON.stringify({\n      kid: kid\n    }));\n    // Generate header\n    const shrHeader = JoseHeader.getShrHeaderString({\n      ...shrOptions?.header,\n      alg: publicKeyJwk.alg,\n      kid: encodedKeyIdThumbprint\n    });\n    const encodedShrHeader = urlEncode(shrHeader);\n    // Generate payload\n    payload.cnf = {\n      jwk: JSON.parse(publicKeyJwkString)\n    };\n    const encodedPayload = urlEncode(JSON.stringify(payload));\n    // Form token string\n    const tokenString = `${encodedShrHeader}.${encodedPayload}`;\n    // Sign token\n    const encoder = new TextEncoder();\n    const tokenBuffer = encoder.encode(tokenString);\n    const signatureBuffer = await sign(cachedKeyPair.privateKey, tokenBuffer);\n    const encodedSignature = urlEncodeArr(new Uint8Array(signatureBuffer));\n    const signedJwt = `${tokenString}.${encodedSignature}`;\n    if (signJwtMeasurement) {\n      signJwtMeasurement.end({\n        success: true\n      });\n    }\n    return signedJwt;\n  }\n  /**\n   * Returns the SHA-256 hash of an input string\n   * @param plainText\n   */\n  async hashString(plainText) {\n    const hashBuffer = await sha256Digest(plainText);\n    const hashBytes = new Uint8Array(hashBuffer);\n    return urlEncodeArr(hashBytes);\n  }\n}\nCryptoOps.POP_KEY_USAGES = [\"sign\", \"verify\"];\nCryptoOps.EXTRACTABLE = true;\nfunction getSortedObjectString(obj) {\n  return JSON.stringify(obj, Object.keys(obj).sort());\n}\nexport { CryptoOps };","map":{"version":3,"names":["CryptoOps","constructor","logger","performanceClient","validateCryptoAvailable","cache","CryptoKeyStore","createNewGuid","base64Encode","input","base64Decode","getPublicKeyThumbprint","request","publicKeyThumbMeasurement","startMeasurement","PerformanceEvents","CryptoOptsGetPublicKeyThumbprint","correlationId","keyPair","generateKeyPair","EXTRACTABLE","POP_KEY_USAGES","publicKeyJwk","exportJwk","publicKey","pubKeyThumprintObj","e","kty","n","publicJwkString","getSortedObjectString","publicJwkHash","hashString","privateKeyJwk","privateKey","unextractablePrivateKey","importJwk","asymmetricKeys","setItem","requestMethod","resourceRequestMethod","requestUri","resourceRequestUri","end","success","removeTokenBindingKey","kid","removeItem","keyFound","containsKey","clearKeystore","clear","signJwt","payload","shrOptions","signJwtMeasurement","CryptoOptsSignJwt","cachedKeyPair","getItem","createBrowserAuthError","cryptoKeyNotFound","publicKeyJwkString","encodedKeyIdThumbprint","urlEncode","JSON","stringify","shrHeader","JoseHeader","getShrHeaderString","header","alg","encodedShrHeader","cnf","jwk","parse","encodedPayload","tokenString","encoder","TextEncoder","tokenBuffer","encode","signatureBuffer","sign","encodedSignature","urlEncodeArr","Uint8Array","signedJwt","plainText","hashBuffer","sha256Digest","hashBytes","obj","Object","keys","sort"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\crypto\\CryptoOps.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    ICrypto,\n    IPerformanceClient,\n    JoseHeader,\n    Logger,\n    PerformanceEvents,\n    ShrOptions,\n    SignedHttpRequest,\n    SignedHttpRequestParameters,\n} from \"@azure/msal-common\";\nimport { base64Encode, urlEncode, urlEncodeArr } from \"../encode/Base64Encode\";\nimport { base64Decode } from \"../encode/Base64Decode\";\nimport * as BrowserCrypto from \"./BrowserCrypto\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError\";\nimport { CryptoKeyStore } from \"../cache/CryptoKeyStore\";\n\nexport type CachedKeyPair = {\n    publicKey: CryptoKey;\n    privateKey: CryptoKey;\n    requestMethod?: string;\n    requestUri?: string;\n};\n\n/**\n * This class implements MSAL's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and\n * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).\n */\nexport class CryptoOps implements ICrypto {\n    private logger: Logger;\n\n    /**\n     * CryptoOps can be used in contexts outside a PCA instance,\n     * meaning there won't be a performance manager available.\n     */\n    private performanceClient: IPerformanceClient | undefined;\n\n    private static POP_KEY_USAGES: Array<KeyUsage> = [\"sign\", \"verify\"];\n    private static EXTRACTABLE: boolean = true;\n    private cache: CryptoKeyStore;\n\n    constructor(logger: Logger, performanceClient?: IPerformanceClient) {\n        this.logger = logger;\n        // Browser crypto needs to be validated first before any other classes can be set.\n        BrowserCrypto.validateCryptoAvailable(logger);\n        this.cache = new CryptoKeyStore(this.logger);\n        this.performanceClient = performanceClient;\n    }\n\n    /**\n     * Creates a new random GUID - used to populate state and nonce.\n     * @returns string (GUID)\n     */\n    createNewGuid(): string {\n        return BrowserCrypto.createNewGuid();\n    }\n\n    /**\n     * Encodes input string to base64.\n     * @param input\n     */\n    base64Encode(input: string): string {\n        return base64Encode(input);\n    }\n\n    /**\n     * Decodes input string from base64.\n     * @param input\n     */\n    base64Decode(input: string): string {\n        return base64Decode(input);\n    }\n\n    /**\n     * Generates a keypair, stores it and returns a thumbprint\n     * @param request\n     */\n    async getPublicKeyThumbprint(\n        request: SignedHttpRequestParameters\n    ): Promise<string> {\n        const publicKeyThumbMeasurement =\n            this.performanceClient?.startMeasurement(\n                PerformanceEvents.CryptoOptsGetPublicKeyThumbprint,\n                request.correlationId\n            );\n\n        // Generate Keypair\n        const keyPair: CryptoKeyPair = await BrowserCrypto.generateKeyPair(\n            CryptoOps.EXTRACTABLE,\n            CryptoOps.POP_KEY_USAGES\n        );\n\n        // Generate Thumbprint for Public Key\n        const publicKeyJwk: JsonWebKey = await BrowserCrypto.exportJwk(\n            keyPair.publicKey\n        );\n\n        const pubKeyThumprintObj: JsonWebKey = {\n            e: publicKeyJwk.e,\n            kty: publicKeyJwk.kty,\n            n: publicKeyJwk.n,\n        };\n\n        const publicJwkString: string =\n            getSortedObjectString(pubKeyThumprintObj);\n        const publicJwkHash = await this.hashString(publicJwkString);\n\n        // Generate Thumbprint for Private Key\n        const privateKeyJwk: JsonWebKey = await BrowserCrypto.exportJwk(\n            keyPair.privateKey\n        );\n        // Re-import private key to make it unextractable\n        const unextractablePrivateKey: CryptoKey =\n            await BrowserCrypto.importJwk(privateKeyJwk, false, [\"sign\"]);\n\n        // Store Keypair data in keystore\n        await this.cache.asymmetricKeys.setItem(publicJwkHash, {\n            privateKey: unextractablePrivateKey,\n            publicKey: keyPair.publicKey,\n            requestMethod: request.resourceRequestMethod,\n            requestUri: request.resourceRequestUri,\n        });\n\n        if (publicKeyThumbMeasurement) {\n            publicKeyThumbMeasurement.end({\n                success: true,\n            });\n        }\n\n        return publicJwkHash;\n    }\n\n    /**\n     * Removes cryptographic keypair from key store matching the keyId passed in\n     * @param kid\n     */\n    async removeTokenBindingKey(kid: string): Promise<boolean> {\n        await this.cache.asymmetricKeys.removeItem(kid);\n        const keyFound = await this.cache.asymmetricKeys.containsKey(kid);\n        return !keyFound;\n    }\n\n    /**\n     * Removes all cryptographic keys from IndexedDB storage\n     */\n    async clearKeystore(): Promise<boolean> {\n        return this.cache.clear();\n    }\n\n    /**\n     * Signs the given object as a jwt payload with private key retrieved by given kid.\n     * @param payload\n     * @param kid\n     */\n    async signJwt(\n        payload: SignedHttpRequest,\n        kid: string,\n        shrOptions?: ShrOptions,\n        correlationId?: string\n    ): Promise<string> {\n        const signJwtMeasurement = this.performanceClient?.startMeasurement(\n            PerformanceEvents.CryptoOptsSignJwt,\n            correlationId\n        );\n        const cachedKeyPair = await this.cache.asymmetricKeys.getItem(kid);\n\n        if (!cachedKeyPair) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.cryptoKeyNotFound\n            );\n        }\n\n        // Get public key as JWK\n        const publicKeyJwk = await BrowserCrypto.exportJwk(\n            cachedKeyPair.publicKey\n        );\n        const publicKeyJwkString = getSortedObjectString(publicKeyJwk);\n        // Base64URL encode public key thumbprint with keyId only: BASE64URL({ kid: \"FULL_PUBLIC_KEY_HASH\" })\n        const encodedKeyIdThumbprint = urlEncode(JSON.stringify({ kid: kid }));\n        // Generate header\n        const shrHeader = JoseHeader.getShrHeaderString({\n            ...shrOptions?.header,\n            alg: publicKeyJwk.alg,\n            kid: encodedKeyIdThumbprint,\n        });\n\n        const encodedShrHeader = urlEncode(shrHeader);\n\n        // Generate payload\n        payload.cnf = {\n            jwk: JSON.parse(publicKeyJwkString),\n        };\n        const encodedPayload = urlEncode(JSON.stringify(payload));\n\n        // Form token string\n        const tokenString = `${encodedShrHeader}.${encodedPayload}`;\n\n        // Sign token\n        const encoder = new TextEncoder();\n        const tokenBuffer = encoder.encode(tokenString);\n        const signatureBuffer = await BrowserCrypto.sign(\n            cachedKeyPair.privateKey,\n            tokenBuffer\n        );\n        const encodedSignature = urlEncodeArr(new Uint8Array(signatureBuffer));\n\n        const signedJwt = `${tokenString}.${encodedSignature}`;\n\n        if (signJwtMeasurement) {\n            signJwtMeasurement.end({\n                success: true,\n            });\n        }\n\n        return signedJwt;\n    }\n\n    /**\n     * Returns the SHA-256 hash of an input string\n     * @param plainText\n     */\n    async hashString(plainText: string): Promise<string> {\n        const hashBuffer: ArrayBuffer = await BrowserCrypto.sha256Digest(\n            plainText\n        );\n        const hashBytes = new Uint8Array(hashBuffer);\n        return urlEncodeArr(hashBytes);\n    }\n}\n\nfunction getSortedObjectString(obj: object): string {\n    return JSON.stringify(obj, Object.keys(obj).sort());\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}