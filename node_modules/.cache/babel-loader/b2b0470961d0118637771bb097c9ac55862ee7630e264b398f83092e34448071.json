{"ast":null,"code":"/*! @azure/msal-browser v3.9.0 2024-02-07 */\n'use strict';\n\nimport { createClientAuthError, ClientAuthErrorCodes, ServerError, invokeAsync, PerformanceEvents } from '@azure/msal-common';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { TemporaryCacheKeys, ApiId } from '../utils/BrowserConstants.mjs';\nimport { emptyNavigateUri, userCancelled } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass RedirectHandler {\n  constructor(authCodeModule, storageImpl, authCodeRequest, logger, performanceClient) {\n    this.authModule = authCodeModule;\n    this.browserStorage = storageImpl;\n    this.authCodeRequest = authCodeRequest;\n    this.logger = logger;\n    this.performanceClient = performanceClient;\n  }\n  /**\n   * Redirects window to given URL.\n   * @param urlNavigate\n   */\n  async initiateAuthRequest(requestUrl, params) {\n    this.logger.verbose(\"RedirectHandler.initiateAuthRequest called\");\n    // Navigate if valid URL\n    if (requestUrl) {\n      // Cache start page, returns to this page after redirectUri if navigateToLoginRequestUrl is true\n      if (params.redirectStartPage) {\n        this.logger.verbose(\"RedirectHandler.initiateAuthRequest: redirectStartPage set, caching start page\");\n        this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, params.redirectStartPage, true);\n      }\n      // Set interaction status in the library.\n      this.browserStorage.setTemporaryCache(TemporaryCacheKeys.CORRELATION_ID, this.authCodeRequest.correlationId, true);\n      this.browserStorage.cacheCodeRequest(this.authCodeRequest);\n      this.logger.infoPii(`RedirectHandler.initiateAuthRequest: Navigate to: ${requestUrl}`);\n      const navigationOptions = {\n        apiId: ApiId.acquireTokenRedirect,\n        timeout: params.redirectTimeout,\n        noHistory: false\n      };\n      // If onRedirectNavigate is implemented, invoke it and provide requestUrl\n      if (typeof params.onRedirectNavigate === \"function\") {\n        this.logger.verbose(\"RedirectHandler.initiateAuthRequest: Invoking onRedirectNavigate callback\");\n        const navigate = params.onRedirectNavigate(requestUrl);\n        // Returning false from onRedirectNavigate will stop navigation\n        if (navigate !== false) {\n          this.logger.verbose(\"RedirectHandler.initiateAuthRequest: onRedirectNavigate did not return false, navigating\");\n          await params.navigationClient.navigateExternal(requestUrl, navigationOptions);\n          return;\n        } else {\n          this.logger.verbose(\"RedirectHandler.initiateAuthRequest: onRedirectNavigate returned false, stopping navigation\");\n          return;\n        }\n      } else {\n        // Navigate window to request URL\n        this.logger.verbose(\"RedirectHandler.initiateAuthRequest: Navigating window to navigate url\");\n        await params.navigationClient.navigateExternal(requestUrl, navigationOptions);\n        return;\n      }\n    } else {\n      // Throw error if request URL is empty.\n      this.logger.info(\"RedirectHandler.initiateAuthRequest: Navigate url is empty\");\n      throw createBrowserAuthError(emptyNavigateUri);\n    }\n  }\n  /**\n   * Handle authorization code response in the window.\n   * @param hash\n   */\n  async handleCodeResponse(response, state) {\n    this.logger.verbose(\"RedirectHandler.handleCodeResponse called\");\n    // Interaction is completed - remove interaction status.\n    this.browserStorage.setInteractionInProgress(false);\n    // Handle code response.\n    const stateKey = this.browserStorage.generateStateKey(state);\n    const requestState = this.browserStorage.getTemporaryCache(stateKey);\n    if (!requestState) {\n      throw createClientAuthError(ClientAuthErrorCodes.stateNotFound, \"Cached State\");\n    }\n    let authCodeResponse;\n    try {\n      authCodeResponse = this.authModule.handleFragmentResponse(response, requestState);\n    } catch (e) {\n      if (e instanceof ServerError && e.subError === userCancelled) {\n        // Translate server error caused by user closing native prompt to corresponding first class MSAL error\n        throw createBrowserAuthError(userCancelled);\n      } else {\n        throw e;\n      }\n    }\n    // Get cached items\n    const nonceKey = this.browserStorage.generateNonceKey(requestState);\n    const cachedNonce = this.browserStorage.getTemporaryCache(nonceKey);\n    // Assign code to request\n    this.authCodeRequest.code = authCodeResponse.code;\n    // Check for new cloud instance\n    if (authCodeResponse.cloud_instance_host_name) {\n      await invokeAsync(this.authModule.updateAuthority.bind(this.authModule), PerformanceEvents.UpdateTokenEndpointAuthority, this.logger, this.performanceClient, this.authCodeRequest.correlationId)(authCodeResponse.cloud_instance_host_name, this.authCodeRequest.correlationId);\n    }\n    authCodeResponse.nonce = cachedNonce || undefined;\n    authCodeResponse.state = requestState;\n    // Add CCS parameters if available\n    if (authCodeResponse.client_info) {\n      this.authCodeRequest.clientInfo = authCodeResponse.client_info;\n    } else {\n      const cachedCcsCred = this.checkCcsCredentials();\n      if (cachedCcsCred) {\n        this.authCodeRequest.ccsCredential = cachedCcsCred;\n      }\n    }\n    // Acquire token with retrieved code.\n    const tokenResponse = await this.authModule.acquireToken(this.authCodeRequest, authCodeResponse);\n    this.browserStorage.cleanRequestByState(state);\n    return tokenResponse;\n  }\n  /**\n   * Looks up ccs creds in the cache\n   */\n  checkCcsCredentials() {\n    // Look up ccs credential in temp cache\n    const cachedCcsCred = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, true);\n    if (cachedCcsCred) {\n      try {\n        return JSON.parse(cachedCcsCred);\n      } catch (e) {\n        this.authModule.logger.error(\"Cache credential could not be parsed\");\n        this.authModule.logger.errorPii(`Cache credential could not be parsed: ${cachedCcsCred}`);\n      }\n    }\n    return null;\n  }\n}\nexport { RedirectHandler };","map":{"version":3,"names":["RedirectHandler","constructor","authCodeModule","storageImpl","authCodeRequest","logger","performanceClient","authModule","browserStorage","initiateAuthRequest","requestUrl","params","verbose","redirectStartPage","setTemporaryCache","TemporaryCacheKeys","ORIGIN_URI","CORRELATION_ID","correlationId","cacheCodeRequest","infoPii","navigationOptions","apiId","ApiId","acquireTokenRedirect","timeout","redirectTimeout","noHistory","onRedirectNavigate","navigate","navigationClient","navigateExternal","info","createBrowserAuthError","emptyNavigateUri","handleCodeResponse","response","state","setInteractionInProgress","stateKey","generateStateKey","requestState","getTemporaryCache","createClientAuthError","ClientAuthErrorCodes","stateNotFound","authCodeResponse","handleFragmentResponse","e","ServerError","subError","userCancelled","nonceKey","generateNonceKey","cachedNonce","code","cloud_instance_host_name","invokeAsync","updateAuthority","bind","PerformanceEvents","UpdateTokenEndpointAuthority","nonce","undefined","client_info","clientInfo","cachedCcsCred","checkCcsCredentials","ccsCredential","tokenResponse","acquireToken","cleanRequestByState","CCS_CREDENTIAL","JSON","parse","error","errorPii"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\interaction_handler\\RedirectHandler.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AuthorizationCodeClient,\n    CommonAuthorizationCodeRequest,\n    Logger,\n    ServerError,\n    IPerformanceClient,\n    createClientAuthError,\n    ClientAuthErrorCodes,\n    CcsCredential,\n    invokeAsync,\n    PerformanceEvents,\n    ServerAuthorizationCodeResponse,\n} from \"@azure/msal-common\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError\";\nimport { ApiId, TemporaryCacheKeys } from \"../utils/BrowserConstants\";\nimport { BrowserCacheManager } from \"../cache/BrowserCacheManager\";\nimport { INavigationClient } from \"../navigation/INavigationClient\";\nimport { NavigationOptions } from \"../navigation/NavigationOptions\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\n\nexport type RedirectParams = {\n    navigationClient: INavigationClient;\n    redirectTimeout: number;\n    redirectStartPage: string;\n    onRedirectNavigate?: (url: string) => void | boolean;\n};\n\nexport class RedirectHandler {\n    authModule: AuthorizationCodeClient;\n    browserStorage: BrowserCacheManager;\n    authCodeRequest: CommonAuthorizationCodeRequest;\n    logger: Logger;\n    performanceClient: IPerformanceClient;\n\n    constructor(\n        authCodeModule: AuthorizationCodeClient,\n        storageImpl: BrowserCacheManager,\n        authCodeRequest: CommonAuthorizationCodeRequest,\n        logger: Logger,\n        performanceClient: IPerformanceClient\n    ) {\n        this.authModule = authCodeModule;\n        this.browserStorage = storageImpl;\n        this.authCodeRequest = authCodeRequest;\n        this.logger = logger;\n        this.performanceClient = performanceClient;\n    }\n\n    /**\n     * Redirects window to given URL.\n     * @param urlNavigate\n     */\n    async initiateAuthRequest(\n        requestUrl: string,\n        params: RedirectParams\n    ): Promise<void> {\n        this.logger.verbose(\"RedirectHandler.initiateAuthRequest called\");\n        // Navigate if valid URL\n        if (requestUrl) {\n            // Cache start page, returns to this page after redirectUri if navigateToLoginRequestUrl is true\n            if (params.redirectStartPage) {\n                this.logger.verbose(\n                    \"RedirectHandler.initiateAuthRequest: redirectStartPage set, caching start page\"\n                );\n                this.browserStorage.setTemporaryCache(\n                    TemporaryCacheKeys.ORIGIN_URI,\n                    params.redirectStartPage,\n                    true\n                );\n            }\n\n            // Set interaction status in the library.\n            this.browserStorage.setTemporaryCache(\n                TemporaryCacheKeys.CORRELATION_ID,\n                this.authCodeRequest.correlationId,\n                true\n            );\n            this.browserStorage.cacheCodeRequest(this.authCodeRequest);\n            this.logger.infoPii(\n                `RedirectHandler.initiateAuthRequest: Navigate to: ${requestUrl}`\n            );\n            const navigationOptions: NavigationOptions = {\n                apiId: ApiId.acquireTokenRedirect,\n                timeout: params.redirectTimeout,\n                noHistory: false,\n            };\n\n            // If onRedirectNavigate is implemented, invoke it and provide requestUrl\n            if (typeof params.onRedirectNavigate === \"function\") {\n                this.logger.verbose(\n                    \"RedirectHandler.initiateAuthRequest: Invoking onRedirectNavigate callback\"\n                );\n                const navigate = params.onRedirectNavigate(requestUrl);\n\n                // Returning false from onRedirectNavigate will stop navigation\n                if (navigate !== false) {\n                    this.logger.verbose(\n                        \"RedirectHandler.initiateAuthRequest: onRedirectNavigate did not return false, navigating\"\n                    );\n                    await params.navigationClient.navigateExternal(\n                        requestUrl,\n                        navigationOptions\n                    );\n                    return;\n                } else {\n                    this.logger.verbose(\n                        \"RedirectHandler.initiateAuthRequest: onRedirectNavigate returned false, stopping navigation\"\n                    );\n                    return;\n                }\n            } else {\n                // Navigate window to request URL\n                this.logger.verbose(\n                    \"RedirectHandler.initiateAuthRequest: Navigating window to navigate url\"\n                );\n                await params.navigationClient.navigateExternal(\n                    requestUrl,\n                    navigationOptions\n                );\n                return;\n            }\n        } else {\n            // Throw error if request URL is empty.\n            this.logger.info(\n                \"RedirectHandler.initiateAuthRequest: Navigate url is empty\"\n            );\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.emptyNavigateUri\n            );\n        }\n    }\n\n    /**\n     * Handle authorization code response in the window.\n     * @param hash\n     */\n    async handleCodeResponse(\n        response: ServerAuthorizationCodeResponse,\n        state: string\n    ): Promise<AuthenticationResult> {\n        this.logger.verbose(\"RedirectHandler.handleCodeResponse called\");\n\n        // Interaction is completed - remove interaction status.\n        this.browserStorage.setInteractionInProgress(false);\n\n        // Handle code response.\n        const stateKey = this.browserStorage.generateStateKey(state);\n        const requestState = this.browserStorage.getTemporaryCache(stateKey);\n        if (!requestState) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.stateNotFound,\n                \"Cached State\"\n            );\n        }\n\n        let authCodeResponse;\n        try {\n            authCodeResponse = this.authModule.handleFragmentResponse(\n                response,\n                requestState\n            );\n        } catch (e) {\n            if (\n                e instanceof ServerError &&\n                e.subError === BrowserAuthErrorCodes.userCancelled\n            ) {\n                // Translate server error caused by user closing native prompt to corresponding first class MSAL error\n                throw createBrowserAuthError(\n                    BrowserAuthErrorCodes.userCancelled\n                );\n            } else {\n                throw e;\n            }\n        }\n\n        // Get cached items\n        const nonceKey = this.browserStorage.generateNonceKey(requestState);\n        const cachedNonce = this.browserStorage.getTemporaryCache(nonceKey);\n\n        // Assign code to request\n        this.authCodeRequest.code = authCodeResponse.code;\n\n        // Check for new cloud instance\n        if (authCodeResponse.cloud_instance_host_name) {\n            await invokeAsync(\n                this.authModule.updateAuthority.bind(this.authModule),\n                PerformanceEvents.UpdateTokenEndpointAuthority,\n                this.logger,\n                this.performanceClient,\n                this.authCodeRequest.correlationId\n            )(\n                authCodeResponse.cloud_instance_host_name,\n                this.authCodeRequest.correlationId\n            );\n        }\n\n        authCodeResponse.nonce = cachedNonce || undefined;\n        authCodeResponse.state = requestState;\n\n        // Add CCS parameters if available\n        if (authCodeResponse.client_info) {\n            this.authCodeRequest.clientInfo = authCodeResponse.client_info;\n        } else {\n            const cachedCcsCred = this.checkCcsCredentials();\n            if (cachedCcsCred) {\n                this.authCodeRequest.ccsCredential = cachedCcsCred;\n            }\n        }\n\n        // Acquire token with retrieved code.\n        const tokenResponse = (await this.authModule.acquireToken(\n            this.authCodeRequest,\n            authCodeResponse\n        )) as AuthenticationResult;\n\n        this.browserStorage.cleanRequestByState(state);\n        return tokenResponse;\n    }\n\n    /**\n     * Looks up ccs creds in the cache\n     */\n    protected checkCcsCredentials(): CcsCredential | null {\n        // Look up ccs credential in temp cache\n        const cachedCcsCred = this.browserStorage.getTemporaryCache(\n            TemporaryCacheKeys.CCS_CREDENTIAL,\n            true\n        );\n        if (cachedCcsCred) {\n            try {\n                return JSON.parse(cachedCcsCred) as CcsCredential;\n            } catch (e) {\n                this.authModule.logger.error(\n                    \"Cache credential could not be parsed\"\n                );\n                this.authModule.logger.errorPii(\n                    `Cache credential could not be parsed: ${cachedCcsCred}`\n                );\n            }\n        }\n        return null;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}