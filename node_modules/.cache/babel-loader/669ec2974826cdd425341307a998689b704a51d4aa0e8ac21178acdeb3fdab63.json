{"ast":null,"code":"/*! @azure/msal-common v14.0.3 2023-09-05 */\n'use strict';\n\nimport { BaseClient } from './BaseClient.mjs';\nimport { TimeUtils } from '../utils/TimeUtils.mjs';\nimport { RefreshTokenClient } from './RefreshTokenClient.mjs';\nimport { ClientAuthError, ClientAuthErrorMessage } from '../error/ClientAuthError.mjs';\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.mjs';\nimport { ResponseHandler } from '../response/ResponseHandler.mjs';\nimport { CacheOutcome } from '../utils/Constants.mjs';\nimport { StringUtils } from '../utils/StringUtils.mjs';\nimport { extractTokenClaims, checkMaxAge } from '../account/AuthToken.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/** @internal */\nclass SilentFlowClient extends BaseClient {\n  constructor(configuration, performanceClient) {\n    super(configuration, performanceClient);\n  }\n  /**\n   * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew\n   * the given token and returns the renewed token\n   * @param request\n   */\n  async acquireToken(request) {\n    try {\n      return await this.acquireCachedToken(request);\n    } catch (e) {\n      if (e instanceof ClientAuthError && e.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {\n        const refreshTokenClient = new RefreshTokenClient(this.config, this.performanceClient);\n        return refreshTokenClient.acquireTokenByRefreshToken(request);\n      } else {\n        throw e;\n      }\n    }\n  }\n  /**\n   * Retrieves token from cache or throws an error if it must be refreshed.\n   * @param request\n   */\n  async acquireCachedToken(request) {\n    // Cannot renew token if no request object is given.\n    if (!request) {\n      throw ClientConfigurationError.createEmptyTokenRequestError();\n    }\n    if (request.forceRefresh) {\n      // Must refresh due to present force_refresh flag.\n      this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.FORCE_REFRESH);\n      this.logger.info(\"SilentFlowClient:acquireCachedToken - Skipping cache because forceRefresh is true.\");\n      throw ClientAuthError.createRefreshRequiredError();\n    } else if (!this.config.cacheOptions.claimsBasedCachingEnabled && !StringUtils.isEmptyObj(request.claims)) {\n      // Must refresh due to request parameters.\n      this.logger.info(\"SilentFlowClient:acquireCachedToken - Skipping cache because claims-based caching is disabled and claims were requested.\");\n      throw ClientAuthError.createRefreshRequiredError();\n    }\n    // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n    if (!request.account) {\n      throw ClientAuthError.createNoAccountInSilentRequestError();\n    }\n    const environment = request.authority || this.authority.getPreferredCache();\n    const cacheRecord = this.cacheManager.readCacheRecord(request.account, request, environment);\n    if (!cacheRecord.accessToken) {\n      // Must refresh due to non-existent access_token.\n      this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);\n      this.logger.info(\"SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.\");\n      throw ClientAuthError.createRefreshRequiredError();\n    } else if (TimeUtils.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) || TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {\n      // Must refresh due to expired access_token.\n      this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);\n      this.logger.info(`SilentFlowClient:acquireCachedToken - Cached access token is expired or will expire within ${this.config.systemOptions.tokenRenewalOffsetSeconds} seconds.`);\n      throw ClientAuthError.createRefreshRequiredError();\n    } else if (cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {\n      // Must refresh due to the refresh_in value.\n      this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN);\n      this.logger.info(\"SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'.\");\n      throw ClientAuthError.createRefreshRequiredError();\n    }\n    if (this.config.serverTelemetryManager) {\n      this.config.serverTelemetryManager.incrementCacheHits();\n    }\n    return await this.generateResultFromCacheRecord(cacheRecord, request);\n  }\n  /**\n   * Helper function to build response object from the CacheRecord\n   * @param cacheRecord\n   */\n  async generateResultFromCacheRecord(cacheRecord, request) {\n    let idTokenClaims;\n    if (cacheRecord.idToken) {\n      idTokenClaims = extractTokenClaims(cacheRecord.idToken.secret, this.config.cryptoInterface.base64Decode);\n    }\n    // token max_age check\n    if (request.maxAge || request.maxAge === 0) {\n      const authTime = idTokenClaims?.auth_time;\n      if (!authTime) {\n        throw ClientAuthError.createAuthTimeNotFoundError();\n      }\n      checkMaxAge(authTime, request.maxAge);\n    }\n    return await ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenClaims);\n  }\n}\nexport { SilentFlowClient };","map":{"version":3,"names":["SilentFlowClient","BaseClient","acquireToken","request"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-common\\src\\client\\SilentFlowClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { BaseClient } from \"./BaseClient\";\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\nimport { CommonSilentFlowRequest } from \"../request/CommonSilentFlowRequest\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\nimport { TimeUtils } from \"../utils/TimeUtils\";\nimport { RefreshTokenClient } from \"./RefreshTokenClient\";\nimport {\n    ClientAuthError,\n    ClientAuthErrorMessage,\n} from \"../error/ClientAuthError\";\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\nimport { ResponseHandler } from \"../response/ResponseHandler\";\nimport { CacheRecord } from \"../cache/entities/CacheRecord\";\nimport { CacheOutcome } from \"../utils/Constants\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\nimport { StringUtils } from \"../utils/StringUtils\";\nimport { checkMaxAge, extractTokenClaims } from \"../account/AuthToken\";\nimport { TokenClaims } from \"../account/TokenClaims\";\n\n/** @internal */\nexport class SilentFlowClient extends BaseClient {\n    constructor(\n        configuration: ClientConfiguration,\n        performanceClient?: IPerformanceClient\n    ) {\n        super(configuration, performanceClient);\n    }\n\n    /**\n     * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew\n     * the given token and returns the renewed token\n     * @param request\n     */\n    async acquireToken(\n        request: CommonSilentFlowRequest\n    ): Promise<AuthenticationResult> {\n        try {\n            return await this.acquireCachedToken(request);\n        } catch (e) {\n            if (\n                e instanceof ClientAuthError &&\n                e.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code\n            ) {\n                const refreshTokenClient = new RefreshTokenClient(\n                    this.config,\n                    this.performanceClient\n                );\n                return refreshTokenClient.acquireTokenByRefreshToken(request);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    /**\n     * Retrieves token from cache or throws an error if it must be refreshed.\n     * @param request\n     */\n    async acquireCachedToken(\n        request: CommonSilentFlowRequest\n    ): Promise<AuthenticationResult> {\n        // Cannot renew token if no request object is given.\n        if (!request) {\n            throw ClientConfigurationError.createEmptyTokenRequestError();\n        }\n\n        if (request.forceRefresh) {\n            // Must refresh due to present force_refresh flag.\n            this.serverTelemetryManager?.setCacheOutcome(\n                CacheOutcome.FORCE_REFRESH\n            );\n            this.logger.info(\n                \"SilentFlowClient:acquireCachedToken - Skipping cache because forceRefresh is true.\"\n            );\n            throw ClientAuthError.createRefreshRequiredError();\n        } else if (\n            !this.config.cacheOptions.claimsBasedCachingEnabled &&\n            !StringUtils.isEmptyObj(request.claims)\n        ) {\n            // Must refresh due to request parameters.\n            this.logger.info(\n                \"SilentFlowClient:acquireCachedToken - Skipping cache because claims-based caching is disabled and claims were requested.\"\n            );\n            throw ClientAuthError.createRefreshRequiredError();\n        }\n\n        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n        if (!request.account) {\n            throw ClientAuthError.createNoAccountInSilentRequestError();\n        }\n\n        const environment =\n            request.authority || this.authority.getPreferredCache();\n\n        const cacheRecord = this.cacheManager.readCacheRecord(\n            request.account,\n            request,\n            environment\n        );\n\n        if (!cacheRecord.accessToken) {\n            // Must refresh due to non-existent access_token.\n            this.serverTelemetryManager?.setCacheOutcome(\n                CacheOutcome.NO_CACHED_ACCESS_TOKEN\n            );\n            this.logger.info(\n                \"SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.\"\n            );\n            throw ClientAuthError.createRefreshRequiredError();\n        } else if (\n            TimeUtils.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) ||\n            TimeUtils.isTokenExpired(\n                cacheRecord.accessToken.expiresOn,\n                this.config.systemOptions.tokenRenewalOffsetSeconds\n            )\n        ) {\n            // Must refresh due to expired access_token.\n            this.serverTelemetryManager?.setCacheOutcome(\n                CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED\n            );\n            this.logger.info(\n                `SilentFlowClient:acquireCachedToken - Cached access token is expired or will expire within ${this.config.systemOptions.tokenRenewalOffsetSeconds} seconds.`\n            );\n            throw ClientAuthError.createRefreshRequiredError();\n        } else if (\n            cacheRecord.accessToken.refreshOn &&\n            TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)\n        ) {\n            // Must refresh due to the refresh_in value.\n            this.serverTelemetryManager?.setCacheOutcome(\n                CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN\n            );\n            this.logger.info(\n                \"SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'.\"\n            );\n            throw ClientAuthError.createRefreshRequiredError();\n        }\n\n        if (this.config.serverTelemetryManager) {\n            this.config.serverTelemetryManager.incrementCacheHits();\n        }\n\n        return await this.generateResultFromCacheRecord(cacheRecord, request);\n    }\n\n    /**\n     * Helper function to build response object from the CacheRecord\n     * @param cacheRecord\n     */\n    private async generateResultFromCacheRecord(\n        cacheRecord: CacheRecord,\n        request: CommonSilentFlowRequest\n    ): Promise<AuthenticationResult> {\n        let idTokenClaims: TokenClaims | undefined;\n        if (cacheRecord.idToken) {\n            idTokenClaims = extractTokenClaims(\n                cacheRecord.idToken.secret,\n                this.config.cryptoInterface.base64Decode\n            );\n        }\n\n        // token max_age check\n        if (request.maxAge || request.maxAge === 0) {\n            const authTime = idTokenClaims?.auth_time;\n            if (!authTime) {\n                throw ClientAuthError.createAuthTimeNotFoundError();\n            }\n\n            checkMaxAge(authTime, request.maxAge);\n        }\n\n        return await ResponseHandler.generateAuthenticationResult(\n            this.cryptoUtils,\n            this.authority,\n            cacheRecord,\n            true,\n            request,\n            idTokenClaims\n        );\n    }\n}\n"],"mappings":";;;;;;;;;;;;;AAKA;AACA;AACA;AACA;;AAmDI,MAAAA,gBAAA,SAAAC,UAAA;;;EAGG;;AAwFH;;;AAGG;oBACwCC,CAAAC,OAAA;IA+B9C"},"metadata":{},"sourceType":"module","externalDependencies":[]}