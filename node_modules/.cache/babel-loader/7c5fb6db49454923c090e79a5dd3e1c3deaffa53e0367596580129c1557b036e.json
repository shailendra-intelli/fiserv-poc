{"ast":null,"code":"/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\n\nimport { PerformanceEvents, ClientAuthError, ServerError, invokeAsync, AuthorityFactory } from '@azure/msal-common';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { TemporaryCacheKeys } from '../utils/BrowserConstants.mjs';\nimport { hashEmptyError, userCancelled } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Abstract class which defines operations for a browser interaction handling class.\n */\nclass InteractionHandler {\n  constructor(authCodeModule, storageImpl, authCodeRequest, logger, performanceClient) {\n    this.authModule = authCodeModule;\n    this.browserStorage = storageImpl;\n    this.authCodeRequest = authCodeRequest;\n    this.logger = logger;\n    this.performanceClient = performanceClient;\n  }\n  /**\n   * Function to handle response parameters from hash.\n   * @param locationHash\n   */\n  async handleCodeResponseFromHash(locationHash, state, authority, networkModule) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponseFromHash, this.authCodeRequest.correlationId);\n    this.logger.verbose(\"InteractionHandler.handleCodeResponse called\");\n    // Check that location hash isn't empty.\n    if (!locationHash) {\n      throw createBrowserAuthError(hashEmptyError);\n    }\n    // Handle code response.\n    const stateKey = this.browserStorage.generateStateKey(state);\n    const requestState = this.browserStorage.getTemporaryCache(stateKey);\n    if (!requestState) {\n      throw ClientAuthError.createStateNotFoundError(\"Cached State\");\n    }\n    let authCodeResponse;\n    try {\n      authCodeResponse = this.authModule.handleFragmentResponse(locationHash, requestState);\n    } catch (e) {\n      if (e instanceof ServerError && e.subError === userCancelled) {\n        // Translate server error caused by user closing native prompt to corresponding first class MSAL error\n        throw createBrowserAuthError(userCancelled);\n      } else {\n        throw e;\n      }\n    }\n    this.performanceClient.setPreQueueTime(PerformanceEvents.HandleCodeResponseFromServer, this.authCodeRequest.correlationId);\n    return this.handleCodeResponseFromServer(authCodeResponse, state, authority, networkModule);\n  }\n  /**\n   * Process auth code response from AAD\n   * @param authCodeResponse\n   * @param state\n   * @param authority\n   * @param networkModule\n   * @returns\n   */\n  async handleCodeResponseFromServer(authCodeResponse, state, authority, networkModule, validateNonce = true) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.HandleCodeResponseFromServer, this.authCodeRequest.correlationId);\n    this.logger.trace(\"InteractionHandler.handleCodeResponseFromServer called\");\n    // Handle code response.\n    const stateKey = this.browserStorage.generateStateKey(state);\n    const requestState = this.browserStorage.getTemporaryCache(stateKey);\n    if (!requestState) {\n      throw ClientAuthError.createStateNotFoundError(\"Cached State\");\n    }\n    // Get cached items\n    const nonceKey = this.browserStorage.generateNonceKey(requestState);\n    const cachedNonce = this.browserStorage.getTemporaryCache(nonceKey);\n    // Assign code to request\n    this.authCodeRequest.code = authCodeResponse.code;\n    // Check for new cloud instance\n    if (authCodeResponse.cloud_instance_host_name) {\n      this.performanceClient.setPreQueueTime(PerformanceEvents.UpdateTokenEndpointAuthority, this.authCodeRequest.correlationId);\n      await this.updateTokenEndpointAuthority(authCodeResponse.cloud_instance_host_name, authority, networkModule);\n    }\n    // Nonce validation not needed when redirect not involved (e.g. hybrid spa, renewing token via rt)\n    if (validateNonce) {\n      authCodeResponse.nonce = cachedNonce || undefined;\n    }\n    authCodeResponse.state = requestState;\n    // Add CCS parameters if available\n    if (authCodeResponse.client_info) {\n      this.authCodeRequest.clientInfo = authCodeResponse.client_info;\n    } else {\n      const cachedCcsCred = this.checkCcsCredentials();\n      if (cachedCcsCred) {\n        this.authCodeRequest.ccsCredential = cachedCcsCred;\n      }\n    }\n    // Acquire token with retrieved code.\n    const tokenResponse = await invokeAsync(this.authModule.acquireToken.bind(this.authModule), PerformanceEvents.AuthClientAcquireToken, this.logger, this.performanceClient, this.authCodeRequest.correlationId)(this.authCodeRequest, authCodeResponse);\n    this.browserStorage.cleanRequestByState(state);\n    return tokenResponse;\n  }\n  /**\n   * Updates authority based on cloudInstanceHostname\n   * @param cloudInstanceHostname\n   * @param authority\n   * @param networkModule\n   */\n  async updateTokenEndpointAuthority(cloudInstanceHostname, authority, networkModule) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.UpdateTokenEndpointAuthority, this.authCodeRequest.correlationId);\n    const cloudInstanceAuthorityUri = `https://${cloudInstanceHostname}/${authority.tenant}/`;\n    const cloudInstanceAuthority = await AuthorityFactory.createDiscoveredInstance(cloudInstanceAuthorityUri, networkModule, this.browserStorage, authority.options, this.logger, this.performanceClient, this.authCodeRequest.correlationId);\n    this.authModule.updateAuthority(cloudInstanceAuthority);\n  }\n  /**\n   * Looks up ccs creds in the cache\n   */\n  checkCcsCredentials() {\n    // Look up ccs credential in temp cache\n    const cachedCcsCred = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, true);\n    if (cachedCcsCred) {\n      try {\n        return JSON.parse(cachedCcsCred);\n      } catch (e) {\n        this.authModule.logger.error(\"Cache credential could not be parsed\");\n        this.authModule.logger.errorPii(`Cache credential could not be parsed: ${cachedCcsCred}`);\n      }\n    }\n    return null;\n  }\n}\nexport { InteractionHandler };","map":{"version":3,"names":["InteractionHandler","constructor","authCodeModule","storageImpl","authCodeRequest","logger","performanceClient","authModule","browserStorage","locationHash","createBrowserAuthError","hashEmptyError","ClientAuthError","createStateNotFoundError","authCodeResponse","handleFragmentResponse","requestState","e"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\interaction_handler\\InteractionHandler.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AuthorizationCodePayload,\n    CommonAuthorizationCodeRequest,\n    AuthorizationCodeClient,\n    AuthorityFactory,\n    Authority,\n    INetworkModule,\n    ClientAuthError,\n    CcsCredential,\n    Logger,\n    ServerError,\n    IPerformanceClient,\n    PerformanceEvents,\n    invokeAsync,\n} from \"@azure/msal-common\";\n\nimport { BrowserCacheManager } from \"../cache/BrowserCacheManager\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError\";\nimport { TemporaryCacheKeys } from \"../utils/BrowserConstants\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\n\nexport type InteractionParams = {};\n\n/**\n * Abstract class which defines operations for a browser interaction handling class.\n */\nexport class InteractionHandler {\n    protected authModule: AuthorizationCodeClient;\n    protected browserStorage: BrowserCacheManager;\n    protected authCodeRequest: CommonAuthorizationCodeRequest;\n    protected logger: Logger;\n    protected performanceClient: IPerformanceClient;\n\n    constructor(\n        authCodeModule: AuthorizationCodeClient,\n        storageImpl: BrowserCacheManager,\n        authCodeRequest: CommonAuthorizationCodeRequest,\n        logger: Logger,\n        performanceClient: IPerformanceClient\n    ) {\n        this.authModule = authCodeModule;\n        this.browserStorage = storageImpl;\n        this.authCodeRequest = authCodeRequest;\n        this.logger = logger;\n        this.performanceClient = performanceClient;\n    }\n\n    /**\n     * Function to handle response parameters from hash.\n     * @param locationHash\n     */\n    async handleCodeResponseFromHash(\n        locationHash: string,\n        state: string,\n        authority: Authority,\n        networkModule: INetworkModule\n    ): Promise<AuthenticationResult> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.HandleCodeResponseFromHash,\n            this.authCodeRequest.correlationId\n        );\n        this.logger.verbose(\"InteractionHandler.handleCodeResponse called\");\n        // Check that location hash isn't empty.\n        if (!locationHash) {\n            throw createBrowserAuthError(BrowserAuthErrorCodes.hashEmptyError);\n        }\n\n        // Handle code response.\n        const stateKey = this.browserStorage.generateStateKey(state);\n        const requestState = this.browserStorage.getTemporaryCache(stateKey);\n        if (!requestState) {\n            throw ClientAuthError.createStateNotFoundError(\"Cached State\");\n        }\n\n        let authCodeResponse;\n        try {\n            authCodeResponse = this.authModule.handleFragmentResponse(\n                locationHash,\n                requestState\n            );\n        } catch (e) {\n            if (\n                e instanceof ServerError &&\n                e.subError === BrowserAuthErrorCodes.userCancelled\n            ) {\n                // Translate server error caused by user closing native prompt to corresponding first class MSAL error\n                throw createBrowserAuthError(\n                    BrowserAuthErrorCodes.userCancelled\n                );\n            } else {\n                throw e;\n            }\n        }\n\n        this.performanceClient.setPreQueueTime(\n            PerformanceEvents.HandleCodeResponseFromServer,\n            this.authCodeRequest.correlationId\n        );\n        return this.handleCodeResponseFromServer(\n            authCodeResponse,\n            state,\n            authority,\n            networkModule\n        );\n    }\n\n    /**\n     * Process auth code response from AAD\n     * @param authCodeResponse\n     * @param state\n     * @param authority\n     * @param networkModule\n     * @returns\n     */\n    async handleCodeResponseFromServer(\n        authCodeResponse: AuthorizationCodePayload,\n        state: string,\n        authority: Authority,\n        networkModule: INetworkModule,\n        validateNonce: boolean = true\n    ): Promise<AuthenticationResult> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.HandleCodeResponseFromServer,\n            this.authCodeRequest.correlationId\n        );\n        this.logger.trace(\n            \"InteractionHandler.handleCodeResponseFromServer called\"\n        );\n\n        // Handle code response.\n        const stateKey = this.browserStorage.generateStateKey(state);\n        const requestState = this.browserStorage.getTemporaryCache(stateKey);\n        if (!requestState) {\n            throw ClientAuthError.createStateNotFoundError(\"Cached State\");\n        }\n\n        // Get cached items\n        const nonceKey = this.browserStorage.generateNonceKey(requestState);\n        const cachedNonce = this.browserStorage.getTemporaryCache(nonceKey);\n\n        // Assign code to request\n        this.authCodeRequest.code = authCodeResponse.code;\n\n        // Check for new cloud instance\n        if (authCodeResponse.cloud_instance_host_name) {\n            this.performanceClient.setPreQueueTime(\n                PerformanceEvents.UpdateTokenEndpointAuthority,\n                this.authCodeRequest.correlationId\n            );\n            await this.updateTokenEndpointAuthority(\n                authCodeResponse.cloud_instance_host_name,\n                authority,\n                networkModule\n            );\n        }\n\n        // Nonce validation not needed when redirect not involved (e.g. hybrid spa, renewing token via rt)\n        if (validateNonce) {\n            authCodeResponse.nonce = cachedNonce || undefined;\n        }\n\n        authCodeResponse.state = requestState;\n\n        // Add CCS parameters if available\n        if (authCodeResponse.client_info) {\n            this.authCodeRequest.clientInfo = authCodeResponse.client_info;\n        } else {\n            const cachedCcsCred = this.checkCcsCredentials();\n            if (cachedCcsCred) {\n                this.authCodeRequest.ccsCredential = cachedCcsCred;\n            }\n        }\n\n        // Acquire token with retrieved code.\n        const tokenResponse = (await invokeAsync(\n            this.authModule.acquireToken.bind(this.authModule),\n            PerformanceEvents.AuthClientAcquireToken,\n            this.logger,\n            this.performanceClient,\n            this.authCodeRequest.correlationId\n        )(this.authCodeRequest, authCodeResponse)) as AuthenticationResult;\n        this.browserStorage.cleanRequestByState(state);\n        return tokenResponse;\n    }\n\n    /**\n     * Updates authority based on cloudInstanceHostname\n     * @param cloudInstanceHostname\n     * @param authority\n     * @param networkModule\n     */\n    protected async updateTokenEndpointAuthority(\n        cloudInstanceHostname: string,\n        authority: Authority,\n        networkModule: INetworkModule\n    ): Promise<void> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.UpdateTokenEndpointAuthority,\n            this.authCodeRequest.correlationId\n        );\n        const cloudInstanceAuthorityUri = `https://${cloudInstanceHostname}/${authority.tenant}/`;\n        const cloudInstanceAuthority =\n            await AuthorityFactory.createDiscoveredInstance(\n                cloudInstanceAuthorityUri,\n                networkModule,\n                this.browserStorage,\n                authority.options,\n                this.logger,\n                this.performanceClient,\n                this.authCodeRequest.correlationId\n            );\n        this.authModule.updateAuthority(cloudInstanceAuthority);\n    }\n\n    /**\n     * Looks up ccs creds in the cache\n     */\n    protected checkCcsCredentials(): CcsCredential | null {\n        // Look up ccs credential in temp cache\n        const cachedCcsCred = this.browserStorage.getTemporaryCache(\n            TemporaryCacheKeys.CCS_CREDENTIAL,\n            true\n        );\n        if (cachedCcsCred) {\n            try {\n                return JSON.parse(cachedCcsCred) as CcsCredential;\n            } catch (e) {\n                this.authModule.logger.error(\n                    \"Cache credential could not be parsed\"\n                );\n                this.authModule.logger.errorPii(\n                    `Cache credential could not be parsed: ${cachedCcsCred}`\n                );\n            }\n        }\n        return null;\n    }\n}\n"],"mappings":";;;;;;;;AAKA;AAgBA;AAMA;AAEA;AAKA;AACI;AACA;AACA,MAASA,kBAAkB;EAC3BC,WAAUA,CAAAC,cAAe,EAAAC,WAAA,EAAAC,eAAA,EAAAC,MAAA,EAAAC,iBAAA;IACzB,KAASC,UAAC,GAAAL,cAAmB;IAGzB,KAAAM,cAAA,GAAcL,WAAyB;IAa3C,KAAAC,eAAA,GAAAA,eAAA;;;EAGG;;AAwDH;;;;;;;IAOG,KAAAK,YAAA;MAC+B,MAAAC,sBACd,CAAAC,cAChB;IAqEJ;;;;;MAKG,MAAAC,eAAA,CAAAC,wBAAA;IACa;IAuBhB,IAAAC,gBAAA;;MAEGA,gBAAA,QAAAP,UAAA,CAAAQ,sBAAA,CAAAN,YAAA,EAAAO,YAAA;IACH,EAoBH,OAAAC,CAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}