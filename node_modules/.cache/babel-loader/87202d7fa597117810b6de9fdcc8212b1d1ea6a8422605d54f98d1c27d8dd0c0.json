{"ast":null,"code":"/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\n\nimport { PerformanceEvents, Constants, UrlString } from '@azure/msal-common';\nimport { InteractionHandler } from './InteractionHandler.mjs';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { DEFAULT_IFRAME_TIMEOUT_MS } from '../config/Configuration.mjs';\nimport { emptyNavigateUri, monitorWindowTimeout, hashDoesNotContainKnownProperties, hashEmptyError } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass SilentHandler extends InteractionHandler {\n  constructor(authCodeModule, storageImpl, authCodeRequest, logger, systemOptions, performanceClient) {\n    super(authCodeModule, storageImpl, authCodeRequest, logger, performanceClient);\n    this.navigateFrameWait = systemOptions.navigateFrameWait;\n    this.pollIntervalMilliseconds = systemOptions.pollIntervalMilliseconds;\n  }\n  /**\n   * Creates a hidden iframe to given URL using user-requested scopes as an id.\n   * @param urlNavigate\n   * @param userRequestScopes\n   */\n  async initiateAuthRequest(requestUrl) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerInitiateAuthRequest, this.authCodeRequest.correlationId);\n    if (!requestUrl) {\n      // Throw error if request URL is empty.\n      this.logger.info(\"Navigate url is empty\");\n      throw createBrowserAuthError(emptyNavigateUri);\n    }\n    if (this.navigateFrameWait) {\n      this.performanceClient.setPreQueueTime(PerformanceEvents.SilentHandlerLoadFrame, this.authCodeRequest.correlationId);\n      return await this.loadFrame(requestUrl);\n    }\n    return this.loadFrameSync(requestUrl);\n  }\n  /**\n   * Monitors an iframe content window until it loads a url with a known hash, or hits a specified timeout.\n   * @param iframe\n   * @param timeout\n   */\n  monitorIframeForHash(iframe, timeout) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerMonitorIframeForHash, this.authCodeRequest.correlationId);\n    return new Promise((resolve, reject) => {\n      if (timeout < DEFAULT_IFRAME_TIMEOUT_MS) {\n        this.logger.warning(`system.loadFrameTimeout or system.iframeHashTimeout set to lower (${timeout}ms) than the default (${DEFAULT_IFRAME_TIMEOUT_MS}ms). This may result in timeouts.`);\n      }\n      /*\n       * Polling for iframes can be purely timing based,\n       * since we don't need to account for interaction.\n       */\n      const nowMark = window.performance.now();\n      const timeoutMark = nowMark + timeout;\n      const intervalId = setInterval(() => {\n        if (window.performance.now() > timeoutMark) {\n          this.removeHiddenIframe(iframe);\n          clearInterval(intervalId);\n          reject(createBrowserAuthError(monitorWindowTimeout));\n          return;\n        }\n        let href = Constants.EMPTY_STRING;\n        const contentWindow = iframe.contentWindow;\n        try {\n          /*\n           * Will throw if cross origin,\n           * which should be caught and ignored\n           * since we need the interval to keep running while on STS UI.\n           */\n          href = contentWindow ? contentWindow.location.href : Constants.EMPTY_STRING;\n        } catch (e) {}\n        if (!href || href === \"about:blank\") {\n          return;\n        }\n        const contentHash = contentWindow ? contentWindow.location.hash : Constants.EMPTY_STRING;\n        if (contentHash) {\n          if (UrlString.hashContainsKnownProperties(contentHash)) {\n            // Success case\n            this.removeHiddenIframe(iframe);\n            clearInterval(intervalId);\n            resolve(contentHash);\n            return;\n          } else {\n            // Hash is present but incorrect\n            this.logger.error(\"SilentHandler:monitorIFrameForHash - a hash is present in the iframe but it does not contain known properties. It's likely that the hash has been replaced by code running on the redirectUri page.\");\n            this.logger.errorPii(`SilentHandler:monitorIFrameForHash - the url detected in the iframe is: ${href}`);\n            this.removeHiddenIframe(iframe);\n            clearInterval(intervalId);\n            reject(createBrowserAuthError(hashDoesNotContainKnownProperties));\n            return;\n          }\n        } else {\n          // No hash is present\n          this.logger.error(\"SilentHandler:monitorIFrameForHash - the request has returned to the redirectUri but a hash is not present in the iframe. It's likely that the hash has been removed or the page has been redirected by code running on the redirectUri page.\");\n          this.logger.errorPii(`SilentHandler:monitorIFrameForHash - the url detected in the iframe is: ${href}`);\n          this.removeHiddenIframe(iframe);\n          clearInterval(intervalId);\n          reject(createBrowserAuthError(hashEmptyError));\n          return;\n        }\n      }, this.pollIntervalMilliseconds);\n    });\n  }\n  /**\n   * @hidden\n   * Loads iframe with authorization endpoint URL\n   * @ignore\n   */\n  loadFrame(urlNavigate) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.SilentHandlerLoadFrame, this.authCodeRequest.correlationId);\n    /*\n     * This trick overcomes iframe navigation in IE\n     * IE does not load the page consistently in iframe\n     */\n    return new Promise((resolve, reject) => {\n      const frameHandle = this.createHiddenIframe();\n      setTimeout(() => {\n        if (!frameHandle) {\n          reject(\"Unable to load iframe\");\n          return;\n        }\n        frameHandle.src = urlNavigate;\n        resolve(frameHandle);\n      }, this.navigateFrameWait);\n    });\n  }\n  /**\n   * @hidden\n   * Loads the iframe synchronously when the navigateTimeFrame is set to `0`\n   * @param urlNavigate\n   * @param frameName\n   * @param logger\n   */\n  loadFrameSync(urlNavigate) {\n    const frameHandle = this.createHiddenIframe();\n    frameHandle.src = urlNavigate;\n    return frameHandle;\n  }\n  /**\n   * @hidden\n   * Creates a new hidden iframe or gets an existing one for silent token renewal.\n   * @ignore\n   */\n  createHiddenIframe() {\n    const authFrame = document.createElement(\"iframe\");\n    authFrame.style.visibility = \"hidden\";\n    authFrame.style.position = \"absolute\";\n    authFrame.style.width = authFrame.style.height = \"0\";\n    authFrame.style.border = \"0\";\n    authFrame.setAttribute(\"sandbox\", \"allow-scripts allow-same-origin allow-forms\");\n    document.getElementsByTagName(\"body\")[0].appendChild(authFrame);\n    return authFrame;\n  }\n  /**\n   * @hidden\n   * Removes a hidden iframe from the page.\n   * @ignore\n   */\n  removeHiddenIframe(iframe) {\n    if (document.body === iframe.parentNode) {\n      document.body.removeChild(iframe);\n    }\n  }\n}\nexport { SilentHandler };","map":{"version":3,"names":["SilentHandler","InteractionHandler","pollIntervalMilliseconds","systemOptions","initiateAuthRequest","requestUrl","performanceClient","addQueueMeasurement","PerformanceEvents","SilentHandlerInitiateAuthRequest","authCodeRequest","correlationId","createBrowserAuthError","emptyNavigateUri","navigateFrameWait","SilentHandlerMonitorIframeForHash","Promise","resolve","reject","timeout","DEFAULT_IFRAME_TIMEOUT_MS"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\interaction_handler\\SilentHandler.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    UrlString,\n    CommonAuthorizationCodeRequest,\n    AuthorizationCodeClient,\n    Constants,\n    Logger,\n    IPerformanceClient,\n    PerformanceEvents,\n} from \"@azure/msal-common\";\nimport { InteractionHandler } from \"./InteractionHandler\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError\";\nimport { BrowserCacheManager } from \"../cache/BrowserCacheManager\";\nimport {\n    BrowserSystemOptions,\n    DEFAULT_IFRAME_TIMEOUT_MS,\n} from \"../config/Configuration\";\n\nexport class SilentHandler extends InteractionHandler {\n    private navigateFrameWait: number;\n    private pollIntervalMilliseconds: number;\n\n    constructor(\n        authCodeModule: AuthorizationCodeClient,\n        storageImpl: BrowserCacheManager,\n        authCodeRequest: CommonAuthorizationCodeRequest,\n        logger: Logger,\n        systemOptions: Required<\n            Pick<\n                BrowserSystemOptions,\n                \"navigateFrameWait\" | \"pollIntervalMilliseconds\"\n            >\n        >,\n        performanceClient: IPerformanceClient\n    ) {\n        super(\n            authCodeModule,\n            storageImpl,\n            authCodeRequest,\n            logger,\n            performanceClient\n        );\n        this.navigateFrameWait = systemOptions.navigateFrameWait;\n        this.pollIntervalMilliseconds = systemOptions.pollIntervalMilliseconds;\n    }\n\n    /**\n     * Creates a hidden iframe to given URL using user-requested scopes as an id.\n     * @param urlNavigate\n     * @param userRequestScopes\n     */\n    async initiateAuthRequest(requestUrl: string): Promise<HTMLIFrameElement> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.SilentHandlerInitiateAuthRequest,\n            this.authCodeRequest.correlationId\n        );\n\n        if (!requestUrl) {\n            // Throw error if request URL is empty.\n            this.logger.info(\"Navigate url is empty\");\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.emptyNavigateUri\n            );\n        }\n\n        if (this.navigateFrameWait) {\n            this.performanceClient.setPreQueueTime(\n                PerformanceEvents.SilentHandlerLoadFrame,\n                this.authCodeRequest.correlationId\n            );\n            return await this.loadFrame(requestUrl);\n        }\n        return this.loadFrameSync(requestUrl);\n    }\n\n    /**\n     * Monitors an iframe content window until it loads a url with a known hash, or hits a specified timeout.\n     * @param iframe\n     * @param timeout\n     */\n    monitorIframeForHash(\n        iframe: HTMLIFrameElement,\n        timeout: number\n    ): Promise<string> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.SilentHandlerMonitorIframeForHash,\n            this.authCodeRequest.correlationId\n        );\n\n        return new Promise((resolve, reject) => {\n            if (timeout < DEFAULT_IFRAME_TIMEOUT_MS) {\n                this.logger.warning(\n                    `system.loadFrameTimeout or system.iframeHashTimeout set to lower (${timeout}ms) than the default (${DEFAULT_IFRAME_TIMEOUT_MS}ms). This may result in timeouts.`\n                );\n            }\n\n            /*\n             * Polling for iframes can be purely timing based,\n             * since we don't need to account for interaction.\n             */\n            const nowMark = window.performance.now();\n            const timeoutMark = nowMark + timeout;\n\n            const intervalId = setInterval(() => {\n                if (window.performance.now() > timeoutMark) {\n                    this.removeHiddenIframe(iframe);\n                    clearInterval(intervalId);\n                    reject(\n                        createBrowserAuthError(\n                            BrowserAuthErrorCodes.monitorWindowTimeout\n                        )\n                    );\n                    return;\n                }\n\n                let href: string = Constants.EMPTY_STRING;\n                const contentWindow = iframe.contentWindow;\n                try {\n                    /*\n                     * Will throw if cross origin,\n                     * which should be caught and ignored\n                     * since we need the interval to keep running while on STS UI.\n                     */\n                    href = contentWindow\n                        ? contentWindow.location.href\n                        : Constants.EMPTY_STRING;\n                } catch (e) {}\n\n                if (!href || href === \"about:blank\") {\n                    return;\n                }\n\n                const contentHash = contentWindow\n                    ? contentWindow.location.hash\n                    : Constants.EMPTY_STRING;\n                if (contentHash) {\n                    if (UrlString.hashContainsKnownProperties(contentHash)) {\n                        // Success case\n                        this.removeHiddenIframe(iframe);\n                        clearInterval(intervalId);\n                        resolve(contentHash);\n                        return;\n                    } else {\n                        // Hash is present but incorrect\n                        this.logger.error(\n                            \"SilentHandler:monitorIFrameForHash - a hash is present in the iframe but it does not contain known properties. It's likely that the hash has been replaced by code running on the redirectUri page.\"\n                        );\n                        this.logger.errorPii(\n                            `SilentHandler:monitorIFrameForHash - the url detected in the iframe is: ${href}`\n                        );\n                        this.removeHiddenIframe(iframe);\n                        clearInterval(intervalId);\n                        reject(\n                            createBrowserAuthError(\n                                BrowserAuthErrorCodes.hashDoesNotContainKnownProperties\n                            )\n                        );\n                        return;\n                    }\n                } else {\n                    // No hash is present\n                    this.logger.error(\n                        \"SilentHandler:monitorIFrameForHash - the request has returned to the redirectUri but a hash is not present in the iframe. It's likely that the hash has been removed or the page has been redirected by code running on the redirectUri page.\"\n                    );\n                    this.logger.errorPii(\n                        `SilentHandler:monitorIFrameForHash - the url detected in the iframe is: ${href}`\n                    );\n                    this.removeHiddenIframe(iframe);\n                    clearInterval(intervalId);\n                    reject(\n                        createBrowserAuthError(\n                            BrowserAuthErrorCodes.hashEmptyError\n                        )\n                    );\n                    return;\n                }\n            }, this.pollIntervalMilliseconds);\n        });\n    }\n\n    /**\n     * @hidden\n     * Loads iframe with authorization endpoint URL\n     * @ignore\n     */\n    private loadFrame(urlNavigate: string): Promise<HTMLIFrameElement> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.SilentHandlerLoadFrame,\n            this.authCodeRequest.correlationId\n        );\n\n        /*\n         * This trick overcomes iframe navigation in IE\n         * IE does not load the page consistently in iframe\n         */\n\n        return new Promise((resolve, reject) => {\n            const frameHandle = this.createHiddenIframe();\n\n            setTimeout(() => {\n                if (!frameHandle) {\n                    reject(\"Unable to load iframe\");\n                    return;\n                }\n\n                frameHandle.src = urlNavigate;\n\n                resolve(frameHandle);\n            }, this.navigateFrameWait);\n        });\n    }\n\n    /**\n     * @hidden\n     * Loads the iframe synchronously when the navigateTimeFrame is set to `0`\n     * @param urlNavigate\n     * @param frameName\n     * @param logger\n     */\n    private loadFrameSync(urlNavigate: string): HTMLIFrameElement {\n        const frameHandle = this.createHiddenIframe();\n\n        frameHandle.src = urlNavigate;\n\n        return frameHandle;\n    }\n\n    /**\n     * @hidden\n     * Creates a new hidden iframe or gets an existing one for silent token renewal.\n     * @ignore\n     */\n    private createHiddenIframe(): HTMLIFrameElement {\n        const authFrame = document.createElement(\"iframe\");\n\n        authFrame.style.visibility = \"hidden\";\n        authFrame.style.position = \"absolute\";\n        authFrame.style.width = authFrame.style.height = \"0\";\n        authFrame.style.border = \"0\";\n        authFrame.setAttribute(\n            \"sandbox\",\n            \"allow-scripts allow-same-origin allow-forms\"\n        );\n        document.getElementsByTagName(\"body\")[0].appendChild(authFrame);\n\n        return authFrame;\n    }\n\n    /**\n     * @hidden\n     * Removes a hidden iframe from the page.\n     * @ignore\n     */\n    private removeHiddenIframe(iframe: HTMLIFrameElement): void {\n        if (document.body === iframe.parentNode) {\n            document.body.removeChild(iframe);\n        }\n    }\n}\n"],"mappings":";;;;;;;;;AAKA;AASA;AAKA;AACA;AAiCI,MAAAA,aAAA,SAAAC,kBAAA;;;;IAIG,KAAAC,wBAAA,GAAAC,aAAA,CAAAD,wBAAA;;EAyBH;;;;AAIG;EACH,MAAAE,mBACIA,CAAAC,UAAQ;IAmGZ,KAAAC,iBAAA,CAAAC,mBAAA,CAAAC,iBAAA,CAAAC,gCAAA,OAAAC,eAAA,CAAAC,aAAA;;;;MAIG,MAAAC,sBAAA,CAAAC,gBAAA;IACH;IA2BA,SAAAC,iBAAA;;;;;;EAMG;AACH;AAQA;;;;IAIG,KAAAR,iBAAA,CAAAC,mBAAA,CAAAC,iBAAA,CAAAO,iCAAA,OAAAL,eAAA,CAAAC,aAAA;IACH,OAA0B,IAAAK,OAAA,EAAAC,OAAA,EAAAC,MAAA;MAgB1B,IAAAC,OAAA,GAAAC,yBAAA;;;;AAIG;AACH;AAKH"},"metadata":{},"sourceType":"module","externalDependencies":[]}