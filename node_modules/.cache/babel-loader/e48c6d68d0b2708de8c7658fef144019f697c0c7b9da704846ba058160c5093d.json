{"ast":null,"code":"/*! @azure/msal-common v14.4.0 2023-11-07 */\n'use strict';\n\nimport { Separators, CredentialType, AuthenticationScheme, THE_FAMILY_ID, APP_METADATA, AUTHORITY_METADATA_CONSTANTS } from '../utils/Constants.mjs';\nimport { generateCredentialKey } from './utils/CacheHelpers.mjs';\nimport { ScopeSet } from '../request/ScopeSet.mjs';\nimport { AccountEntity } from './entities/AccountEntity.mjs';\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { extractTokenClaims } from '../account/AuthToken.mjs';\nimport { name, version } from '../packageMetadata.mjs';\nimport { getAliasesFromStaticSources } from '../authority/AuthorityMetadata.mjs';\nimport { invalidCacheRecord, bindingKeyNotRemoved, multipleMatchingAppMetadata, methodNotImplemented } from '../error/ClientAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\n * @internal\n */\nclass CacheManager {\n  constructor(clientId, cryptoImpl, logger, staticAuthorityOptions) {\n    this.clientId = clientId;\n    this.cryptoImpl = cryptoImpl;\n    this.commonLogger = logger.clone(name, version);\n    this.staticAuthorityOptions = staticAuthorityOptions;\n  }\n  /**\n   * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.\n   * @param accountFilter - (Optional) filter to narrow down the accounts returned\n   * @returns Array of AccountInfo objects in cache\n   */\n  getAllAccounts(accountFilter) {\n    const validAccounts = [];\n    this.getAccountsFilteredBy(accountFilter || {}).forEach(accountEntity => {\n      const accountInfo = this.getAccountInfoFromEntity(accountEntity, accountFilter);\n      if (accountInfo) {\n        validAccounts.push(accountInfo);\n      }\n    });\n    return validAccounts;\n  }\n  /**\n   * Gets accountInfo object based on provided filters\n   */\n  getAccountInfoFilteredBy(accountFilter) {\n    const allAccounts = this.getAllAccounts(accountFilter);\n    if (allAccounts.length > 1) {\n      // If one or more accounts are found, further filter to the first account that has an ID token\n      return allAccounts.filter(account => {\n        return !!account.idTokenClaims;\n      })[0];\n    } else if (allAccounts.length === 1) {\n      // If only one account is found, return it regardless of whether a matching ID token was found\n      return allAccounts[0];\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Returns a single matching\n   * @param accountFilter\n   * @returns\n   */\n  getBaseAccountInfo(accountFilter) {\n    const accountEntities = this.getAccountsFilteredBy(accountFilter);\n    if (accountEntities.length > 0) {\n      return accountEntities[0].getAccountInfo();\n    } else {\n      return null;\n    }\n  }\n  getAccountInfoFromEntity(accountEntity, accountFilter) {\n    const accountInfo = accountEntity.getAccountInfo();\n    const idToken = this.getIdToken(accountInfo);\n    if (idToken) {\n      const idTokenClaims = extractTokenClaims(idToken.secret, this.cryptoImpl.base64Decode);\n      if (this.idTokenClaimsMatchAccountFilter(idTokenClaims, accountFilter)) {\n        accountInfo.idToken = idToken.secret;\n        accountInfo.idTokenClaims = idTokenClaims;\n        return accountInfo;\n      }\n    }\n    return accountInfo;\n  }\n  idTokenClaimsMatchAccountFilter(idTokenClaims, accountFilter) {\n    if (accountFilter) {\n      if (!!accountFilter.loginHint && !this.matchLoginHint(idTokenClaims, accountFilter.loginHint)) {\n        return false;\n      }\n      if (!!accountFilter.sid && !this.matchSid(idTokenClaims, accountFilter.sid)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * saves a cache record\n   * @param cacheRecord\n   */\n  async saveCacheRecord(cacheRecord, storeInCache) {\n    if (!cacheRecord) {\n      throw createClientAuthError(invalidCacheRecord);\n    }\n    if (!!cacheRecord.account) {\n      this.setAccount(cacheRecord.account);\n    }\n    if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {\n      this.setIdTokenCredential(cacheRecord.idToken);\n    }\n    if (!!cacheRecord.accessToken && storeInCache?.accessToken !== false) {\n      await this.saveAccessToken(cacheRecord.accessToken);\n    }\n    if (!!cacheRecord.refreshToken && storeInCache?.refreshToken !== false) {\n      this.setRefreshTokenCredential(cacheRecord.refreshToken);\n    }\n    if (!!cacheRecord.appMetadata) {\n      this.setAppMetadata(cacheRecord.appMetadata);\n    }\n  }\n  /**\n   * saves access token credential\n   * @param credential\n   */\n  async saveAccessToken(credential) {\n    const accessTokenFilter = {\n      clientId: credential.clientId,\n      credentialType: credential.credentialType,\n      environment: credential.environment,\n      homeAccountId: credential.homeAccountId,\n      realm: credential.realm,\n      tokenType: credential.tokenType,\n      requestedClaimsHash: credential.requestedClaimsHash\n    };\n    const tokenKeys = this.getTokenKeys();\n    const currentScopes = ScopeSet.fromString(credential.target);\n    const removedAccessTokens = [];\n    tokenKeys.accessToken.forEach(key => {\n      if (!this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {\n        return;\n      }\n      const tokenEntity = this.getAccessTokenCredential(key);\n      if (tokenEntity && this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {\n        const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n        if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n          removedAccessTokens.push(this.removeAccessToken(key));\n        }\n      }\n    });\n    await Promise.all(removedAccessTokens);\n    this.setAccessTokenCredential(credential);\n  }\n  /**\n   * Retrieve accounts matching all provided filters; if no filter is set, get all accounts\n   * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\n   * @param accountFilter - An object containing Account properties to filter by\n   */\n  getAccountsFilteredBy(accountFilter) {\n    const allAccountKeys = this.getAccountKeys();\n    const matchingAccounts = [];\n    allAccountKeys.forEach(cacheKey => {\n      if (!this.isAccountKey(cacheKey, accountFilter.homeAccountId, accountFilter.tenantId)) {\n        // Don't parse value if the key doesn't match the account filters\n        return;\n      }\n      const entity = this.getAccount(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (!!accountFilter.homeAccountId && !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {\n        return;\n      }\n      if (!!accountFilter.localAccountId && !this.matchLocalAccountId(entity, accountFilter.localAccountId)) {\n        return;\n      }\n      if (!!accountFilter.username && !this.matchUsername(entity, accountFilter.username)) {\n        return;\n      }\n      if (!!accountFilter.environment && !this.matchEnvironment(entity, accountFilter.environment)) {\n        return;\n      }\n      if (!!accountFilter.realm && !this.matchRealm(entity, accountFilter.realm)) {\n        return;\n      }\n      // tenantId is another name for realm\n      if (!!accountFilter.tenantId && !this.matchRealm(entity, accountFilter.tenantId)) {\n        return;\n      }\n      if (!!accountFilter.nativeAccountId && !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {\n        return;\n      }\n      if (!!accountFilter.authorityType && !this.matchAuthorityType(entity, accountFilter.authorityType)) {\n        return;\n      }\n      if (!!accountFilter.name && !this.matchName(entity, accountFilter.name)) {\n        return;\n      }\n      matchingAccounts.push(entity);\n    });\n    return matchingAccounts;\n  }\n  /**\n   * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided\n   * @param key\n   * @param homeAccountId\n   * @param tenantId\n   * @returns\n   */\n  isAccountKey(key, homeAccountId, tenantId) {\n    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {\n      // Account cache keys contain 3 items separated by '-' (each item may also contain '-')\n      return false;\n    }\n    if (homeAccountId && !key.toLowerCase().includes(homeAccountId.toLowerCase())) {\n      return false;\n    }\n    if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {\n      return false;\n    }\n    // Do not check environment as aliasing can cause false negatives\n    return true;\n  }\n  /**\n   * Returns true if the given key matches our credential key schema.\n   * @param key\n   */\n  isCredentialKey(key) {\n    if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {\n      // Credential cache keys contain 6 items separated by '-' (each item may also contain '-')\n      return false;\n    }\n    const lowerCaseKey = key.toLowerCase();\n    // Credential keys must indicate what credential type they represent\n    if (lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) === -1 && lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) === -1) {\n      return false;\n    }\n    if (lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) > -1) {\n      // Refresh tokens must contain the client id or family id\n      const clientIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${this.clientId}${Separators.CACHE_KEY_SEPARATOR}`;\n      const familyIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${THE_FAMILY_ID}${Separators.CACHE_KEY_SEPARATOR}`;\n      if (lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 && lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1) {\n        return false;\n      }\n    } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {\n      // Tokens must contain the clientId\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Returns whether or not the given credential entity matches the filter\n   * @param entity\n   * @param filter\n   * @returns\n   */\n  credentialMatchesFilter(entity, filter) {\n    if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\n      return false;\n    }\n    if (!!filter.userAssertionHash && !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {\n      return false;\n    }\n    /*\n     * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of \"\"\n     * because we don't want a client_credential request to return a cached token that has a homeAccountId\n     */\n    if (typeof filter.homeAccountId === \"string\" && !this.matchHomeAccountId(entity, filter.homeAccountId)) {\n      return false;\n    }\n    if (!!filter.environment && !this.matchEnvironment(entity, filter.environment)) {\n      return false;\n    }\n    if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {\n      return false;\n    }\n    if (!!filter.credentialType && !this.matchCredentialType(entity, filter.credentialType)) {\n      return false;\n    }\n    if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {\n      return false;\n    }\n    /*\n     * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\n     * Resource specific refresh tokens case will be added when the support is deemed necessary\n     */\n    if (!!filter.target && !this.matchTarget(entity, filter.target)) {\n      return false;\n    }\n    // If request OR cached entity has requested Claims Hash, check if they match\n    if (filter.requestedClaimsHash || entity.requestedClaimsHash) {\n      // Don't match if either is undefined or they are different\n      if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {\n        return false;\n      }\n    }\n    // Access Token with Auth Scheme specific matching\n    if (entity.credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\n      if (!!filter.tokenType && !this.matchTokenType(entity, filter.tokenType)) {\n        return false;\n      }\n      // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n      if (filter.tokenType === AuthenticationScheme.SSH) {\n        if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\n   * @param filter\n   */\n  getAppMetadataFilteredBy(filter) {\n    return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);\n  }\n  /**\n   * Support function to help match appMetadata\n   * @param environment\n   * @param clientId\n   */\n  getAppMetadataFilteredByInternal(environment, clientId) {\n    const allCacheKeys = this.getKeys();\n    const matchingAppMetadata = {};\n    allCacheKeys.forEach(cacheKey => {\n      // don't parse any non-appMetadata type cache entities\n      if (!this.isAppMetadata(cacheKey)) {\n        return;\n      }\n      // Attempt retrieval\n      const entity = this.getAppMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (!!environment && !this.matchEnvironment(entity, environment)) {\n        return;\n      }\n      if (!!clientId && !this.matchClientId(entity, clientId)) {\n        return;\n      }\n      matchingAppMetadata[cacheKey] = entity;\n    });\n    return matchingAppMetadata;\n  }\n  /**\n   * retrieve authorityMetadata that contains a matching alias\n   * @param filter\n   */\n  getAuthorityMetadataByAlias(host) {\n    const allCacheKeys = this.getAuthorityMetadataKeys();\n    let matchedEntity = null;\n    allCacheKeys.forEach(cacheKey => {\n      // don't parse any non-authorityMetadata type cache entities\n      if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {\n        return;\n      }\n      // Attempt retrieval\n      const entity = this.getAuthorityMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (entity.aliases.indexOf(host) === -1) {\n        return;\n      }\n      matchedEntity = entity;\n    });\n    return matchedEntity;\n  }\n  /**\n   * Removes all accounts and related tokens from cache.\n   */\n  async removeAllAccounts() {\n    const allAccountKeys = this.getAccountKeys();\n    const removedAccounts = [];\n    allAccountKeys.forEach(cacheKey => {\n      removedAccounts.push(this.removeAccount(cacheKey));\n    });\n    await Promise.all(removedAccounts);\n  }\n  /**\n   * Removes the account and related tokens for a given account key\n   * @param account\n   */\n  async removeAccount(accountKey) {\n    const account = this.getAccount(accountKey);\n    if (!account) {\n      return;\n    }\n    await this.removeAccountContext(account);\n    this.removeItem(accountKey);\n  }\n  /**\n   * Removes credentials associated with the provided account\n   * @param account\n   */\n  async removeAccountContext(account) {\n    const allTokenKeys = this.getTokenKeys();\n    const accountId = account.generateAccountId();\n    const removedCredentials = [];\n    allTokenKeys.idToken.forEach(key => {\n      if (key.indexOf(accountId) === 0) {\n        this.removeIdToken(key);\n      }\n    });\n    allTokenKeys.accessToken.forEach(key => {\n      if (key.indexOf(accountId) === 0) {\n        removedCredentials.push(this.removeAccessToken(key));\n      }\n    });\n    allTokenKeys.refreshToken.forEach(key => {\n      if (key.indexOf(accountId) === 0) {\n        this.removeRefreshToken(key);\n      }\n    });\n    await Promise.all(removedCredentials);\n  }\n  /**\n   * returns a boolean if the given credential is removed\n   * @param credential\n   */\n  async removeAccessToken(key) {\n    const credential = this.getAccessTokenCredential(key);\n    if (!credential) {\n      return;\n    }\n    // Remove Token Binding Key from key store for PoP Tokens Credentials\n    if (credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) {\n      if (credential.tokenType === AuthenticationScheme.POP) {\n        const accessTokenWithAuthSchemeEntity = credential;\n        const kid = accessTokenWithAuthSchemeEntity.keyId;\n        if (kid) {\n          try {\n            await this.cryptoImpl.removeTokenBindingKey(kid);\n          } catch (error) {\n            throw createClientAuthError(bindingKeyNotRemoved);\n          }\n        }\n      }\n    }\n    return this.removeItem(key);\n  }\n  /**\n   * Removes all app metadata objects from cache.\n   */\n  removeAppMetadata() {\n    const allCacheKeys = this.getKeys();\n    allCacheKeys.forEach(cacheKey => {\n      if (this.isAppMetadata(cacheKey)) {\n        this.removeItem(cacheKey);\n      }\n    });\n    return true;\n  }\n  /**\n   * Retrieve the cached credentials into a cacherecord\n   * @param account {AccountInfo}\n   * @param request {BaseAuthRequest}\n   * @param environment {string}\n   * @param performanceClient {?IPerformanceClient}\n   * @param correlationId {?string}\n   */\n  readCacheRecord(account, request, environment, performanceClient, correlationId) {\n    const tokenKeys = this.getTokenKeys();\n    const cachedAccount = this.readAccountFromCache(account);\n    const cachedIdToken = this.getIdToken(account, tokenKeys, performanceClient, correlationId);\n    const cachedAccessToken = this.getAccessToken(account, request, tokenKeys, performanceClient, correlationId);\n    const cachedRefreshToken = this.getRefreshToken(account, false, tokenKeys, performanceClient, correlationId);\n    const cachedAppMetadata = this.readAppMetadataFromCache(environment);\n    if (cachedAccount && cachedIdToken) {\n      cachedAccount.idTokenClaims = extractTokenClaims(cachedIdToken.secret, this.cryptoImpl.base64Decode);\n    }\n    return {\n      account: cachedAccount,\n      idToken: cachedIdToken,\n      accessToken: cachedAccessToken,\n      refreshToken: cachedRefreshToken,\n      appMetadata: cachedAppMetadata\n    };\n  }\n  /**\n   * Retrieve AccountEntity from cache\n   * @param account\n   */\n  readAccountFromCache(account) {\n    const accountKey = AccountEntity.generateAccountCacheKey(account);\n    return this.getAccount(accountKey);\n  }\n  /**\n   * Retrieve IdTokenEntity from cache\n   * @param account {AccountInfo}\n   * @param tokenKeys {?TokenKeys}\n   * @param performanceClient {?IPerformanceClient}\n   * @param correlationId {?string}\n   */\n  getIdToken(account, tokenKeys, performanceClient, correlationId) {\n    this.commonLogger.trace(\"CacheManager - getIdToken called\");\n    const idTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.ID_TOKEN,\n      clientId: this.clientId,\n      realm: account.tenantId\n    };\n    const idTokens = this.getIdTokensByFilter(idTokenFilter, tokenKeys);\n    const numIdTokens = idTokens.length;\n    if (numIdTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getIdToken - No token found\");\n      return null;\n    } else if (numIdTokens > 1) {\n      this.commonLogger.info(\"CacheManager:getIdToken - Multiple id tokens found, clearing them\");\n      idTokens.forEach(idToken => {\n        this.removeIdToken(generateCredentialKey(idToken));\n      });\n      if (performanceClient && correlationId) {\n        performanceClient.addFields({\n          multiMatchedID: idTokens.length\n        }, correlationId);\n      }\n      return null;\n    }\n    this.commonLogger.info(\"CacheManager:getIdToken - Returning id token\");\n    return idTokens[0];\n  }\n  /**\n   * Gets all idTokens matching the given filter\n   * @param filter\n   * @returns\n   */\n  getIdTokensByFilter(filter, tokenKeys) {\n    const idTokenKeys = tokenKeys && tokenKeys.idToken || this.getTokenKeys().idToken;\n    const idTokens = [];\n    idTokenKeys.forEach(key => {\n      if (!this.idTokenKeyMatchesFilter(key, {\n        clientId: this.clientId,\n        ...filter\n      })) {\n        return;\n      }\n      const idToken = this.getIdTokenCredential(key);\n      if (idToken && this.credentialMatchesFilter(idToken, filter)) {\n        idTokens.push(idToken);\n      }\n    });\n    return idTokens;\n  }\n  /**\n   * Validate the cache key against filter before retrieving and parsing cache value\n   * @param key\n   * @param filter\n   * @returns\n   */\n  idTokenKeyMatchesFilter(inputKey, filter) {\n    const key = inputKey.toLowerCase();\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Removes idToken from the cache\n   * @param key\n   */\n  removeIdToken(key) {\n    this.removeItem(key);\n  }\n  /**\n   * Removes refresh token from the cache\n   * @param key\n   */\n  removeRefreshToken(key) {\n    this.removeItem(key);\n  }\n  /**\n   * Retrieve AccessTokenEntity from cache\n   * @param account {AccountInfo}\n   * @param request {BaseAuthRequest}\n   * @param tokenKeys {?TokenKeys}\n   * @param performanceClient {?IPerformanceClient}\n   * @param correlationId {?string}\n   */\n  getAccessToken(account, request, tokenKeys, performanceClient, correlationId) {\n    this.commonLogger.trace(\"CacheManager - getAccessToken called\");\n    const scopes = ScopeSet.createSearchScopes(request.scopes);\n    const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n    /*\n     * Distinguish between Bearer and PoP/SSH token cache types\n     * Cast to lowercase to handle \"bearer\" from ADFS\n     */\n    const credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n    const accessTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: credentialType,\n      clientId: this.clientId,\n      realm: account.tenantId,\n      target: scopes,\n      tokenType: authScheme,\n      keyId: request.sshKid,\n      requestedClaimsHash: request.requestedClaimsHash\n    };\n    const accessTokenKeys = tokenKeys && tokenKeys.accessToken || this.getTokenKeys().accessToken;\n    const accessTokens = [];\n    accessTokenKeys.forEach(key => {\n      // Validate key\n      if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {\n        const accessToken = this.getAccessTokenCredential(key);\n        // Validate value\n        if (accessToken && this.credentialMatchesFilter(accessToken, accessTokenFilter)) {\n          accessTokens.push(accessToken);\n        }\n      }\n    });\n    const numAccessTokens = accessTokens.length;\n    if (numAccessTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getAccessToken - No token found\");\n      return null;\n    } else if (numAccessTokens > 1) {\n      this.commonLogger.info(\"CacheManager:getAccessToken - Multiple access tokens found, clearing them\");\n      accessTokens.forEach(accessToken => {\n        void this.removeAccessToken(generateCredentialKey(accessToken));\n      });\n      if (performanceClient && correlationId) {\n        performanceClient.addFields({\n          multiMatchedAT: accessTokens.length\n        }, correlationId);\n      }\n      return null;\n    }\n    this.commonLogger.info(\"CacheManager:getAccessToken - Returning access token\");\n    return accessTokens[0];\n  }\n  /**\n   * Validate the cache key against filter before retrieving and parsing cache value\n   * @param key\n   * @param filter\n   * @param keyMustContainAllScopes\n   * @returns\n   */\n  accessTokenKeyMatchesFilter(inputKey, filter, keyMustContainAllScopes) {\n    const key = inputKey.toLowerCase();\n    if (filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.requestedClaimsHash && key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.target) {\n      const scopes = filter.target.asArray();\n      for (let i = 0; i < scopes.length; i++) {\n        if (keyMustContainAllScopes && !key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache lookup a missing scope would be a cache miss\n          return false;\n        } else if (!keyMustContainAllScopes && key.includes(scopes[i].toLowerCase())) {\n          // When performing a cache write, any token with a subset of requested scopes should be replaced\n          return true;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * Gets all access tokens matching the filter\n   * @param filter\n   * @returns\n   */\n  getAccessTokensByFilter(filter) {\n    const tokenKeys = this.getTokenKeys();\n    const accessTokens = [];\n    tokenKeys.accessToken.forEach(key => {\n      if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {\n        return;\n      }\n      const accessToken = this.getAccessTokenCredential(key);\n      if (accessToken && this.credentialMatchesFilter(accessToken, filter)) {\n        accessTokens.push(accessToken);\n      }\n    });\n    return accessTokens;\n  }\n  /**\n   * Helper to retrieve the appropriate refresh token from cache\n   * @param account {AccountInfo}\n   * @param familyRT {boolean}\n   * @param tokenKeys {?TokenKeys}\n   * @param performanceClient {?IPerformanceClient}\n   * @param correlationId {?string}\n   */\n  getRefreshToken(account, familyRT, tokenKeys, performanceClient, correlationId) {\n    this.commonLogger.trace(\"CacheManager - getRefreshToken called\");\n    const id = familyRT ? THE_FAMILY_ID : undefined;\n    const refreshTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.REFRESH_TOKEN,\n      clientId: this.clientId,\n      familyId: id\n    };\n    const refreshTokenKeys = tokenKeys && tokenKeys.refreshToken || this.getTokenKeys().refreshToken;\n    const refreshTokens = [];\n    refreshTokenKeys.forEach(key => {\n      // Validate key\n      if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {\n        const refreshToken = this.getRefreshTokenCredential(key);\n        // Validate value\n        if (refreshToken && this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {\n          refreshTokens.push(refreshToken);\n        }\n      }\n    });\n    const numRefreshTokens = refreshTokens.length;\n    if (numRefreshTokens < 1) {\n      this.commonLogger.info(\"CacheManager:getRefreshToken - No refresh token found.\");\n      return null;\n    }\n    // address the else case after remove functions address environment aliases\n    if (numRefreshTokens > 1 && performanceClient && correlationId) {\n      performanceClient.addFields({\n        multiMatchedRT: numRefreshTokens\n      }, correlationId);\n    }\n    this.commonLogger.info(\"CacheManager:getRefreshToken - returning refresh token\");\n    return refreshTokens[0];\n  }\n  /**\n   * Validate the cache key against filter before retrieving and parsing cache value\n   * @param key\n   * @param filter\n   */\n  refreshTokenKeyMatchesFilter(inputKey, filter) {\n    const key = inputKey.toLowerCase();\n    if (filter.familyId && key.indexOf(filter.familyId.toLowerCase()) === -1) {\n      return false;\n    }\n    // If familyId is used, clientId is not in the key\n    if (!filter.familyId && filter.clientId && key.indexOf(filter.clientId.toLowerCase()) === -1) {\n      return false;\n    }\n    if (filter.homeAccountId && key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Retrieve AppMetadataEntity from cache\n   */\n  readAppMetadataFromCache(environment) {\n    const appMetadataFilter = {\n      environment,\n      clientId: this.clientId\n    };\n    const appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\n    const appMetadataEntries = Object.keys(appMetadata).map(key => appMetadata[key]);\n    const numAppMetadata = appMetadataEntries.length;\n    if (numAppMetadata < 1) {\n      return null;\n    } else if (numAppMetadata > 1) {\n      throw createClientAuthError(multipleMatchingAppMetadata);\n    }\n    return appMetadataEntries[0];\n  }\n  /**\n   * Return the family_id value associated  with FOCI\n   * @param environment\n   * @param clientId\n   */\n  isAppMetadataFOCI(environment) {\n    const appMetadata = this.readAppMetadataFromCache(environment);\n    return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n  }\n  /**\n   * helper to match account ids\n   * @param value\n   * @param homeAccountId\n   */\n  matchHomeAccountId(entity, homeAccountId) {\n    return !!(typeof entity.homeAccountId === \"string\" && homeAccountId === entity.homeAccountId);\n  }\n  /**\n   * helper to match account ids\n   * @param entity\n   * @param localAccountId\n   * @returns\n   */\n  matchLocalAccountId(entity, localAccountId) {\n    return !!(typeof entity.localAccountId === \"string\" && localAccountId === entity.localAccountId);\n  }\n  /**\n   * helper to match usernames\n   * @param entity\n   * @param username\n   * @returns\n   */\n  matchUsername(entity, username) {\n    return !!(typeof entity.username === \"string\" && username.toLowerCase() === entity.username.toLowerCase());\n  }\n  /**\n   * helper to match names\n   * @param entity\n   * @param name\n   * @returns true if the downcased name properties are present and match in the filter and the entity\n   */\n  matchName(entity, name) {\n    return !!(name.toLowerCase() === entity.name?.toLowerCase());\n  }\n  /**\n   * helper to match assertion\n   * @param value\n   * @param oboAssertion\n   */\n  matchUserAssertionHash(entity, userAssertionHash) {\n    return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);\n  }\n  /**\n   * helper to match environment\n   * @param value\n   * @param environment\n   */\n  matchEnvironment(entity, environment) {\n    // Check static authority options first for cases where authority metadata has not been resolved and cached yet\n    if (this.staticAuthorityOptions) {\n      const staticAliases = getAliasesFromStaticSources(this.staticAuthorityOptions, this.commonLogger);\n      if (staticAliases.includes(environment) && staticAliases.includes(entity.environment)) {\n        return true;\n      }\n    }\n    // Query metadata cache if no static authority configuration has aliases that match enviroment\n    const cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n    if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * helper to match credential type\n   * @param entity\n   * @param credentialType\n   */\n  matchCredentialType(entity, credentialType) {\n    return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();\n  }\n  /**\n   * helper to match client ids\n   * @param entity\n   * @param clientId\n   */\n  matchClientId(entity, clientId) {\n    return !!(entity.clientId && clientId === entity.clientId);\n  }\n  /**\n   * helper to match family ids\n   * @param entity\n   * @param familyId\n   */\n  matchFamilyId(entity, familyId) {\n    return !!(entity.familyId && familyId === entity.familyId);\n  }\n  /**\n   * helper to match realm\n   * @param entity\n   * @param realm\n   */\n  matchRealm(entity, realm) {\n    return !!(entity.realm && realm === entity.realm);\n  }\n  /**\n   * helper to match nativeAccountId\n   * @param entity\n   * @param nativeAccountId\n   * @returns boolean indicating the match result\n   */\n  matchNativeAccountId(entity, nativeAccountId) {\n    return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\n  }\n  /**\n   * helper to match loginHint which can be either:\n   * 1. login_hint ID token claim\n   * 2. username in cached account object\n   * 3. upn in ID token claims\n   * @param entity\n   * @param loginHint\n   * @returns\n   */\n  matchLoginHint(idTokenClaims, loginHint) {\n    if (idTokenClaims?.login_hint === loginHint) {\n      return true;\n    }\n    if (idTokenClaims.preferred_username === loginHint) {\n      return true;\n    }\n    if (idTokenClaims?.upn === loginHint) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Helper to match sid\n   * @param idTokenClaims\n   * @param sid\n   * @returns true if the sid claim is present and matches the filter\n   */\n  matchSid(idTokenClaims, sid) {\n    return !!(idTokenClaims?.sid && idTokenClaims.sid === sid);\n  }\n  matchAuthorityType(entity, authorityType) {\n    return !!(entity.authorityType && authorityType.toLowerCase() === entity.authorityType.toLowerCase());\n  }\n  /**\n   * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\n   * @param entity\n   * @param target\n   */\n  matchTarget(entity, target) {\n    const isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n    if (isNotAccessTokenCredential || !entity.target) {\n      return false;\n    }\n    const entityScopeSet = ScopeSet.fromString(entity.target);\n    return entityScopeSet.containsScopeSet(target);\n  }\n  /**\n   * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\n   * @param entity\n   * @param tokenType\n   */\n  matchTokenType(entity, tokenType) {\n    return !!(entity.tokenType && entity.tokenType === tokenType);\n  }\n  /**\n   * Returns true if the credential's keyId matches the one in the request, false otherwise\n   * @param entity\n   * @param tokenType\n   */\n  matchKeyId(entity, keyId) {\n    return !!(entity.keyId && entity.keyId === keyId);\n  }\n  /**\n   * returns if a given cache entity is of the type appmetadata\n   * @param key\n   */\n  isAppMetadata(key) {\n    return key.indexOf(APP_METADATA) !== -1;\n  }\n  /**\n   * returns if a given cache entity is of the type authoritymetadata\n   * @param key\n   */\n  isAuthorityMetadata(key) {\n    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n  }\n  /**\n   * returns cache key used for cloud instance metadata\n   */\n  generateAuthorityMetadataCacheKey(authority) {\n    return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;\n  }\n  /**\n   * Helper to convert serialized data to object\n   * @param obj\n   * @param json\n   */\n  static toObject(obj, json) {\n    for (const propertyName in json) {\n      obj[propertyName] = json[propertyName];\n    }\n    return obj;\n  }\n}\n/** @internal */\nclass DefaultStorageClass extends CacheManager {\n  setAccount() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAccount() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setIdTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getIdTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setAccessTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAccessTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setRefreshTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getRefreshTokenCredential() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setAppMetadata() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAppMetadata() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setServerTelemetry() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getServerTelemetry() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setAuthorityMetadata() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAuthorityMetadata() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAuthorityMetadataKeys() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  setThrottlingCache() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getThrottlingCache() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  removeItem() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  containsKey() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getKeys() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getAccountKeys() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  getTokenKeys() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  async clear() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n  updateCredentialCacheKey() {\n    throw createClientAuthError(methodNotImplemented);\n  }\n}\nexport { CacheManager, DefaultStorageClass };","map":{"version":3,"names":["CacheManager","constructor","clientId","cryptoImpl","logger","staticAuthorityOptions","getAllAccounts","accountFilter","accountInfo","getAccountInfoFromEntity","accountEntity","validAccounts","push","getAccountInfoFilteredBy","allAccounts","length","account","idTokenClaims","getBaseAccountInfo","accountEntities","getAccountsFilteredBy","getAccountInfo","idToken","getIdToken","idTokenClaimsMatchAccountFilter","secret","matchLoginHint","loginHint","cacheRecord","createClientAuthError","invalidCacheRecord","storeInCache","setIdTokenCredential","refreshToken","appMetadata","setAppMetadata","accessTokenFilter","credential","credentialType","homeAccountId","realm","tokenType","tokenKeys","getTokenKeys","currentScopes","ScopeSet","fromString","target","accessToken","forEach","key","accessTokenKeyMatchesFilter","tokenEntity","getAccessTokenCredential","credentialMatchesFilter","setAccessTokenCredential","allAccountKeys","getAccountKeys","matchingAccounts","cacheKey","entity","getAccount","matchHomeAccountId","matchLocalAccountId","localAccountId","matchEnvironment","environment","nativeAccountId","matchNativeAccountId","matchAuthorityType","authorityType","tenantId","toLowerCase","includes","lowerCaseKey","indexOf","CredentialType","ID_TOKEN","ACCESS_TOKEN_WITH_AUTH_SCHEME","REFRESH_TOKEN","clientIdValidation","Separators","CACHE_KEY_SEPARATOR","familyIdValidation","THE_FAMILY_ID","filter","matchClientId","userAssertionHash","matchUserAssertionHash","familyId","matchFamilyId","requestedClaimsHash","matchTokenType","AuthenticationScheme","SSH","keyId","matchKeyId","getAppMetadataFilteredByInternal","allCacheKeys","getKeys","matchingAppMetadata","getAppMetadata","getAuthorityMetadataByAlias","host","isAuthorityMetadata","getAuthorityMetadata","matchedEntity","removeAllAccounts","removeAccountContext","removeItem","accountKey","allTokenKeys","accountId","removeIdToken","removedCredentials","removeAccessToken","removeRefreshToken","POP","accessTokenWithAuthSchemeEntity","kid","removeTokenBindingKey","error","bindingKeyNotRemoved","removeAppMetadata","isAppMetadata"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-common\\src\\cache\\CacheManager.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AccountFilter,\n    CredentialFilter,\n    ValidCredentialType,\n    AppMetadataFilter,\n    AppMetadataCache,\n    TokenKeys,\n} from \"./utils/CacheTypes\";\nimport { CacheRecord } from \"./entities/CacheRecord\";\nimport {\n    CredentialType,\n    APP_METADATA,\n    THE_FAMILY_ID,\n    AUTHORITY_METADATA_CONSTANTS,\n    AuthenticationScheme,\n    Separators,\n} from \"../utils/Constants\";\nimport { CredentialEntity } from \"./entities/CredentialEntity\";\nimport { generateCredentialKey } from \"./utils/CacheHelpers\";\nimport { ScopeSet } from \"../request/ScopeSet\";\nimport { AccountEntity } from \"./entities/AccountEntity\";\nimport { AccessTokenEntity } from \"./entities/AccessTokenEntity\";\nimport { IdTokenEntity } from \"./entities/IdTokenEntity\";\nimport { RefreshTokenEntity } from \"./entities/RefreshTokenEntity\";\nimport { ICacheManager } from \"./interface/ICacheManager\";\nimport {\n    createClientAuthError,\n    ClientAuthErrorCodes,\n} from \"../error/ClientAuthError\";\nimport { AccountInfo } from \"../account/AccountInfo\";\nimport { AppMetadataEntity } from \"./entities/AppMetadataEntity\";\nimport { ServerTelemetryEntity } from \"./entities/ServerTelemetryEntity\";\nimport { ThrottlingEntity } from \"./entities/ThrottlingEntity\";\nimport { extractTokenClaims } from \"../account/AuthToken\";\nimport { ICrypto } from \"../crypto/ICrypto\";\nimport { AuthorityMetadataEntity } from \"./entities/AuthorityMetadataEntity\";\nimport { BaseAuthRequest } from \"../request/BaseAuthRequest\";\nimport { Logger } from \"../logger/Logger\";\nimport { name, version } from \"../packageMetadata\";\nimport { StoreInCache } from \"../request/StoreInCache\";\nimport { getAliasesFromStaticSources } from \"../authority/AuthorityMetadata\";\nimport { StaticAuthorityOptions } from \"../authority/AuthorityOptions\";\nimport { TokenClaims } from \"../account/TokenClaims\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\n\n/**\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\n * @internal\n */\nexport abstract class CacheManager implements ICacheManager {\n    protected clientId: string;\n    protected cryptoImpl: ICrypto;\n    // Instance of logger for functions defined in the msal-common layer\n    private commonLogger: Logger;\n    private staticAuthorityOptions?: StaticAuthorityOptions;\n\n    constructor(\n        clientId: string,\n        cryptoImpl: ICrypto,\n        logger: Logger,\n        staticAuthorityOptions?: StaticAuthorityOptions\n    ) {\n        this.clientId = clientId;\n        this.cryptoImpl = cryptoImpl;\n        this.commonLogger = logger.clone(name, version);\n        this.staticAuthorityOptions = staticAuthorityOptions;\n    }\n\n    /**\n     * fetch the account entity from the platform cache\n     *  @param accountKey\n     */\n    abstract getAccount(accountKey: string): AccountEntity | null;\n\n    /**\n     * set account entity in the platform cache\n     * @param account\n     */\n    abstract setAccount(account: AccountEntity): void;\n\n    /**\n     * fetch the idToken entity from the platform cache\n     * @param idTokenKey\n     */\n    abstract getIdTokenCredential(idTokenKey: string): IdTokenEntity | null;\n\n    /**\n     * set idToken entity to the platform cache\n     * @param idToken\n     */\n    abstract setIdTokenCredential(idToken: IdTokenEntity): void;\n\n    /**\n     * fetch the idToken entity from the platform cache\n     * @param accessTokenKey\n     */\n    abstract getAccessTokenCredential(\n        accessTokenKey: string\n    ): AccessTokenEntity | null;\n\n    /**\n     * set idToken entity to the platform cache\n     * @param accessToken\n     */\n    abstract setAccessTokenCredential(accessToken: AccessTokenEntity): void;\n\n    /**\n     * fetch the idToken entity from the platform cache\n     * @param refreshTokenKey\n     */\n    abstract getRefreshTokenCredential(\n        refreshTokenKey: string\n    ): RefreshTokenEntity | null;\n\n    /**\n     * set idToken entity to the platform cache\n     * @param refreshToken\n     */\n    abstract setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void;\n\n    /**\n     * fetch appMetadata entity from the platform cache\n     * @param appMetadataKey\n     */\n    abstract getAppMetadata(appMetadataKey: string): AppMetadataEntity | null;\n\n    /**\n     * set appMetadata entity to the platform cache\n     * @param appMetadata\n     */\n    abstract setAppMetadata(appMetadata: AppMetadataEntity): void;\n\n    /**\n     * fetch server telemetry entity from the platform cache\n     * @param serverTelemetryKey\n     */\n    abstract getServerTelemetry(\n        serverTelemetryKey: string\n    ): ServerTelemetryEntity | null;\n\n    /**\n     * set server telemetry entity to the platform cache\n     * @param serverTelemetryKey\n     * @param serverTelemetry\n     */\n    abstract setServerTelemetry(\n        serverTelemetryKey: string,\n        serverTelemetry: ServerTelemetryEntity\n    ): void;\n\n    /**\n     * fetch cloud discovery metadata entity from the platform cache\n     * @param key\n     */\n    abstract getAuthorityMetadata(key: string): AuthorityMetadataEntity | null;\n\n    /**\n     *\n     */\n    abstract getAuthorityMetadataKeys(): Array<string>;\n\n    /**\n     * set cloud discovery metadata entity to the platform cache\n     * @param key\n     * @param value\n     */\n    abstract setAuthorityMetadata(\n        key: string,\n        value: AuthorityMetadataEntity\n    ): void;\n\n    /**\n     * fetch throttling entity from the platform cache\n     * @param throttlingCacheKey\n     */\n    abstract getThrottlingCache(\n        throttlingCacheKey: string\n    ): ThrottlingEntity | null;\n\n    /**\n     * set throttling entity to the platform cache\n     * @param throttlingCacheKey\n     * @param throttlingCache\n     */\n    abstract setThrottlingCache(\n        throttlingCacheKey: string,\n        throttlingCache: ThrottlingEntity\n    ): void;\n\n    /**\n     * Function to remove an item from cache given its key.\n     * @param key\n     */\n    abstract removeItem(key: string): void;\n\n    /**\n     * Function which returns boolean whether cache contains a specific key.\n     * @param key\n     */\n    abstract containsKey(key: string, type?: string): boolean;\n\n    /**\n     * Function which retrieves all current keys from the cache.\n     */\n    abstract getKeys(): string[];\n\n    /**\n     * Function which retrieves all account keys from the cache\n     */\n    abstract getAccountKeys(): string[];\n\n    /**\n     * Function which retrieves all token keys from the cache\n     */\n    abstract getTokenKeys(): TokenKeys;\n\n    /**\n     * Function which clears cache.\n     */\n    abstract clear(): Promise<void>;\n\n    /**\n     * Function which updates an outdated credential cache key\n     */\n    abstract updateCredentialCacheKey(\n        currentCacheKey: string,\n        credential: ValidCredentialType\n    ): string;\n\n    /**\n     * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.\n     * @param accountFilter - (Optional) filter to narrow down the accounts returned\n     * @returns Array of AccountInfo objects in cache\n     */\n    getAllAccounts(accountFilter?: AccountFilter): AccountInfo[] {\n        const validAccounts: AccountInfo[] = [];\n        this.getAccountsFilteredBy(accountFilter || {}).forEach(\n            (accountEntity: AccountEntity) => {\n                const accountInfo = this.getAccountInfoFromEntity(\n                    accountEntity,\n                    accountFilter\n                );\n                if (accountInfo) {\n                    validAccounts.push(accountInfo);\n                }\n            }\n        );\n        return validAccounts;\n    }\n\n    /**\n     * Gets accountInfo object based on provided filters\n     */\n    getAccountInfoFilteredBy(accountFilter: AccountFilter): AccountInfo | null {\n        const allAccounts = this.getAllAccounts(accountFilter);\n        if (allAccounts.length > 1) {\n            // If one or more accounts are found, further filter to the first account that has an ID token\n            return allAccounts.filter((account) => {\n                return !!account.idTokenClaims;\n            })[0];\n        } else if (allAccounts.length === 1) {\n            // If only one account is found, return it regardless of whether a matching ID token was found\n            return allAccounts[0];\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns a single matching\n     * @param accountFilter\n     * @returns\n     */\n    getBaseAccountInfo(accountFilter: AccountFilter): AccountInfo | null {\n        const accountEntities = this.getAccountsFilteredBy(accountFilter);\n        if (accountEntities.length > 0) {\n            return accountEntities[0].getAccountInfo();\n        } else {\n            return null;\n        }\n    }\n\n    private getAccountInfoFromEntity(\n        accountEntity: AccountEntity,\n        accountFilter?: AccountFilter\n    ): AccountInfo | null {\n        const accountInfo = accountEntity.getAccountInfo();\n        const idToken = this.getIdToken(accountInfo);\n        if (idToken) {\n            const idTokenClaims = extractTokenClaims(\n                idToken.secret,\n                this.cryptoImpl.base64Decode\n            );\n\n            if (\n                this.idTokenClaimsMatchAccountFilter(\n                    idTokenClaims,\n                    accountFilter\n                )\n            ) {\n                accountInfo.idToken = idToken.secret;\n                accountInfo.idTokenClaims = idTokenClaims;\n                return accountInfo;\n            }\n        }\n        return accountInfo;\n    }\n\n    private idTokenClaimsMatchAccountFilter(\n        idTokenClaims: TokenClaims,\n        accountFilter?: AccountFilter\n    ): boolean {\n        if (accountFilter) {\n            if (\n                !!accountFilter.loginHint &&\n                !this.matchLoginHint(idTokenClaims, accountFilter.loginHint)\n            ) {\n                return false;\n            }\n            if (\n                !!accountFilter.sid &&\n                !this.matchSid(idTokenClaims, accountFilter.sid)\n            ) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * saves a cache record\n     * @param cacheRecord\n     */\n    async saveCacheRecord(\n        cacheRecord: CacheRecord,\n        storeInCache?: StoreInCache\n    ): Promise<void> {\n        if (!cacheRecord) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.invalidCacheRecord\n            );\n        }\n\n        if (!!cacheRecord.account) {\n            this.setAccount(cacheRecord.account);\n        }\n\n        if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {\n            this.setIdTokenCredential(cacheRecord.idToken);\n        }\n\n        if (!!cacheRecord.accessToken && storeInCache?.accessToken !== false) {\n            await this.saveAccessToken(cacheRecord.accessToken);\n        }\n\n        if (\n            !!cacheRecord.refreshToken &&\n            storeInCache?.refreshToken !== false\n        ) {\n            this.setRefreshTokenCredential(cacheRecord.refreshToken);\n        }\n\n        if (!!cacheRecord.appMetadata) {\n            this.setAppMetadata(cacheRecord.appMetadata);\n        }\n    }\n\n    /**\n     * saves access token credential\n     * @param credential\n     */\n    private async saveAccessToken(\n        credential: AccessTokenEntity\n    ): Promise<void> {\n        const accessTokenFilter: CredentialFilter = {\n            clientId: credential.clientId,\n            credentialType: credential.credentialType,\n            environment: credential.environment,\n            homeAccountId: credential.homeAccountId,\n            realm: credential.realm,\n            tokenType: credential.tokenType,\n            requestedClaimsHash: credential.requestedClaimsHash,\n        };\n\n        const tokenKeys = this.getTokenKeys();\n        const currentScopes = ScopeSet.fromString(credential.target);\n\n        const removedAccessTokens: Array<Promise<void>> = [];\n        tokenKeys.accessToken.forEach((key) => {\n            if (\n                !this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)\n            ) {\n                return;\n            }\n\n            const tokenEntity = this.getAccessTokenCredential(key);\n\n            if (\n                tokenEntity &&\n                this.credentialMatchesFilter(tokenEntity, accessTokenFilter)\n            ) {\n                const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n                    removedAccessTokens.push(this.removeAccessToken(key));\n                }\n            }\n        });\n        await Promise.all(removedAccessTokens);\n        this.setAccessTokenCredential(credential);\n    }\n\n    /**\n     * Retrieve accounts matching all provided filters; if no filter is set, get all accounts\n     * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\n     * @param accountFilter - An object containing Account properties to filter by\n     */\n    getAccountsFilteredBy(accountFilter: AccountFilter): AccountEntity[] {\n        const allAccountKeys = this.getAccountKeys();\n        const matchingAccounts: AccountEntity[] = [];\n        allAccountKeys.forEach((cacheKey) => {\n            if (\n                !this.isAccountKey(\n                    cacheKey,\n                    accountFilter.homeAccountId,\n                    accountFilter.tenantId\n                )\n            ) {\n                // Don't parse value if the key doesn't match the account filters\n                return;\n            }\n\n            const entity: AccountEntity | null = this.getAccount(cacheKey);\n\n            if (!entity) {\n                return;\n            }\n\n            if (\n                !!accountFilter.homeAccountId &&\n                !this.matchHomeAccountId(entity, accountFilter.homeAccountId)\n            ) {\n                return;\n            }\n\n            if (\n                !!accountFilter.localAccountId &&\n                !this.matchLocalAccountId(entity, accountFilter.localAccountId)\n            ) {\n                return;\n            }\n\n            if (\n                !!accountFilter.username &&\n                !this.matchUsername(entity, accountFilter.username)\n            ) {\n                return;\n            }\n\n            if (\n                !!accountFilter.environment &&\n                !this.matchEnvironment(entity, accountFilter.environment)\n            ) {\n                return;\n            }\n\n            if (\n                !!accountFilter.realm &&\n                !this.matchRealm(entity, accountFilter.realm)\n            ) {\n                return;\n            }\n\n            // tenantId is another name for realm\n            if (\n                !!accountFilter.tenantId &&\n                !this.matchRealm(entity, accountFilter.tenantId)\n            ) {\n                return;\n            }\n\n            if (\n                !!accountFilter.nativeAccountId &&\n                !this.matchNativeAccountId(\n                    entity,\n                    accountFilter.nativeAccountId\n                )\n            ) {\n                return;\n            }\n\n            if (\n                !!accountFilter.authorityType &&\n                !this.matchAuthorityType(entity, accountFilter.authorityType)\n            ) {\n                return;\n            }\n\n            if (\n                !!accountFilter.name &&\n                !this.matchName(entity, accountFilter.name)\n            ) {\n                return;\n            }\n\n            matchingAccounts.push(entity);\n        });\n\n        return matchingAccounts;\n    }\n\n    /**\n     * Returns true if the given key matches our account key schema. Also matches homeAccountId and/or tenantId if provided\n     * @param key\n     * @param homeAccountId\n     * @param tenantId\n     * @returns\n     */\n    isAccountKey(\n        key: string,\n        homeAccountId?: string,\n        tenantId?: string\n    ): boolean {\n        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 3) {\n            // Account cache keys contain 3 items separated by '-' (each item may also contain '-')\n            return false;\n        }\n\n        if (\n            homeAccountId &&\n            !key.toLowerCase().includes(homeAccountId.toLowerCase())\n        ) {\n            return false;\n        }\n\n        if (tenantId && !key.toLowerCase().includes(tenantId.toLowerCase())) {\n            return false;\n        }\n\n        // Do not check environment as aliasing can cause false negatives\n\n        return true;\n    }\n\n    /**\n     * Returns true if the given key matches our credential key schema.\n     * @param key\n     */\n    isCredentialKey(key: string): boolean {\n        if (key.split(Separators.CACHE_KEY_SEPARATOR).length < 6) {\n            // Credential cache keys contain 6 items separated by '-' (each item may also contain '-')\n            return false;\n        }\n\n        const lowerCaseKey = key.toLowerCase();\n        // Credential keys must indicate what credential type they represent\n        if (\n            lowerCaseKey.indexOf(CredentialType.ID_TOKEN.toLowerCase()) ===\n                -1 &&\n            lowerCaseKey.indexOf(CredentialType.ACCESS_TOKEN.toLowerCase()) ===\n                -1 &&\n            lowerCaseKey.indexOf(\n                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()\n            ) === -1 &&\n            lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) ===\n                -1\n        ) {\n            return false;\n        }\n\n        if (\n            lowerCaseKey.indexOf(CredentialType.REFRESH_TOKEN.toLowerCase()) >\n            -1\n        ) {\n            // Refresh tokens must contain the client id or family id\n            const clientIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${this.clientId}${Separators.CACHE_KEY_SEPARATOR}`;\n            const familyIdValidation = `${CredentialType.REFRESH_TOKEN}${Separators.CACHE_KEY_SEPARATOR}${THE_FAMILY_ID}${Separators.CACHE_KEY_SEPARATOR}`;\n            if (\n                lowerCaseKey.indexOf(clientIdValidation.toLowerCase()) === -1 &&\n                lowerCaseKey.indexOf(familyIdValidation.toLowerCase()) === -1\n            ) {\n                return false;\n            }\n        } else if (lowerCaseKey.indexOf(this.clientId.toLowerCase()) === -1) {\n            // Tokens must contain the clientId\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns whether or not the given credential entity matches the filter\n     * @param entity\n     * @param filter\n     * @returns\n     */\n    credentialMatchesFilter(\n        entity: ValidCredentialType,\n        filter: CredentialFilter\n    ): boolean {\n        if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {\n            return false;\n        }\n\n        if (\n            !!filter.userAssertionHash &&\n            !this.matchUserAssertionHash(entity, filter.userAssertionHash)\n        ) {\n            return false;\n        }\n\n        /*\n         * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of \"\"\n         * because we don't want a client_credential request to return a cached token that has a homeAccountId\n         */\n        if (\n            typeof filter.homeAccountId === \"string\" &&\n            !this.matchHomeAccountId(entity, filter.homeAccountId)\n        ) {\n            return false;\n        }\n\n        if (\n            !!filter.environment &&\n            !this.matchEnvironment(entity, filter.environment)\n        ) {\n            return false;\n        }\n\n        if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {\n            return false;\n        }\n\n        if (\n            !!filter.credentialType &&\n            !this.matchCredentialType(entity, filter.credentialType)\n        ) {\n            return false;\n        }\n\n        if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {\n            return false;\n        }\n\n        /*\n         * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\n         * Resource specific refresh tokens case will be added when the support is deemed necessary\n         */\n        if (!!filter.target && !this.matchTarget(entity, filter.target)) {\n            return false;\n        }\n\n        // If request OR cached entity has requested Claims Hash, check if they match\n        if (filter.requestedClaimsHash || entity.requestedClaimsHash) {\n            // Don't match if either is undefined or they are different\n            if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {\n                return false;\n            }\n        }\n\n        // Access Token with Auth Scheme specific matching\n        if (\n            entity.credentialType ===\n            CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME\n        ) {\n            if (\n                !!filter.tokenType &&\n                !this.matchTokenType(entity, filter.tokenType)\n            ) {\n                return false;\n            }\n\n            // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n            if (filter.tokenType === AuthenticationScheme.SSH) {\n                if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\n     * @param filter\n     */\n    getAppMetadataFilteredBy(filter: AppMetadataFilter): AppMetadataCache {\n        return this.getAppMetadataFilteredByInternal(\n            filter.environment,\n            filter.clientId\n        );\n    }\n\n    /**\n     * Support function to help match appMetadata\n     * @param environment\n     * @param clientId\n     */\n    private getAppMetadataFilteredByInternal(\n        environment?: string,\n        clientId?: string\n    ): AppMetadataCache {\n        const allCacheKeys = this.getKeys();\n        const matchingAppMetadata: AppMetadataCache = {};\n\n        allCacheKeys.forEach((cacheKey) => {\n            // don't parse any non-appMetadata type cache entities\n            if (!this.isAppMetadata(cacheKey)) {\n                return;\n            }\n\n            // Attempt retrieval\n            const entity = this.getAppMetadata(cacheKey);\n\n            if (!entity) {\n                return;\n            }\n\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\n                return;\n            }\n\n            if (!!clientId && !this.matchClientId(entity, clientId)) {\n                return;\n            }\n\n            matchingAppMetadata[cacheKey] = entity;\n        });\n\n        return matchingAppMetadata;\n    }\n\n    /**\n     * retrieve authorityMetadata that contains a matching alias\n     * @param filter\n     */\n    getAuthorityMetadataByAlias(host: string): AuthorityMetadataEntity | null {\n        const allCacheKeys = this.getAuthorityMetadataKeys();\n        let matchedEntity = null;\n\n        allCacheKeys.forEach((cacheKey) => {\n            // don't parse any non-authorityMetadata type cache entities\n            if (\n                !this.isAuthorityMetadata(cacheKey) ||\n                cacheKey.indexOf(this.clientId) === -1\n            ) {\n                return;\n            }\n\n            // Attempt retrieval\n            const entity = this.getAuthorityMetadata(cacheKey);\n\n            if (!entity) {\n                return;\n            }\n\n            if (entity.aliases.indexOf(host) === -1) {\n                return;\n            }\n\n            matchedEntity = entity;\n        });\n\n        return matchedEntity;\n    }\n\n    /**\n     * Removes all accounts and related tokens from cache.\n     */\n    async removeAllAccounts(): Promise<void> {\n        const allAccountKeys = this.getAccountKeys();\n        const removedAccounts: Array<Promise<void>> = [];\n\n        allAccountKeys.forEach((cacheKey) => {\n            removedAccounts.push(this.removeAccount(cacheKey));\n        });\n\n        await Promise.all(removedAccounts);\n    }\n\n    /**\n     * Removes the account and related tokens for a given account key\n     * @param account\n     */\n    async removeAccount(accountKey: string): Promise<void> {\n        const account = this.getAccount(accountKey);\n        if (!account) {\n            return;\n        }\n        await this.removeAccountContext(account);\n        this.removeItem(accountKey);\n    }\n\n    /**\n     * Removes credentials associated with the provided account\n     * @param account\n     */\n    async removeAccountContext(account: AccountEntity): Promise<void> {\n        const allTokenKeys = this.getTokenKeys();\n        const accountId = account.generateAccountId();\n        const removedCredentials: Array<Promise<void>> = [];\n\n        allTokenKeys.idToken.forEach((key) => {\n            if (key.indexOf(accountId) === 0) {\n                this.removeIdToken(key);\n            }\n        });\n\n        allTokenKeys.accessToken.forEach((key) => {\n            if (key.indexOf(accountId) === 0) {\n                removedCredentials.push(this.removeAccessToken(key));\n            }\n        });\n\n        allTokenKeys.refreshToken.forEach((key) => {\n            if (key.indexOf(accountId) === 0) {\n                this.removeRefreshToken(key);\n            }\n        });\n\n        await Promise.all(removedCredentials);\n    }\n\n    /**\n     * returns a boolean if the given credential is removed\n     * @param credential\n     */\n    async removeAccessToken(key: string): Promise<void> {\n        const credential = this.getAccessTokenCredential(key);\n        if (!credential) {\n            return;\n        }\n\n        // Remove Token Binding Key from key store for PoP Tokens Credentials\n        if (\n            credential.credentialType.toLowerCase() ===\n            CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()\n        ) {\n            if (credential.tokenType === AuthenticationScheme.POP) {\n                const accessTokenWithAuthSchemeEntity =\n                    credential as AccessTokenEntity;\n                const kid = accessTokenWithAuthSchemeEntity.keyId;\n\n                if (kid) {\n                    try {\n                        await this.cryptoImpl.removeTokenBindingKey(kid);\n                    } catch (error) {\n                        throw createClientAuthError(\n                            ClientAuthErrorCodes.bindingKeyNotRemoved\n                        );\n                    }\n                }\n            }\n        }\n\n        return this.removeItem(key);\n    }\n\n    /**\n     * Removes all app metadata objects from cache.\n     */\n    removeAppMetadata(): boolean {\n        const allCacheKeys = this.getKeys();\n        allCacheKeys.forEach((cacheKey) => {\n            if (this.isAppMetadata(cacheKey)) {\n                this.removeItem(cacheKey);\n            }\n        });\n\n        return true;\n    }\n\n    /**\n     * Retrieve the cached credentials into a cacherecord\n     * @param account {AccountInfo}\n     * @param request {BaseAuthRequest}\n     * @param environment {string}\n     * @param performanceClient {?IPerformanceClient}\n     * @param correlationId {?string}\n     */\n    readCacheRecord(\n        account: AccountInfo,\n        request: BaseAuthRequest,\n        environment: string,\n        performanceClient?: IPerformanceClient,\n        correlationId?: string\n    ): CacheRecord {\n        const tokenKeys = this.getTokenKeys();\n        const cachedAccount = this.readAccountFromCache(account);\n        const cachedIdToken = this.getIdToken(\n            account,\n            tokenKeys,\n            performanceClient,\n            correlationId\n        );\n        const cachedAccessToken = this.getAccessToken(\n            account,\n            request,\n            tokenKeys,\n            performanceClient,\n            correlationId\n        );\n        const cachedRefreshToken = this.getRefreshToken(\n            account,\n            false,\n            tokenKeys,\n            performanceClient,\n            correlationId\n        );\n        const cachedAppMetadata = this.readAppMetadataFromCache(environment);\n\n        if (cachedAccount && cachedIdToken) {\n            cachedAccount.idTokenClaims = extractTokenClaims(\n                cachedIdToken.secret,\n                this.cryptoImpl.base64Decode\n            );\n        }\n\n        return {\n            account: cachedAccount,\n            idToken: cachedIdToken,\n            accessToken: cachedAccessToken,\n            refreshToken: cachedRefreshToken,\n            appMetadata: cachedAppMetadata,\n        };\n    }\n\n    /**\n     * Retrieve AccountEntity from cache\n     * @param account\n     */\n    readAccountFromCache(account: AccountInfo): AccountEntity | null {\n        const accountKey: string =\n            AccountEntity.generateAccountCacheKey(account);\n        return this.getAccount(accountKey);\n    }\n\n    /**\n     * Retrieve IdTokenEntity from cache\n     * @param account {AccountInfo}\n     * @param tokenKeys {?TokenKeys}\n     * @param performanceClient {?IPerformanceClient}\n     * @param correlationId {?string}\n     */\n    getIdToken(\n        account: AccountInfo,\n        tokenKeys?: TokenKeys,\n        performanceClient?: IPerformanceClient,\n        correlationId?: string\n    ): IdTokenEntity | null {\n        this.commonLogger.trace(\"CacheManager - getIdToken called\");\n        const idTokenFilter: CredentialFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: CredentialType.ID_TOKEN,\n            clientId: this.clientId,\n            realm: account.tenantId,\n        };\n\n        const idTokens: IdTokenEntity[] = this.getIdTokensByFilter(\n            idTokenFilter,\n            tokenKeys\n        );\n        const numIdTokens = idTokens.length;\n\n        if (numIdTokens < 1) {\n            this.commonLogger.info(\"CacheManager:getIdToken - No token found\");\n            return null;\n        } else if (numIdTokens > 1) {\n            this.commonLogger.info(\n                \"CacheManager:getIdToken - Multiple id tokens found, clearing them\"\n            );\n            idTokens.forEach((idToken) => {\n                this.removeIdToken(generateCredentialKey(idToken));\n            });\n            if (performanceClient && correlationId) {\n                performanceClient.addFields(\n                    { multiMatchedID: idTokens.length },\n                    correlationId\n                );\n            }\n            return null;\n        }\n\n        this.commonLogger.info(\"CacheManager:getIdToken - Returning id token\");\n        return idTokens[0];\n    }\n\n    /**\n     * Gets all idTokens matching the given filter\n     * @param filter\n     * @returns\n     */\n    getIdTokensByFilter(\n        filter: CredentialFilter,\n        tokenKeys?: TokenKeys\n    ): IdTokenEntity[] {\n        const idTokenKeys =\n            (tokenKeys && tokenKeys.idToken) || this.getTokenKeys().idToken;\n\n        const idTokens: IdTokenEntity[] = [];\n        idTokenKeys.forEach((key) => {\n            if (\n                !this.idTokenKeyMatchesFilter(key, {\n                    clientId: this.clientId,\n                    ...filter,\n                })\n            ) {\n                return;\n            }\n            const idToken = this.getIdTokenCredential(key);\n            if (idToken && this.credentialMatchesFilter(idToken, filter)) {\n                idTokens.push(idToken);\n            }\n        });\n\n        return idTokens;\n    }\n\n    /**\n     * Validate the cache key against filter before retrieving and parsing cache value\n     * @param key\n     * @param filter\n     * @returns\n     */\n    idTokenKeyMatchesFilter(\n        inputKey: string,\n        filter: CredentialFilter\n    ): boolean {\n        const key = inputKey.toLowerCase();\n        if (\n            filter.clientId &&\n            key.indexOf(filter.clientId.toLowerCase()) === -1\n        ) {\n            return false;\n        }\n\n        if (\n            filter.homeAccountId &&\n            key.indexOf(filter.homeAccountId.toLowerCase()) === -1\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Removes idToken from the cache\n     * @param key\n     */\n    removeIdToken(key: string): void {\n        this.removeItem(key);\n    }\n\n    /**\n     * Removes refresh token from the cache\n     * @param key\n     */\n    removeRefreshToken(key: string): void {\n        this.removeItem(key);\n    }\n\n    /**\n     * Retrieve AccessTokenEntity from cache\n     * @param account {AccountInfo}\n     * @param request {BaseAuthRequest}\n     * @param tokenKeys {?TokenKeys}\n     * @param performanceClient {?IPerformanceClient}\n     * @param correlationId {?string}\n     */\n    getAccessToken(\n        account: AccountInfo,\n        request: BaseAuthRequest,\n        tokenKeys?: TokenKeys,\n        performanceClient?: IPerformanceClient,\n        correlationId?: string\n    ): AccessTokenEntity | null {\n        this.commonLogger.trace(\"CacheManager - getAccessToken called\");\n        const scopes = ScopeSet.createSearchScopes(request.scopes);\n        const authScheme =\n            request.authenticationScheme || AuthenticationScheme.BEARER;\n        /*\n         * Distinguish between Bearer and PoP/SSH token cache types\n         * Cast to lowercase to handle \"bearer\" from ADFS\n         */\n        const credentialType =\n            authScheme &&\n            authScheme.toLowerCase() !==\n                AuthenticationScheme.BEARER.toLowerCase()\n                ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME\n                : CredentialType.ACCESS_TOKEN;\n\n        const accessTokenFilter: CredentialFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: credentialType,\n            clientId: this.clientId,\n            realm: account.tenantId,\n            target: scopes,\n            tokenType: authScheme,\n            keyId: request.sshKid,\n            requestedClaimsHash: request.requestedClaimsHash,\n        };\n\n        const accessTokenKeys =\n            (tokenKeys && tokenKeys.accessToken) ||\n            this.getTokenKeys().accessToken;\n        const accessTokens: AccessTokenEntity[] = [];\n\n        accessTokenKeys.forEach((key) => {\n            // Validate key\n            if (\n                this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)\n            ) {\n                const accessToken = this.getAccessTokenCredential(key);\n\n                // Validate value\n                if (\n                    accessToken &&\n                    this.credentialMatchesFilter(accessToken, accessTokenFilter)\n                ) {\n                    accessTokens.push(accessToken);\n                }\n            }\n        });\n\n        const numAccessTokens = accessTokens.length;\n        if (numAccessTokens < 1) {\n            this.commonLogger.info(\n                \"CacheManager:getAccessToken - No token found\"\n            );\n            return null;\n        } else if (numAccessTokens > 1) {\n            this.commonLogger.info(\n                \"CacheManager:getAccessToken - Multiple access tokens found, clearing them\"\n            );\n            accessTokens.forEach((accessToken) => {\n                void this.removeAccessToken(generateCredentialKey(accessToken));\n            });\n            if (performanceClient && correlationId) {\n                performanceClient.addFields(\n                    { multiMatchedAT: accessTokens.length },\n                    correlationId\n                );\n            }\n            return null;\n        }\n\n        this.commonLogger.info(\n            \"CacheManager:getAccessToken - Returning access token\"\n        );\n        return accessTokens[0];\n    }\n\n    /**\n     * Validate the cache key against filter before retrieving and parsing cache value\n     * @param key\n     * @param filter\n     * @param keyMustContainAllScopes\n     * @returns\n     */\n    accessTokenKeyMatchesFilter(\n        inputKey: string,\n        filter: CredentialFilter,\n        keyMustContainAllScopes: boolean\n    ): boolean {\n        const key = inputKey.toLowerCase();\n        if (\n            filter.clientId &&\n            key.indexOf(filter.clientId.toLowerCase()) === -1\n        ) {\n            return false;\n        }\n\n        if (\n            filter.homeAccountId &&\n            key.indexOf(filter.homeAccountId.toLowerCase()) === -1\n        ) {\n            return false;\n        }\n\n        if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {\n            return false;\n        }\n\n        if (\n            filter.requestedClaimsHash &&\n            key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1\n        ) {\n            return false;\n        }\n\n        if (filter.target) {\n            const scopes = filter.target.asArray();\n            for (let i = 0; i < scopes.length; i++) {\n                if (\n                    keyMustContainAllScopes &&\n                    !key.includes(scopes[i].toLowerCase())\n                ) {\n                    // When performing a cache lookup a missing scope would be a cache miss\n                    return false;\n                } else if (\n                    !keyMustContainAllScopes &&\n                    key.includes(scopes[i].toLowerCase())\n                ) {\n                    // When performing a cache write, any token with a subset of requested scopes should be replaced\n                    return true;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Gets all access tokens matching the filter\n     * @param filter\n     * @returns\n     */\n    getAccessTokensByFilter(filter: CredentialFilter): AccessTokenEntity[] {\n        const tokenKeys = this.getTokenKeys();\n\n        const accessTokens: AccessTokenEntity[] = [];\n        tokenKeys.accessToken.forEach((key) => {\n            if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {\n                return;\n            }\n\n            const accessToken = this.getAccessTokenCredential(key);\n            if (\n                accessToken &&\n                this.credentialMatchesFilter(accessToken, filter)\n            ) {\n                accessTokens.push(accessToken);\n            }\n        });\n\n        return accessTokens;\n    }\n\n    /**\n     * Helper to retrieve the appropriate refresh token from cache\n     * @param account {AccountInfo}\n     * @param familyRT {boolean}\n     * @param tokenKeys {?TokenKeys}\n     * @param performanceClient {?IPerformanceClient}\n     * @param correlationId {?string}\n     */\n    getRefreshToken(\n        account: AccountInfo,\n        familyRT: boolean,\n        tokenKeys?: TokenKeys,\n        performanceClient?: IPerformanceClient,\n        correlationId?: string\n    ): RefreshTokenEntity | null {\n        this.commonLogger.trace(\"CacheManager - getRefreshToken called\");\n        const id = familyRT ? THE_FAMILY_ID : undefined;\n        const refreshTokenFilter: CredentialFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: CredentialType.REFRESH_TOKEN,\n            clientId: this.clientId,\n            familyId: id,\n        };\n\n        const refreshTokenKeys =\n            (tokenKeys && tokenKeys.refreshToken) ||\n            this.getTokenKeys().refreshToken;\n        const refreshTokens: RefreshTokenEntity[] = [];\n\n        refreshTokenKeys.forEach((key) => {\n            // Validate key\n            if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {\n                const refreshToken = this.getRefreshTokenCredential(key);\n                // Validate value\n                if (\n                    refreshToken &&\n                    this.credentialMatchesFilter(\n                        refreshToken,\n                        refreshTokenFilter\n                    )\n                ) {\n                    refreshTokens.push(refreshToken);\n                }\n            }\n        });\n\n        const numRefreshTokens = refreshTokens.length;\n        if (numRefreshTokens < 1) {\n            this.commonLogger.info(\n                \"CacheManager:getRefreshToken - No refresh token found.\"\n            );\n            return null;\n        }\n        // address the else case after remove functions address environment aliases\n\n        if (numRefreshTokens > 1 && performanceClient && correlationId) {\n            performanceClient.addFields(\n                { multiMatchedRT: numRefreshTokens },\n                correlationId\n            );\n        }\n\n        this.commonLogger.info(\n            \"CacheManager:getRefreshToken - returning refresh token\"\n        );\n        return refreshTokens[0] as RefreshTokenEntity;\n    }\n\n    /**\n     * Validate the cache key against filter before retrieving and parsing cache value\n     * @param key\n     * @param filter\n     */\n    refreshTokenKeyMatchesFilter(\n        inputKey: string,\n        filter: CredentialFilter\n    ): boolean {\n        const key = inputKey.toLowerCase();\n        if (\n            filter.familyId &&\n            key.indexOf(filter.familyId.toLowerCase()) === -1\n        ) {\n            return false;\n        }\n\n        // If familyId is used, clientId is not in the key\n        if (\n            !filter.familyId &&\n            filter.clientId &&\n            key.indexOf(filter.clientId.toLowerCase()) === -1\n        ) {\n            return false;\n        }\n\n        if (\n            filter.homeAccountId &&\n            key.indexOf(filter.homeAccountId.toLowerCase()) === -1\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Retrieve AppMetadataEntity from cache\n     */\n    readAppMetadataFromCache(environment: string): AppMetadataEntity | null {\n        const appMetadataFilter: AppMetadataFilter = {\n            environment,\n            clientId: this.clientId,\n        };\n\n        const appMetadata: AppMetadataCache =\n            this.getAppMetadataFilteredBy(appMetadataFilter);\n        const appMetadataEntries: AppMetadataEntity[] = Object.keys(\n            appMetadata\n        ).map((key) => appMetadata[key]);\n\n        const numAppMetadata = appMetadataEntries.length;\n        if (numAppMetadata < 1) {\n            return null;\n        } else if (numAppMetadata > 1) {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.multipleMatchingAppMetadata\n            );\n        }\n\n        return appMetadataEntries[0] as AppMetadataEntity;\n    }\n\n    /**\n     * Return the family_id value associated  with FOCI\n     * @param environment\n     * @param clientId\n     */\n    isAppMetadataFOCI(environment: string): boolean {\n        const appMetadata = this.readAppMetadataFromCache(environment);\n        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n    }\n\n    /**\n     * helper to match account ids\n     * @param value\n     * @param homeAccountId\n     */\n    private matchHomeAccountId(\n        entity: AccountEntity | CredentialEntity,\n        homeAccountId: string\n    ): boolean {\n        return !!(\n            typeof entity.homeAccountId === \"string\" &&\n            homeAccountId === entity.homeAccountId\n        );\n    }\n\n    /**\n     * helper to match account ids\n     * @param entity\n     * @param localAccountId\n     * @returns\n     */\n    private matchLocalAccountId(\n        entity: AccountEntity,\n        localAccountId: string\n    ): boolean {\n        return !!(\n            typeof entity.localAccountId === \"string\" &&\n            localAccountId === entity.localAccountId\n        );\n    }\n\n    /**\n     * helper to match usernames\n     * @param entity\n     * @param username\n     * @returns\n     */\n    private matchUsername(entity: AccountEntity, username: string): boolean {\n        return !!(\n            typeof entity.username === \"string\" &&\n            username.toLowerCase() === entity.username.toLowerCase()\n        );\n    }\n\n    /**\n     * helper to match names\n     * @param entity\n     * @param name\n     * @returns true if the downcased name properties are present and match in the filter and the entity\n     */\n    private matchName(entity: AccountEntity, name: string): boolean {\n        return !!(name.toLowerCase() === entity.name?.toLowerCase());\n    }\n\n    /**\n     * helper to match assertion\n     * @param value\n     * @param oboAssertion\n     */\n    private matchUserAssertionHash(\n        entity: CredentialEntity,\n        userAssertionHash: string\n    ): boolean {\n        return !!(\n            entity.userAssertionHash &&\n            userAssertionHash === entity.userAssertionHash\n        );\n    }\n\n    /**\n     * helper to match environment\n     * @param value\n     * @param environment\n     */\n    private matchEnvironment(\n        entity: AccountEntity | CredentialEntity | AppMetadataEntity,\n        environment: string\n    ): boolean {\n        // Check static authority options first for cases where authority metadata has not been resolved and cached yet\n        if (this.staticAuthorityOptions) {\n            const staticAliases = getAliasesFromStaticSources(\n                this.staticAuthorityOptions,\n                this.commonLogger\n            );\n            if (\n                staticAliases.includes(environment) &&\n                staticAliases.includes(entity.environment)\n            ) {\n                return true;\n            }\n        }\n\n        // Query metadata cache if no static authority configuration has aliases that match enviroment\n        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n        if (\n            cloudMetadata &&\n            cloudMetadata.aliases.indexOf(entity.environment) > -1\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * helper to match credential type\n     * @param entity\n     * @param credentialType\n     */\n    private matchCredentialType(\n        entity: CredentialEntity,\n        credentialType: string\n    ): boolean {\n        return (\n            entity.credentialType &&\n            credentialType.toLowerCase() === entity.credentialType.toLowerCase()\n        );\n    }\n\n    /**\n     * helper to match client ids\n     * @param entity\n     * @param clientId\n     */\n    private matchClientId(\n        entity: CredentialEntity | AppMetadataEntity,\n        clientId: string\n    ): boolean {\n        return !!(entity.clientId && clientId === entity.clientId);\n    }\n\n    /**\n     * helper to match family ids\n     * @param entity\n     * @param familyId\n     */\n    private matchFamilyId(\n        entity: CredentialEntity | AppMetadataEntity,\n        familyId: string\n    ): boolean {\n        return !!(entity.familyId && familyId === entity.familyId);\n    }\n\n    /**\n     * helper to match realm\n     * @param entity\n     * @param realm\n     */\n    private matchRealm(\n        entity: AccountEntity | CredentialEntity,\n        realm: string\n    ): boolean {\n        return !!(entity.realm && realm === entity.realm);\n    }\n\n    /**\n     * helper to match nativeAccountId\n     * @param entity\n     * @param nativeAccountId\n     * @returns boolean indicating the match result\n     */\n    private matchNativeAccountId(\n        entity: AccountEntity,\n        nativeAccountId: string\n    ): boolean {\n        return !!(\n            entity.nativeAccountId && nativeAccountId === entity.nativeAccountId\n        );\n    }\n\n    /**\n     * helper to match loginHint which can be either:\n     * 1. login_hint ID token claim\n     * 2. username in cached account object\n     * 3. upn in ID token claims\n     * @param entity\n     * @param loginHint\n     * @returns\n     */\n    private matchLoginHint(\n        idTokenClaims: TokenClaims,\n        loginHint: string\n    ): boolean {\n        if (idTokenClaims?.login_hint === loginHint) {\n            return true;\n        }\n\n        if (idTokenClaims.preferred_username === loginHint) {\n            return true;\n        }\n\n        if (idTokenClaims?.upn === loginHint) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Helper to match sid\n     * @param idTokenClaims\n     * @param sid\n     * @returns true if the sid claim is present and matches the filter\n     */\n    private matchSid(idTokenClaims: TokenClaims, sid: string): boolean {\n        return !!(idTokenClaims?.sid && idTokenClaims.sid === sid);\n    }\n\n    private matchAuthorityType(\n        entity: AccountEntity,\n        authorityType: string\n    ): boolean {\n        return !!(\n            entity.authorityType &&\n            authorityType.toLowerCase() === entity.authorityType.toLowerCase()\n        );\n    }\n\n    /**\n     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\n     * @param entity\n     * @param target\n     */\n    private matchTarget(entity: CredentialEntity, target: ScopeSet): boolean {\n        const isNotAccessTokenCredential =\n            entity.credentialType !== CredentialType.ACCESS_TOKEN &&\n            entity.credentialType !==\n                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n\n        if (isNotAccessTokenCredential || !entity.target) {\n            return false;\n        }\n\n        const entityScopeSet: ScopeSet = ScopeSet.fromString(entity.target);\n\n        return entityScopeSet.containsScopeSet(target);\n    }\n\n    /**\n     * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\n     * @param entity\n     * @param tokenType\n     */\n    private matchTokenType(\n        entity: CredentialEntity,\n        tokenType: AuthenticationScheme\n    ): boolean {\n        return !!(entity.tokenType && entity.tokenType === tokenType);\n    }\n\n    /**\n     * Returns true if the credential's keyId matches the one in the request, false otherwise\n     * @param entity\n     * @param tokenType\n     */\n    private matchKeyId(entity: CredentialEntity, keyId: string): boolean {\n        return !!(entity.keyId && entity.keyId === keyId);\n    }\n\n    /**\n     * returns if a given cache entity is of the type appmetadata\n     * @param key\n     */\n    private isAppMetadata(key: string): boolean {\n        return key.indexOf(APP_METADATA) !== -1;\n    }\n\n    /**\n     * returns if a given cache entity is of the type authoritymetadata\n     * @param key\n     */\n    protected isAuthorityMetadata(key: string): boolean {\n        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n    }\n\n    /**\n     * returns cache key used for cloud instance metadata\n     */\n    generateAuthorityMetadataCacheKey(authority: string): string {\n        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;\n    }\n\n    /**\n     * Helper to convert serialized data to object\n     * @param obj\n     * @param json\n     */\n    static toObject<T>(obj: T, json: object): T {\n        for (const propertyName in json) {\n            obj[propertyName] = json[propertyName];\n        }\n        return obj;\n    }\n}\n\n/** @internal */\nexport class DefaultStorageClass extends CacheManager {\n    setAccount(): void {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getAccount(): AccountEntity {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    setIdTokenCredential(): void {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getIdTokenCredential(): IdTokenEntity {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    setAccessTokenCredential(): void {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getAccessTokenCredential(): AccessTokenEntity {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    setRefreshTokenCredential(): void {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getRefreshTokenCredential(): RefreshTokenEntity {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    setAppMetadata(): void {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getAppMetadata(): AppMetadataEntity {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    setServerTelemetry(): void {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getServerTelemetry(): ServerTelemetryEntity {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    setAuthorityMetadata(): void {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getAuthorityMetadata(): AuthorityMetadataEntity | null {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getAuthorityMetadataKeys(): Array<string> {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    setThrottlingCache(): void {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getThrottlingCache(): ThrottlingEntity {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    removeItem(): boolean {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    containsKey(): boolean {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getKeys(): string[] {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getAccountKeys(): string[] {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    getTokenKeys(): TokenKeys {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    async clear(): Promise<void> {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n    updateCredentialCacheKey(): string {\n        throw createClientAuthError(ClientAuthErrorCodes.methodNotImplemented);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}