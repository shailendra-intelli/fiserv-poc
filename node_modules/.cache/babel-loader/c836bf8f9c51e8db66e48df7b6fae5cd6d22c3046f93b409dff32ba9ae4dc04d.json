{"ast":null,"code":"/*! @azure/msal-browser v3.1.0 2023-09-05 */\n'use strict';\n\nimport { AccountEntity, PerformanceEvents, AuthenticationScheme, ClientConfigurationError, StringUtils, UrlString, ServerTelemetryManager, AuthorityFactory } from '@azure/msal-common';\nimport { version } from '../packageMetadata.mjs';\nimport { BrowserConstants } from '../utils/BrowserConstants.mjs';\nimport { BrowserUtils } from '../utils/BrowserUtils.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nclass BaseInteractionClient {\n  constructor(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, performanceClient, nativeMessageHandler, correlationId) {\n    this.config = config;\n    this.browserStorage = storageImpl;\n    this.browserCrypto = browserCrypto;\n    this.networkClient = this.config.system.networkClient;\n    this.eventHandler = eventHandler;\n    this.navigationClient = navigationClient;\n    this.nativeMessageHandler = nativeMessageHandler;\n    this.correlationId = correlationId || this.browserCrypto.createNewGuid();\n    this.logger = logger.clone(BrowserConstants.MSAL_SKU, version, this.correlationId);\n    this.performanceClient = performanceClient;\n  }\n  async clearCacheOnLogout(account) {\n    if (account) {\n      if (AccountEntity.accountInfoIsEqual(account, this.browserStorage.getActiveAccount(), false)) {\n        this.logger.verbose(\"Setting active account to null\");\n        this.browserStorage.setActiveAccount(null);\n      }\n      // Clear given account.\n      try {\n        await this.browserStorage.removeAccount(AccountEntity.generateAccountCacheKey(account));\n        this.logger.verbose(\"Cleared cache items belonging to the account provided in the logout request.\");\n      } catch (error) {\n        this.logger.error(\"Account provided in logout request was not found. Local cache unchanged.\");\n      }\n    } else {\n      try {\n        this.logger.verbose(\"No account provided in logout request, clearing all cache items.\", this.correlationId);\n        // Clear all accounts and tokens\n        await this.browserStorage.clear();\n        // Clear any stray keys from IndexedDB\n        await this.browserCrypto.clearKeystore();\n      } catch (e) {\n        this.logger.error(\"Attempted to clear all MSAL cache items and failed. Local cache unchanged.\");\n      }\n    }\n  }\n  /**\n   * Initializer function for all request APIs\n   * @param request\n   */\n  async initializeBaseRequest(request, account) {\n    this.performanceClient.addQueueMeasurement(PerformanceEvents.InitializeBaseRequest, request.correlationId);\n    this.logger.verbose(\"Initializing BaseAuthRequest\");\n    const authority = request.authority || this.config.auth.authority;\n    if (account) {\n      await this.validateRequestAuthority(authority, account);\n    }\n    const scopes = [...(request && request.scopes || [])];\n    const validatedRequest = {\n      ...request,\n      correlationId: this.correlationId,\n      authority,\n      scopes\n    };\n    // Set authenticationScheme to BEARER if not explicitly set in the request\n    if (!validatedRequest.authenticationScheme) {\n      validatedRequest.authenticationScheme = AuthenticationScheme.BEARER;\n      this.logger.verbose('Authentication Scheme wasn\\'t explicitly set in request, defaulting to \"Bearer\" request');\n    } else {\n      if (validatedRequest.authenticationScheme === AuthenticationScheme.SSH) {\n        if (!request.sshJwk) {\n          throw ClientConfigurationError.createMissingSshJwkError();\n        }\n        if (!request.sshKid) {\n          throw ClientConfigurationError.createMissingSshKidError();\n        }\n      }\n      this.logger.verbose(`Authentication Scheme set to \"${validatedRequest.authenticationScheme}\" as configured in Auth request`);\n    }\n    // Set requested claims hash if claims-based caching is enabled and claims were requested\n    if (this.config.cache.claimsBasedCachingEnabled && request.claims &&\n    // Checks for empty stringified object \"{}\" which doesn't qualify as requested claims\n    !StringUtils.isEmptyObj(request.claims)) {\n      validatedRequest.requestedClaimsHash = await this.browserCrypto.hashString(request.claims);\n    }\n    return validatedRequest;\n  }\n  /**\n   *\n   * Use to get the redirect uri configured in MSAL or null.\n   * @param requestRedirectUri\n   * @returns Redirect URL\n   *\n   */\n  getRedirectUri(requestRedirectUri) {\n    this.logger.verbose(\"getRedirectUri called\");\n    const redirectUri = requestRedirectUri || this.config.auth.redirectUri || BrowserUtils.getCurrentUri();\n    return UrlString.getAbsoluteUrl(redirectUri, BrowserUtils.getCurrentUri());\n  }\n  /*\n   * If authority provided in the request does not match environment/authority specified\n   * in the account or MSAL config, we throw an error.\n   */\n  async validateRequestAuthority(authority, account) {\n    const discoveredAuthority = await this.getDiscoveredAuthority(authority);\n    if (!discoveredAuthority.isAlias(account.environment)) {\n      throw ClientConfigurationError.createAuthorityMismatchError();\n    }\n  }\n  /**\n   *\n   * @param apiId\n   * @param correlationId\n   * @param forceRefresh\n   */\n  initializeServerTelemetryManager(apiId, forceRefresh) {\n    this.logger.verbose(\"initializeServerTelemetryManager called\");\n    const telemetryPayload = {\n      clientId: this.config.auth.clientId,\n      correlationId: this.correlationId,\n      apiId: apiId,\n      forceRefresh: forceRefresh || false,\n      wrapperSKU: this.browserStorage.getWrapperMetadata()[0],\n      wrapperVer: this.browserStorage.getWrapperMetadata()[1]\n    };\n    return new ServerTelemetryManager(telemetryPayload, this.browserStorage);\n  }\n  /**\n   * Used to get a discovered version of the default authority.\n   * @param requestAuthority\n   * @param requestCorrelationId\n   */\n  async getDiscoveredAuthority(requestAuthority) {\n    this.logger.verbose(\"getDiscoveredAuthority called\");\n    const authorityOptions = {\n      protocolMode: this.config.auth.protocolMode,\n      OIDCOptions: this.config.auth.OIDCOptions,\n      knownAuthorities: this.config.auth.knownAuthorities,\n      cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n      authorityMetadata: this.config.auth.authorityMetadata\n    };\n    if (requestAuthority) {\n      this.logger.verbose(\"Creating discovered authority with request authority\");\n      return await AuthorityFactory.createDiscoveredInstance(requestAuthority, this.config.system.networkClient, this.browserStorage, authorityOptions, this.logger);\n    }\n    this.logger.verbose(\"Creating discovered authority with configured authority\");\n    return await AuthorityFactory.createDiscoveredInstance(this.config.auth.authority, this.config.system.networkClient, this.browserStorage, authorityOptions, this.logger);\n  }\n}\nexport { BaseInteractionClient };","map":{"version":3,"names":["BaseInteractionClient","constructor","config","storageImpl","browserCrypto","logger","eventHandler","navigationClient","performanceClient","nativeMessageHandler","correlationId","browserStorage","networkClient","system","createNewGuid","clone","BrowserConstants","MSAL_SKU","version","clearCacheOnLogout","account","AccountEntity","accountInfoIsEqual","getActiveAccount","verbose","setActiveAccount","removeAccount","generateAccountCacheKey","clear","error","initializeBaseRequest","request"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\interaction_client\\BaseInteractionClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    ICrypto,\n    INetworkModule,\n    Logger,\n    AccountInfo,\n    AccountEntity,\n    BaseAuthRequest,\n    AuthenticationScheme,\n    UrlString,\n    ServerTelemetryManager,\n    ServerTelemetryRequest,\n    ClientConfigurationError,\n    Authority,\n    AuthorityOptions,\n    AuthorityFactory,\n    IPerformanceClient,\n    PerformanceEvents,\n    StringUtils,\n} from \"@azure/msal-common\";\nimport { BrowserConfiguration } from \"../config/Configuration\";\nimport { BrowserCacheManager } from \"../cache/BrowserCacheManager\";\nimport { EventHandler } from \"../event/EventHandler\";\nimport { EndSessionRequest } from \"../request/EndSessionRequest\";\nimport { RedirectRequest } from \"../request/RedirectRequest\";\nimport { PopupRequest } from \"../request/PopupRequest\";\nimport { SsoSilentRequest } from \"../request/SsoSilentRequest\";\nimport { version } from \"../packageMetadata\";\nimport { BrowserConstants } from \"../utils/BrowserConstants\";\nimport { BrowserUtils } from \"../utils/BrowserUtils\";\nimport { INavigationClient } from \"../navigation/INavigationClient\";\nimport { NativeMessageHandler } from \"../broker/nativeBroker/NativeMessageHandler\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\nimport { ClearCacheRequest } from \"../request/ClearCacheRequest\";\n\nexport abstract class BaseInteractionClient {\n    protected config: BrowserConfiguration;\n    protected browserStorage: BrowserCacheManager;\n    protected browserCrypto: ICrypto;\n    protected networkClient: INetworkModule;\n    protected logger: Logger;\n    protected eventHandler: EventHandler;\n    protected navigationClient: INavigationClient;\n    protected nativeMessageHandler: NativeMessageHandler | undefined;\n    protected correlationId: string;\n    protected performanceClient: IPerformanceClient;\n\n    constructor(\n        config: BrowserConfiguration,\n        storageImpl: BrowserCacheManager,\n        browserCrypto: ICrypto,\n        logger: Logger,\n        eventHandler: EventHandler,\n        navigationClient: INavigationClient,\n        performanceClient: IPerformanceClient,\n        nativeMessageHandler?: NativeMessageHandler,\n        correlationId?: string\n    ) {\n        this.config = config;\n        this.browserStorage = storageImpl;\n        this.browserCrypto = browserCrypto;\n        this.networkClient = this.config.system.networkClient;\n        this.eventHandler = eventHandler;\n        this.navigationClient = navigationClient;\n        this.nativeMessageHandler = nativeMessageHandler;\n        this.correlationId =\n            correlationId || this.browserCrypto.createNewGuid();\n        this.logger = logger.clone(\n            BrowserConstants.MSAL_SKU,\n            version,\n            this.correlationId\n        );\n        this.performanceClient = performanceClient;\n    }\n\n    abstract acquireToken(\n        request: RedirectRequest | PopupRequest | SsoSilentRequest\n    ): Promise<AuthenticationResult | void>;\n\n    abstract logout(\n        request: EndSessionRequest | ClearCacheRequest | undefined\n    ): Promise<void>;\n\n    protected async clearCacheOnLogout(\n        account?: AccountInfo | null\n    ): Promise<void> {\n        if (account) {\n            if (\n                AccountEntity.accountInfoIsEqual(\n                    account,\n                    this.browserStorage.getActiveAccount(),\n                    false\n                )\n            ) {\n                this.logger.verbose(\"Setting active account to null\");\n                this.browserStorage.setActiveAccount(null);\n            }\n            // Clear given account.\n            try {\n                await this.browserStorage.removeAccount(\n                    AccountEntity.generateAccountCacheKey(account)\n                );\n                this.logger.verbose(\n                    \"Cleared cache items belonging to the account provided in the logout request.\"\n                );\n            } catch (error) {\n                this.logger.error(\n                    \"Account provided in logout request was not found. Local cache unchanged.\"\n                );\n            }\n        } else {\n            try {\n                this.logger.verbose(\n                    \"No account provided in logout request, clearing all cache items.\",\n                    this.correlationId\n                );\n                // Clear all accounts and tokens\n                await this.browserStorage.clear();\n                // Clear any stray keys from IndexedDB\n                await this.browserCrypto.clearKeystore();\n            } catch (e) {\n                this.logger.error(\n                    \"Attempted to clear all MSAL cache items and failed. Local cache unchanged.\"\n                );\n            }\n        }\n    }\n\n    /**\n     * Initializer function for all request APIs\n     * @param request\n     */\n    protected async initializeBaseRequest(\n        request: Partial<BaseAuthRequest>,\n        account?: AccountInfo\n    ): Promise<BaseAuthRequest> {\n        this.performanceClient.addQueueMeasurement(\n            PerformanceEvents.InitializeBaseRequest,\n            request.correlationId\n        );\n        this.logger.verbose(\"Initializing BaseAuthRequest\");\n        const authority = request.authority || this.config.auth.authority;\n\n        if (account) {\n            await this.validateRequestAuthority(authority, account);\n        }\n\n        const scopes = [...((request && request.scopes) || [])];\n\n        const validatedRequest: BaseAuthRequest = {\n            ...request,\n            correlationId: this.correlationId,\n            authority,\n            scopes,\n        };\n\n        // Set authenticationScheme to BEARER if not explicitly set in the request\n        if (!validatedRequest.authenticationScheme) {\n            validatedRequest.authenticationScheme = AuthenticationScheme.BEARER;\n            this.logger.verbose(\n                'Authentication Scheme wasn\\'t explicitly set in request, defaulting to \"Bearer\" request'\n            );\n        } else {\n            if (\n                validatedRequest.authenticationScheme ===\n                AuthenticationScheme.SSH\n            ) {\n                if (!request.sshJwk) {\n                    throw ClientConfigurationError.createMissingSshJwkError();\n                }\n                if (!request.sshKid) {\n                    throw ClientConfigurationError.createMissingSshKidError();\n                }\n            }\n            this.logger.verbose(\n                `Authentication Scheme set to \"${validatedRequest.authenticationScheme}\" as configured in Auth request`\n            );\n        }\n\n        // Set requested claims hash if claims-based caching is enabled and claims were requested\n        if (\n            this.config.cache.claimsBasedCachingEnabled &&\n            request.claims &&\n            // Checks for empty stringified object \"{}\" which doesn't qualify as requested claims\n            !StringUtils.isEmptyObj(request.claims)\n        ) {\n            validatedRequest.requestedClaimsHash =\n                await this.browserCrypto.hashString(request.claims);\n        }\n\n        return validatedRequest;\n    }\n\n    /**\n     *\n     * Use to get the redirect uri configured in MSAL or null.\n     * @param requestRedirectUri\n     * @returns Redirect URL\n     *\n     */\n    getRedirectUri(requestRedirectUri?: string): string {\n        this.logger.verbose(\"getRedirectUri called\");\n        const redirectUri =\n            requestRedirectUri ||\n            this.config.auth.redirectUri ||\n            BrowserUtils.getCurrentUri();\n        return UrlString.getAbsoluteUrl(\n            redirectUri,\n            BrowserUtils.getCurrentUri()\n        );\n    }\n\n    /*\n     * If authority provided in the request does not match environment/authority specified\n     * in the account or MSAL config, we throw an error.\n     */\n    async validateRequestAuthority(\n        authority: string,\n        account: AccountInfo\n    ): Promise<void> {\n        const discoveredAuthority = await this.getDiscoveredAuthority(\n            authority\n        );\n\n        if (!discoveredAuthority.isAlias(account.environment)) {\n            throw ClientConfigurationError.createAuthorityMismatchError();\n        }\n    }\n\n    /**\n     *\n     * @param apiId\n     * @param correlationId\n     * @param forceRefresh\n     */\n    protected initializeServerTelemetryManager(\n        apiId: number,\n        forceRefresh?: boolean\n    ): ServerTelemetryManager {\n        this.logger.verbose(\"initializeServerTelemetryManager called\");\n        const telemetryPayload: ServerTelemetryRequest = {\n            clientId: this.config.auth.clientId,\n            correlationId: this.correlationId,\n            apiId: apiId,\n            forceRefresh: forceRefresh || false,\n            wrapperSKU: this.browserStorage.getWrapperMetadata()[0],\n            wrapperVer: this.browserStorage.getWrapperMetadata()[1],\n        };\n\n        return new ServerTelemetryManager(\n            telemetryPayload,\n            this.browserStorage\n        );\n    }\n\n    /**\n     * Used to get a discovered version of the default authority.\n     * @param requestAuthority\n     * @param requestCorrelationId\n     */\n    protected async getDiscoveredAuthority(\n        requestAuthority?: string\n    ): Promise<Authority> {\n        this.logger.verbose(\"getDiscoveredAuthority called\");\n        const authorityOptions: AuthorityOptions = {\n            protocolMode: this.config.auth.protocolMode,\n            OIDCOptions: this.config.auth.OIDCOptions,\n            knownAuthorities: this.config.auth.knownAuthorities,\n            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n            authorityMetadata: this.config.auth.authorityMetadata,\n        };\n\n        if (requestAuthority) {\n            this.logger.verbose(\n                \"Creating discovered authority with request authority\"\n            );\n            return await AuthorityFactory.createDiscoveredInstance(\n                requestAuthority,\n                this.config.system.networkClient,\n                this.browserStorage,\n                authorityOptions,\n                this.logger\n            );\n        }\n\n        this.logger.verbose(\n            \"Creating discovered authority with configured authority\"\n        );\n        return await AuthorityFactory.createDiscoveredInstance(\n            this.config.auth.authority,\n            this.config.system.networkClient,\n            this.browserStorage,\n            authorityOptions,\n            this.logger\n        );\n    }\n}\n"],"mappings":";;;;;;;;AAKA;AAmBA;AACA;AACA;AAQO,MAAEA,qBAAyB;EAClCC,WAASA,CAAAC,MAAA,EAAAC,WAAsB,EAAMC,aAAA,EAAAC,MAAA,EAAAC,YAAA,EAAAC,gBAA8C,EAAAC,iBAAA,EAAAC,oBAAA,EAAAC,aAAA;IAC1E,KAAAR,MAAA,GAAAA,MAAA;IACA,KAAAS,cAAmB,GAAAR,WAAA;IAE5B,KAAAC,aAAA,GAAAA,aAA2C;IACvC,KAASQ,aAAS,QAAAV,MAAA,CAAAW,MAAqB,CAAAD,aAAA;IACvC,KAASN,YAAC,GAAcA,YAAE;IAC1B,KAASC,gBAAgB,GAAAA,gBAAQ;IACjC,KAASE,oBAAgB,GAAAA,oBAAe;IACxC,KAASC,aAAS,GAClBA,aAAU,IAAc,KAAAN,aAAa,CAAAU,aAAA;IACrC,KAAST,MAAC,GAAAA,MAAA,CAAAU,KAAkB,CAAAC,gBAAkB,CAAAC,QAAA,EAAAC,OAAA,OAAAR,aAAA;IAC9C,KAASF,iBAAqB,GAAAA,iBAAsB;EACpD;EACA,MAAAW,kBAAUA,CAAAC,OAAmB;IAGzB,IAAAA,OAAA;MA2BI,IAAaC,aACV,CAAAC,kBAAA,CAAAF,OAAoB,OAAAT,cAAe,CAAAY,gBACpC,EAAqB;QAEtB,IACL,CAAAlB,MAAO,CAAAmB,OAAmB,iCAAoB,CAAG;QAGnB,KAAAb,cACvB,CAAAc,gBAAG,KAAc;MA4C5B;;;QAGG,WAAAd,cAAA,CAAAe,aAAA,CAAAL,aAAA,CAAAM,uBAAA,CAAAP,OAAA;QACa,KAAAf,MAAA,CAAAmB,OAAqB,CACjC;MA4DJ,E;;;;MAMG;QACH,IAAiC,CAAAnB,MAAA,CAAAmB,OAAA,mEAAkB,OAAAd,aAAA;QAgB7C;QAaN,WAAAC,cAAA,CAAAiB,KAAA;;;;QAKG,KAAAvB,MAAA,CAAAwB,KAAA;MACH;IAoBA;;;;AAIG;;EAqCN,MAAAC,sBAAAC,OAAA,EAAAX,OAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}