{"ast":null,"code":"/*! @azure/msal-common v14.4.0 2023-11-07 */\n'use strict';\n\nimport { AuthorityType } from './AuthorityType.mjs';\nimport { isOpenIdConfigResponse } from './OpenIdConfigResponse.mjs';\nimport { UrlString } from '../url/UrlString.mjs';\nimport { createClientAuthError } from '../error/ClientAuthError.mjs';\nimport { Constants, AuthorityMetadataSource, RegionDiscoveryOutcomes, AADAuthorityConstants } from '../utils/Constants.mjs';\nimport { EndpointMetadata, getCloudDiscoveryMetadataFromHardcodedValues, getCloudDiscoveryMetadataFromNetworkResponse, InstanceDiscoveryMetadataAliases } from './AuthorityMetadata.mjs';\nimport { createClientConfigurationError } from '../error/ClientConfigurationError.mjs';\nimport { ProtocolMode } from './ProtocolMode.mjs';\nimport { AuthorityMetadataEntity } from '../cache/entities/AuthorityMetadataEntity.mjs';\nimport { AzureCloudInstance } from './AuthorityOptions.mjs';\nimport { isCloudInstanceDiscoveryResponse } from './CloudInstanceDiscoveryResponse.mjs';\nimport { isCloudInstanceDiscoveryErrorResponse } from './CloudInstanceDiscoveryErrorResponse.mjs';\nimport { RegionDiscovery } from './RegionDiscovery.mjs';\nimport { AuthError } from '../error/AuthError.mjs';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.mjs';\nimport { invokeAsync } from '../utils/FunctionWrappers.mjs';\nimport { endpointResolutionError, endSessionEndpointNotSupported, openIdConfigError } from '../error/ClientAuthErrorCodes.mjs';\nimport { invalidAuthorityMetadata, untrustedAuthority, invalidCloudDiscoveryMetadata } from '../error/ClientConfigurationErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the\n * endpoint. It will store the pertinent config data in this object for use during token calls.\n * @internal\n */\nclass Authority {\n  constructor(authority, networkInterface, cacheManager, authorityOptions, logger, performanceClient, correlationId) {\n    this.canonicalAuthority = authority;\n    this._canonicalAuthority.validateAsUri();\n    this.networkInterface = networkInterface;\n    this.cacheManager = cacheManager;\n    this.authorityOptions = authorityOptions;\n    this.regionDiscoveryMetadata = {\n      region_used: undefined,\n      region_source: undefined,\n      region_outcome: undefined\n    };\n    this.logger = logger;\n    this.performanceClient = performanceClient;\n    this.correlationId = correlationId;\n    this.regionDiscovery = new RegionDiscovery(networkInterface, this.logger, this.performanceClient, this.correlationId);\n  }\n  /**\n   * Get {@link AuthorityType}\n   * @param authorityUri {@link IUri}\n   * @private\n   */\n  getAuthorityType(authorityUri) {\n    // CIAM auth url pattern is being standardized as: <tenant>.ciamlogin.com\n    if (authorityUri.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {\n      return AuthorityType.Ciam;\n    }\n    const pathSegments = authorityUri.PathSegments;\n    if (pathSegments.length) {\n      switch (pathSegments[0].toLowerCase()) {\n        case Constants.ADFS:\n          return AuthorityType.Adfs;\n        case Constants.DSTS:\n          return AuthorityType.Dsts;\n      }\n    }\n    return AuthorityType.Default;\n  }\n  // See above for AuthorityType\n  get authorityType() {\n    return this.getAuthorityType(this.canonicalAuthorityUrlComponents);\n  }\n  /**\n   * ProtocolMode enum representing the way endpoints are constructed.\n   */\n  get protocolMode() {\n    return this.authorityOptions.protocolMode;\n  }\n  /**\n   * Returns authorityOptions which can be used to reinstantiate a new authority instance\n   */\n  get options() {\n    return this.authorityOptions;\n  }\n  /**\n   * A URL that is the authority set by the developer\n   */\n  get canonicalAuthority() {\n    return this._canonicalAuthority.urlString;\n  }\n  /**\n   * Sets canonical authority.\n   */\n  set canonicalAuthority(url) {\n    this._canonicalAuthority = new UrlString(url);\n    this._canonicalAuthority.validateAsUri();\n    this._canonicalAuthorityUrlComponents = null;\n  }\n  /**\n   * Get authority components.\n   */\n  get canonicalAuthorityUrlComponents() {\n    if (!this._canonicalAuthorityUrlComponents) {\n      this._canonicalAuthorityUrlComponents = this._canonicalAuthority.getUrlComponents();\n    }\n    return this._canonicalAuthorityUrlComponents;\n  }\n  /**\n   * Get hostname and port i.e. login.microsoftonline.com\n   */\n  get hostnameAndPort() {\n    return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();\n  }\n  /**\n   * Get tenant for authority.\n   */\n  get tenant() {\n    return this.canonicalAuthorityUrlComponents.PathSegments[0];\n  }\n  /**\n   * OAuth /authorize endpoint for requests\n   */\n  get authorizationEndpoint() {\n    if (this.discoveryComplete()) {\n      return this.replacePath(this.metadata.authorization_endpoint);\n    } else {\n      throw createClientAuthError(endpointResolutionError);\n    }\n  }\n  /**\n   * OAuth /token endpoint for requests\n   */\n  get tokenEndpoint() {\n    if (this.discoveryComplete()) {\n      return this.replacePath(this.metadata.token_endpoint);\n    } else {\n      throw createClientAuthError(endpointResolutionError);\n    }\n  }\n  get deviceCodeEndpoint() {\n    if (this.discoveryComplete()) {\n      return this.replacePath(this.metadata.token_endpoint.replace(\"/token\", \"/devicecode\"));\n    } else {\n      throw createClientAuthError(endpointResolutionError);\n    }\n  }\n  /**\n   * OAuth logout endpoint for requests\n   */\n  get endSessionEndpoint() {\n    if (this.discoveryComplete()) {\n      // ROPC policies may not have end_session_endpoint set\n      if (!this.metadata.end_session_endpoint) {\n        throw createClientAuthError(endSessionEndpointNotSupported);\n      }\n      return this.replacePath(this.metadata.end_session_endpoint);\n    } else {\n      throw createClientAuthError(endpointResolutionError);\n    }\n  }\n  /**\n   * OAuth issuer for requests\n   */\n  get selfSignedJwtAudience() {\n    if (this.discoveryComplete()) {\n      return this.replacePath(this.metadata.issuer);\n    } else {\n      throw createClientAuthError(endpointResolutionError);\n    }\n  }\n  /**\n   * Jwks_uri for token signing keys\n   */\n  get jwksUri() {\n    if (this.discoveryComplete()) {\n      return this.replacePath(this.metadata.jwks_uri);\n    } else {\n      throw createClientAuthError(endpointResolutionError);\n    }\n  }\n  /**\n   * Returns a flag indicating that tenant name can be replaced in authority {@link IUri}\n   * @param authorityUri {@link IUri}\n   * @private\n   */\n  canReplaceTenant(authorityUri) {\n    return authorityUri.PathSegments.length === 1 && !Authority.reservedTenantDomains.has(authorityUri.PathSegments[0]) && this.getAuthorityType(authorityUri) === AuthorityType.Default && this.protocolMode === ProtocolMode.AAD;\n  }\n  /**\n   * Replaces tenant in url path with current tenant. Defaults to common.\n   * @param urlString\n   */\n  replaceTenant(urlString) {\n    return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);\n  }\n  /**\n   * Replaces path such as tenant or policy with the current tenant or policy.\n   * @param urlString\n   */\n  replacePath(urlString) {\n    let endpoint = urlString;\n    const cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);\n    const cachedAuthorityUrlComponents = cachedAuthorityUrl.getUrlComponents();\n    const cachedAuthorityParts = cachedAuthorityUrlComponents.PathSegments;\n    const currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;\n    currentAuthorityParts.forEach((currentPart, index) => {\n      let cachedPart = cachedAuthorityParts[index];\n      if (index === 0 && this.canReplaceTenant(cachedAuthorityUrlComponents)) {\n        const tenantId = new UrlString(this.metadata.authorization_endpoint).getUrlComponents().PathSegments[0];\n        /**\n         * Check if AAD canonical authority contains tenant domain name, for example \"testdomain.onmicrosoft.com\",\n         * by comparing its first path segment to the corresponding authorization endpoint path segment, which is\n         * always resolved with tenant id by OIDC.\n         */\n        if (cachedPart !== tenantId) {\n          this.logger.verbose(`Replacing tenant domain name ${cachedPart} with id ${tenantId}`);\n          cachedPart = tenantId;\n        }\n      }\n      if (currentPart !== cachedPart) {\n        endpoint = endpoint.replace(`/${cachedPart}/`, `/${currentPart}/`);\n      }\n    });\n    return this.replaceTenant(endpoint);\n  }\n  /**\n   * The default open id configuration endpoint for any canonical authority.\n   */\n  get defaultOpenIdConfigurationEndpoint() {\n    const canonicalAuthorityHost = this.hostnameAndPort;\n    if (this.canonicalAuthority.endsWith(\"v2.0/\") || this.authorityType === AuthorityType.Adfs || this.protocolMode !== ProtocolMode.AAD && !this.isAliasOfKnownMicrosoftAuthority(canonicalAuthorityHost)) {\n      return `${this.canonicalAuthority}.well-known/openid-configuration`;\n    }\n    return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;\n  }\n  /**\n   * Boolean that returns whethr or not tenant discovery has been completed.\n   */\n  discoveryComplete() {\n    return !!this.metadata;\n  }\n  /**\n   * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network\n   * and the /authorize, /token and logout endpoints.\n   */\n  async resolveEndpointsAsync() {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityResolveEndpointsAsync, this.correlationId);\n    const metadataEntity = this.getCurrentMetadataEntity();\n    const cloudDiscoverySource = await invokeAsync(this.updateCloudDiscoveryMetadata.bind(this), PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);\n    this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);\n    const endpointSource = await invokeAsync(this.updateEndpointMetadata.bind(this), PerformanceEvents.AuthorityUpdateEndpointMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);\n    this.updateCachedMetadata(metadataEntity, cloudDiscoverySource, {\n      source: endpointSource\n    });\n  }\n  /**\n   * Returns metadata entity from cache if it exists, otherwiser returns a new metadata entity built\n   * from the configured canonical authority\n   * @returns\n   */\n  getCurrentMetadataEntity() {\n    let metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);\n    if (!metadataEntity) {\n      metadataEntity = new AuthorityMetadataEntity();\n      metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n    }\n    return metadataEntity;\n  }\n  /**\n   * Updates cached metadata based on metadata source and sets the instance's metadata\n   * property to the same value\n   * @param metadataEntity\n   * @param cloudDiscoverySource\n   * @param endpointMetadataResult\n   */\n  updateCachedMetadata(metadataEntity, cloudDiscoverySource, endpointMetadataResult) {\n    if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE && endpointMetadataResult?.source !== AuthorityMetadataSource.CACHE) {\n      // Reset the expiration time unless both values came from a successful cache lookup\n      metadataEntity.resetExpiresAt();\n      metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n    }\n    const cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);\n    this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);\n    this.metadata = metadataEntity;\n  }\n  /**\n   * Update AuthorityMetadataEntity with new endpoints and return where the information came from\n   * @param metadataEntity\n   */\n  async updateEndpointMetadata(metadataEntity) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateEndpointMetadata, this.correlationId);\n    const localMetadata = this.updateEndpointMetadataFromLocalSources(metadataEntity);\n    // Further update may be required for hardcoded metadata if regional metadata is preferred\n    if (localMetadata) {\n      if (localMetadata.source === AuthorityMetadataSource.HARDCODED_VALUES) {\n        // If the user prefers to use an azure region replace the global endpoints with regional information.\n        if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {\n          if (localMetadata.metadata) {\n            const hardcodedMetadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(localMetadata.metadata);\n            metadataEntity.updateEndpointMetadata(hardcodedMetadata, false);\n          }\n        }\n      }\n      return localMetadata.source;\n    }\n    // Get metadata from network if local sources aren't available\n    let metadata = await invokeAsync(this.getEndpointMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();\n    if (metadata) {\n      // If the user prefers to use an azure region replace the global endpoints with regional information.\n      if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {\n        metadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(metadata);\n      }\n      metadataEntity.updateEndpointMetadata(metadata, true);\n      return AuthorityMetadataSource.NETWORK;\n    } else {\n      // Metadata could not be obtained from the config, cache, network or hardcoded values\n      throw createClientAuthError(openIdConfigError, this.defaultOpenIdConfigurationEndpoint);\n    }\n  }\n  /**\n   * Updates endpoint metadata from local sources and returns where the information was retrieved from and the metadata config\n   * response if the source is hardcoded metadata\n   * @param metadataEntity\n   * @returns\n   */\n  updateEndpointMetadataFromLocalSources(metadataEntity) {\n    this.logger.verbose(\"Attempting to get endpoint metadata from authority configuration\");\n    const configMetadata = this.getEndpointMetadataFromConfig();\n    if (configMetadata) {\n      this.logger.verbose(\"Found endpoint metadata in authority configuration\");\n      metadataEntity.updateEndpointMetadata(configMetadata, false);\n      return {\n        source: AuthorityMetadataSource.CONFIG\n      };\n    }\n    this.logger.verbose(\"Did not find endpoint metadata in the config... Attempting to get endpoint metadata from the hardcoded values.\");\n    // skipAuthorityMetadataCache is used to bypass hardcoded authority metadata and force a network metadata cache lookup and network metadata request if no cached response is available.\n    if (this.authorityOptions.skipAuthorityMetadataCache) {\n      this.logger.verbose(\"Skipping hardcoded metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get endpoint metadata from the network metadata cache.\");\n    } else {\n      const hardcodedMetadata = this.getEndpointMetadataFromHardcodedValues();\n      if (hardcodedMetadata) {\n        metadataEntity.updateEndpointMetadata(hardcodedMetadata, false);\n        return {\n          source: AuthorityMetadataSource.HARDCODED_VALUES,\n          metadata: hardcodedMetadata\n        };\n      } else {\n        this.logger.verbose(\"Did not find endpoint metadata in hardcoded values... Attempting to get endpoint metadata from the network metadata cache.\");\n      }\n    }\n    // Check cached metadata entity expiration status\n    const metadataEntityExpired = metadataEntity.isExpired();\n    if (this.isAuthoritySameType(metadataEntity) && metadataEntity.endpointsFromNetwork && !metadataEntityExpired) {\n      // No need to update\n      this.logger.verbose(\"Found endpoint metadata in the cache.\");\n      return {\n        source: AuthorityMetadataSource.CACHE\n      };\n    } else if (metadataEntityExpired) {\n      this.logger.verbose(\"The metadata entity is expired.\");\n    }\n    return null;\n  }\n  /**\n   * Compares the number of url components after the domain to determine if the cached\n   * authority metadata can be used for the requested authority. Protects against same domain different\n   * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy\n   * @param metadataEntity\n   */\n  isAuthoritySameType(metadataEntity) {\n    const cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);\n    const cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n    return cachedParts.length === this.canonicalAuthorityUrlComponents.PathSegments.length;\n  }\n  /**\n   * Parse authorityMetadata config option\n   */\n  getEndpointMetadataFromConfig() {\n    if (this.authorityOptions.authorityMetadata) {\n      try {\n        return JSON.parse(this.authorityOptions.authorityMetadata);\n      } catch (e) {\n        throw createClientConfigurationError(invalidAuthorityMetadata);\n      }\n    }\n    return null;\n  }\n  /**\n   * Gets OAuth endpoints from the given OpenID configuration endpoint.\n   *\n   * @param hasHardcodedMetadata boolean\n   */\n  async getEndpointMetadataFromNetwork() {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.correlationId);\n    const options = {};\n    /*\n     * TODO: Add a timeout if the authority exists in our library's\n     * hardcoded list of metadata\n     */\n    const openIdConfigurationEndpoint = this.defaultOpenIdConfigurationEndpoint;\n    this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: attempting to retrieve OAuth endpoints from ${openIdConfigurationEndpoint}`);\n    try {\n      const response = await this.networkInterface.sendGetRequestAsync(openIdConfigurationEndpoint, options);\n      const isValidResponse = isOpenIdConfigResponse(response.body);\n      if (isValidResponse) {\n        return response.body;\n      } else {\n        this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: could not parse response as OpenID configuration`);\n        return null;\n      }\n    } catch (e) {\n      this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: ${e}`);\n      return null;\n    }\n  }\n  /**\n   * Get OAuth endpoints for common authorities.\n   */\n  getEndpointMetadataFromHardcodedValues() {\n    if (this.canonicalAuthority in EndpointMetadata) {\n      return EndpointMetadata[this.canonicalAuthority];\n    }\n    return null;\n  }\n  /**\n   * Update the retrieved metadata with regional information.\n   * User selected Azure region will be used if configured.\n   */\n  async updateMetadataWithRegionalInformation(metadata) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId);\n    const userConfiguredAzureRegion = this.authorityOptions.azureRegionConfiguration?.azureRegion;\n    if (userConfiguredAzureRegion) {\n      if (userConfiguredAzureRegion !== Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {\n        this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;\n        this.regionDiscoveryMetadata.region_used = userConfiguredAzureRegion;\n        return Authority.replaceWithRegionalInformation(metadata, userConfiguredAzureRegion);\n      }\n      const autodetectedRegionName = await invokeAsync(this.regionDiscovery.detectRegion.bind(this.regionDiscovery), PerformanceEvents.RegionDiscoveryDetectRegion, this.logger, this.performanceClient, this.correlationId)(this.authorityOptions.azureRegionConfiguration?.environmentRegion, this.regionDiscoveryMetadata);\n      if (autodetectedRegionName) {\n        this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL;\n        this.regionDiscoveryMetadata.region_used = autodetectedRegionName;\n        return Authority.replaceWithRegionalInformation(metadata, autodetectedRegionName);\n      }\n      this.regionDiscoveryMetadata.region_outcome = RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;\n    }\n    return metadata;\n  }\n  /**\n   * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache\n   * and returns where the information was retrieved from\n   * @param metadataEntity\n   * @returns AuthorityMetadataSource\n   */\n  async updateCloudDiscoveryMetadata(metadataEntity) {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId);\n    const localMetadataSource = this.updateCloudDiscoveryMetadataFromLocalSources(metadataEntity);\n    if (localMetadataSource) {\n      return localMetadataSource;\n    }\n    // Fallback to network as metadata source\n    const metadata = await invokeAsync(this.getCloudDiscoveryMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();\n    if (metadata) {\n      metadataEntity.updateCloudDiscoveryMetadata(metadata, true);\n      return AuthorityMetadataSource.NETWORK;\n    }\n    // Metadata could not be obtained from the config, cache, network or hardcoded values\n    throw createClientConfigurationError(untrustedAuthority);\n  }\n  updateCloudDiscoveryMetadataFromLocalSources(metadataEntity) {\n    this.logger.verbose(\"Attempting to get cloud discovery metadata  from authority configuration\");\n    this.logger.verbosePii(`Known Authorities: ${this.authorityOptions.knownAuthorities || Constants.NOT_APPLICABLE}`);\n    this.logger.verbosePii(`Authority Metadata: ${this.authorityOptions.authorityMetadata || Constants.NOT_APPLICABLE}`);\n    this.logger.verbosePii(`Canonical Authority: ${metadataEntity.canonical_authority || Constants.NOT_APPLICABLE}`);\n    const metadata = this.getCloudDiscoveryMetadataFromConfig();\n    if (metadata) {\n      this.logger.verbose(\"Found cloud discovery metadata in authority configuration\");\n      metadataEntity.updateCloudDiscoveryMetadata(metadata, false);\n      return AuthorityMetadataSource.CONFIG;\n    }\n    // If the cached metadata came from config but that config was not passed to this instance, we must go to hardcoded values\n    this.logger.verbose(\"Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the hardcoded values.\");\n    if (this.options.skipAuthorityMetadataCache) {\n      this.logger.verbose(\"Skipping hardcoded cloud discovery metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get cloud discovery metadata from the network metadata cache.\");\n    } else {\n      const hardcodedMetadata = getCloudDiscoveryMetadataFromHardcodedValues(this.hostnameAndPort);\n      if (hardcodedMetadata) {\n        this.logger.verbose(\"Found cloud discovery metadata from hardcoded values.\");\n        metadataEntity.updateCloudDiscoveryMetadata(hardcodedMetadata, false);\n        return AuthorityMetadataSource.HARDCODED_VALUES;\n      }\n      this.logger.verbose(\"Did not find cloud discovery metadata in hardcoded values... Attempting to get cloud discovery metadata from the network metadata cache.\");\n    }\n    const metadataEntityExpired = metadataEntity.isExpired();\n    if (this.isAuthoritySameType(metadataEntity) && metadataEntity.aliasesFromNetwork && !metadataEntityExpired) {\n      this.logger.verbose(\"Found cloud discovery metadata in the cache.\");\n      // No need to update\n      return AuthorityMetadataSource.CACHE;\n    } else if (metadataEntityExpired) {\n      this.logger.verbose(\"The metadata entity is expired.\");\n    }\n    return null;\n  }\n  /**\n   * Parse cloudDiscoveryMetadata config or check knownAuthorities\n   */\n  getCloudDiscoveryMetadataFromConfig() {\n    // CIAM does not support cloud discovery metadata\n    if (this.authorityType === AuthorityType.Ciam) {\n      this.logger.verbose(\"CIAM authorities do not support cloud discovery metadata, generate the aliases from authority host.\");\n      return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\n    }\n    // Check if network response was provided in config\n    if (this.authorityOptions.cloudDiscoveryMetadata) {\n      this.logger.verbose(\"The cloud discovery metadata has been provided as a network response, in the config.\");\n      try {\n        this.logger.verbose(\"Attempting to parse the cloud discovery metadata.\");\n        const parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);\n        const metadata = getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);\n        this.logger.verbose(\"Parsed the cloud discovery metadata.\");\n        if (metadata) {\n          this.logger.verbose(\"There is returnable metadata attached to the parsed cloud discovery metadata.\");\n          return metadata;\n        } else {\n          this.logger.verbose(\"There is no metadata attached to the parsed cloud discovery metadata.\");\n        }\n      } catch (e) {\n        this.logger.verbose(\"Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error.\");\n        throw createClientConfigurationError(invalidCloudDiscoveryMetadata);\n      }\n    }\n    // If cloudDiscoveryMetadata is empty or does not contain the host, check knownAuthorities\n    if (this.isInKnownAuthorities()) {\n      this.logger.verbose(\"The host is included in knownAuthorities. Creating new cloud discovery metadata from the host.\");\n      return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\n    }\n    return null;\n  }\n  /**\n   * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config\n   *\n   * @param hasHardcodedMetadata boolean\n   */\n  async getCloudDiscoveryMetadataFromNetwork() {\n    this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId);\n    const instanceDiscoveryEndpoint = `${Constants.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;\n    const options = {};\n    /*\n     * TODO: Add a timeout if the authority exists in our library's\n     * hardcoded list of metadata\n     */\n    let match = null;\n    try {\n      const response = await this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options);\n      let typedResponseBody;\n      let metadata;\n      if (isCloudInstanceDiscoveryResponse(response.body)) {\n        typedResponseBody = response.body;\n        metadata = typedResponseBody.metadata;\n        this.logger.verbosePii(`tenant_discovery_endpoint is: ${typedResponseBody.tenant_discovery_endpoint}`);\n      } else if (isCloudInstanceDiscoveryErrorResponse(response.body)) {\n        this.logger.warning(`A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: ${response.status}`);\n        typedResponseBody = response.body;\n        if (typedResponseBody.error === Constants.INVALID_INSTANCE) {\n          this.logger.error(\"The CloudInstanceDiscoveryErrorResponse error is invalid_instance.\");\n          return null;\n        }\n        this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error is ${typedResponseBody.error}`);\n        this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error description is ${typedResponseBody.error_description}`);\n        this.logger.warning(\"Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []\");\n        metadata = [];\n      } else {\n        this.logger.error(\"AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse\");\n        return null;\n      }\n      this.logger.verbose(\"Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request.\");\n      match = getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);\n    } catch (error) {\n      if (error instanceof AuthError) {\n        this.logger.error(`There was a network error while attempting to get the cloud discovery instance metadata.\\nError: ${error.errorCode}\\nError Description: ${error.errorMessage}`);\n      } else {\n        const typedError = error;\n        this.logger.error(`A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.\\nError: ${typedError.name}\\nError Description: ${typedError.message}`);\n      }\n      return null;\n    }\n    // Custom Domain scenario, host is trusted because Instance Discovery call succeeded\n    if (!match) {\n      this.logger.warning(\"The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request.\");\n      this.logger.verbose(\"Creating custom Authority for custom domain scenario.\");\n      match = Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);\n    }\n    return match;\n  }\n  /**\n   * Helper function to determine if this host is included in the knownAuthorities config option\n   */\n  isInKnownAuthorities() {\n    const matches = this.authorityOptions.knownAuthorities.filter(authority => {\n      return UrlString.getDomainFromUrl(authority).toLowerCase() === this.hostnameAndPort;\n    });\n    return matches.length > 0;\n  }\n  /**\n   * helper function to populate the authority based on azureCloudOptions\n   * @param authorityString\n   * @param azureCloudOptions\n   */\n  static generateAuthority(authorityString, azureCloudOptions) {\n    let authorityAzureCloudInstance;\n    if (azureCloudOptions && azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {\n      const tenant = azureCloudOptions.tenant ? azureCloudOptions.tenant : Constants.DEFAULT_COMMON_TENANT;\n      authorityAzureCloudInstance = `${azureCloudOptions.azureCloudInstance}/${tenant}/`;\n    }\n    return authorityAzureCloudInstance ? authorityAzureCloudInstance : authorityString;\n  }\n  /**\n   * Creates cloud discovery metadata object from a given host\n   * @param host\n   */\n  static createCloudDiscoveryMetadataFromHost(host) {\n    return {\n      preferred_network: host,\n      preferred_cache: host,\n      aliases: [host]\n    };\n  }\n  /**\n   * helper function to generate environment from authority object\n   */\n  getPreferredCache() {\n    if (this.discoveryComplete()) {\n      return this.metadata.preferred_cache;\n    } else {\n      throw createClientAuthError(endpointResolutionError);\n    }\n  }\n  /**\n   * Returns whether or not the provided host is an alias of this authority instance\n   * @param host\n   */\n  isAlias(host) {\n    return this.metadata.aliases.indexOf(host) > -1;\n  }\n  /**\n   * Returns whether or not the provided host is an alias of a known Microsoft authority for purposes of endpoint discovery\n   * @param host\n   */\n  isAliasOfKnownMicrosoftAuthority(host) {\n    return InstanceDiscoveryMetadataAliases.has(host);\n  }\n  /**\n   * Checks whether the provided host is that of a public cloud authority\n   *\n   * @param authority string\n   * @returns bool\n   */\n  static isPublicCloudAuthority(host) {\n    return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;\n  }\n  /**\n   * Rebuild the authority string with the region\n   *\n   * @param host string\n   * @param region string\n   */\n  static buildRegionalAuthorityString(host, region, queryString) {\n    // Create and validate a Url string object with the initial authority string\n    const authorityUrlInstance = new UrlString(host);\n    authorityUrlInstance.validateAsUri();\n    const authorityUrlParts = authorityUrlInstance.getUrlComponents();\n    let hostNameAndPort = `${region}.${authorityUrlParts.HostNameAndPort}`;\n    if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {\n      hostNameAndPort = `${region}.${Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX}`;\n    }\n    // Include the query string portion of the url\n    const url = UrlString.constructAuthorityUriFromObject({\n      ...authorityUrlInstance.getUrlComponents(),\n      HostNameAndPort: hostNameAndPort\n    }).urlString;\n    // Add the query string if a query string was provided\n    if (queryString) return `${url}?${queryString}`;\n    return url;\n  }\n  /**\n   * Replace the endpoints in the metadata object with their regional equivalents.\n   *\n   * @param metadata OpenIdConfigResponse\n   * @param azureRegion string\n   */\n  static replaceWithRegionalInformation(metadata, azureRegion) {\n    const regionalMetadata = {\n      ...metadata\n    };\n    regionalMetadata.authorization_endpoint = Authority.buildRegionalAuthorityString(regionalMetadata.authorization_endpoint, azureRegion);\n    regionalMetadata.token_endpoint = Authority.buildRegionalAuthorityString(regionalMetadata.token_endpoint, azureRegion);\n    if (regionalMetadata.end_session_endpoint) {\n      regionalMetadata.end_session_endpoint = Authority.buildRegionalAuthorityString(regionalMetadata.end_session_endpoint, azureRegion);\n    }\n    return regionalMetadata;\n  }\n  /**\n   * Transform CIAM_AUTHORIY as per the below rules:\n   * If no path segments found and it is a CIAM authority (hostname ends with .ciamlogin.com), then transform it\n   *\n   * NOTE: The transformation path should go away once STS supports CIAM with the format: `tenantIdorDomain.ciamlogin.com`\n   * `ciamlogin.com` can also change in the future and we should accommodate the same\n   *\n   * @param authority\n   */\n  static transformCIAMAuthority(authority) {\n    let ciamAuthority = authority;\n    const authorityUrl = new UrlString(authority);\n    const authorityUrlComponents = authorityUrl.getUrlComponents();\n    // check if transformation is needed\n    if (authorityUrlComponents.PathSegments.length === 0 && authorityUrlComponents.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {\n      const tenantIdOrDomain = authorityUrlComponents.HostNameAndPort.split(\".\")[0];\n      ciamAuthority = `${ciamAuthority}${tenantIdOrDomain}${Constants.AAD_TENANT_DOMAIN_SUFFIX}`;\n    }\n    return ciamAuthority;\n  }\n}\n// Reserved tenant domain names that will not be replaced with tenant id\nAuthority.reservedTenantDomains = new Set([\"{tenant}\", \"{tenantid}\", AADAuthorityConstants.COMMON, AADAuthorityConstants.CONSUMERS, AADAuthorityConstants.ORGANIZATIONS]);\nfunction formatAuthorityUri(authorityUri) {\n  return authorityUri.endsWith(Constants.FORWARD_SLASH) ? authorityUri : `${authorityUri}${Constants.FORWARD_SLASH}`;\n}\nfunction buildStaticAuthorityOptions(authOptions) {\n  const rawCloudDiscoveryMetadata = authOptions.cloudDiscoveryMetadata;\n  let cloudDiscoveryMetadata = undefined;\n  if (rawCloudDiscoveryMetadata) {\n    try {\n      cloudDiscoveryMetadata = JSON.parse(rawCloudDiscoveryMetadata);\n    } catch (e) {\n      throw createClientConfigurationError(invalidCloudDiscoveryMetadata);\n    }\n  }\n  return {\n    canonicalAuthority: authOptions.authority ? formatAuthorityUri(authOptions.authority) : undefined,\n    knownAuthorities: authOptions.knownAuthorities,\n    cloudDiscoveryMetadata: cloudDiscoveryMetadata\n  };\n}\nexport { Authority, buildStaticAuthorityOptions, formatAuthorityUri };","map":{"version":3,"names":["Authority","constructor","authority","networkInterface","cacheManager","authorityOptions","logger","performanceClient","correlationId","canonicalAuthority","_canonicalAuthority","validateAsUri","region_outcome","undefined","regionDiscovery","RegionDiscovery","authorityUri","HostNameAndPort","endsWith","Constants","CIAM_AUTH_URL","AuthorityType","Ciam","pathSegments","PathSegments","length","toLowerCase","Adfs","DSTS","Dsts","authorityType","protocolMode","options","urlString","UrlString","url","_canonicalAuthorityUrlComponents","canonicalAuthorityUrlComponents","getUrlComponents","tenant","authorizationEndpoint","discoveryComplete","replacePath","metadata","authorization_endpoint","token_endpoint","replace","end_session_endpoint","createClientAuthError","endpointResolutionError","issuer","jwksUri","jwks_uri","canReplaceTenant","replaceTenant","cachedAuthorityUrl","canonical_authority","cachedAuthorityUrlComponents","cachedAuthorityParts","cachedPart","index","tenantId","currentPart","endpoint","defaultOpenIdConfigurationEndpoint"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-common\\src\\authority\\Authority.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AuthorityType } from \"./AuthorityType\";\nimport {\n    isOpenIdConfigResponse,\n    OpenIdConfigResponse,\n} from \"./OpenIdConfigResponse\";\nimport { UrlString } from \"../url/UrlString\";\nimport { IUri } from \"../url/IUri\";\nimport {\n    createClientAuthError,\n    ClientAuthErrorCodes,\n} from \"../error/ClientAuthError\";\nimport { INetworkModule } from \"../network/INetworkModule\";\nimport {\n    AADAuthorityConstants,\n    AuthorityMetadataSource,\n    Constants,\n    RegionDiscoveryOutcomes,\n} from \"../utils/Constants\";\nimport {\n    EndpointMetadata,\n    getCloudDiscoveryMetadataFromHardcodedValues,\n    getCloudDiscoveryMetadataFromNetworkResponse,\n    InstanceDiscoveryMetadataAliases,\n} from \"./AuthorityMetadata\";\nimport {\n    createClientConfigurationError,\n    ClientConfigurationErrorCodes,\n} from \"../error/ClientConfigurationError\";\nimport { ProtocolMode } from \"./ProtocolMode\";\nimport { ICacheManager } from \"../cache/interface/ICacheManager\";\nimport { AuthorityMetadataEntity } from \"../cache/entities/AuthorityMetadataEntity\";\nimport {\n    AuthorityOptions,\n    AzureCloudInstance,\n    StaticAuthorityOptions,\n} from \"./AuthorityOptions\";\nimport {\n    CloudInstanceDiscoveryResponse,\n    isCloudInstanceDiscoveryResponse,\n} from \"./CloudInstanceDiscoveryResponse\";\nimport {\n    CloudInstanceDiscoveryErrorResponse,\n    isCloudInstanceDiscoveryErrorResponse,\n} from \"./CloudInstanceDiscoveryErrorResponse\";\nimport { CloudDiscoveryMetadata } from \"./CloudDiscoveryMetadata\";\nimport { RegionDiscovery } from \"./RegionDiscovery\";\nimport { RegionDiscoveryMetadata } from \"./RegionDiscoveryMetadata\";\nimport { ImdsOptions } from \"./ImdsOptions\";\nimport { AzureCloudOptions } from \"../config/ClientConfiguration\";\nimport { Logger } from \"../logger/Logger\";\nimport { AuthError } from \"../error/AuthError\";\nimport { IPerformanceClient } from \"../telemetry/performance/IPerformanceClient\";\nimport { PerformanceEvents } from \"../telemetry/performance/PerformanceEvent\";\nimport { invokeAsync } from \"../utils/FunctionWrappers\";\n\n/**\n * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the\n * endpoint. It will store the pertinent config data in this object for use during token calls.\n * @internal\n */\nexport class Authority {\n    // Canonical authority url string\n    private _canonicalAuthority: UrlString;\n    // Canonicaly authority url components\n    private _canonicalAuthorityUrlComponents: IUri | null;\n    // Network interface to make requests with.\n    protected networkInterface: INetworkModule;\n    // Cache Manager to cache network responses\n    protected cacheManager: ICacheManager;\n    // Protocol mode to construct endpoints\n    private authorityOptions: AuthorityOptions;\n    // Authority metadata\n    private metadata: AuthorityMetadataEntity;\n    // Region discovery service\n    private regionDiscovery: RegionDiscovery;\n    // Region discovery metadata\n    public regionDiscoveryMetadata: RegionDiscoveryMetadata;\n    // Logger object\n    private logger: Logger;\n    // Performance client\n    protected performanceClient: IPerformanceClient | undefined;\n    // Correlation Id\n    protected correlationId: string | undefined;\n    // Reserved tenant domain names that will not be replaced with tenant id\n    private static reservedTenantDomains: Set<string> = new Set([\n        \"{tenant}\",\n        \"{tenantid}\",\n        AADAuthorityConstants.COMMON,\n        AADAuthorityConstants.CONSUMERS,\n        AADAuthorityConstants.ORGANIZATIONS,\n    ]);\n\n    constructor(\n        authority: string,\n        networkInterface: INetworkModule,\n        cacheManager: ICacheManager,\n        authorityOptions: AuthorityOptions,\n        logger: Logger,\n        performanceClient?: IPerformanceClient,\n        correlationId?: string\n    ) {\n        this.canonicalAuthority = authority;\n        this._canonicalAuthority.validateAsUri();\n        this.networkInterface = networkInterface;\n        this.cacheManager = cacheManager;\n        this.authorityOptions = authorityOptions;\n        this.regionDiscoveryMetadata = {\n            region_used: undefined,\n            region_source: undefined,\n            region_outcome: undefined,\n        };\n        this.logger = logger;\n        this.performanceClient = performanceClient;\n        this.correlationId = correlationId;\n        this.regionDiscovery = new RegionDiscovery(\n            networkInterface,\n            this.logger,\n            this.performanceClient,\n            this.correlationId\n        );\n    }\n\n    /**\n     * Get {@link AuthorityType}\n     * @param authorityUri {@link IUri}\n     * @private\n     */\n    private getAuthorityType(authorityUri: IUri): AuthorityType {\n        // CIAM auth url pattern is being standardized as: <tenant>.ciamlogin.com\n        if (authorityUri.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {\n            return AuthorityType.Ciam;\n        }\n\n        const pathSegments = authorityUri.PathSegments;\n        if (pathSegments.length) {\n            switch (pathSegments[0].toLowerCase()) {\n                case Constants.ADFS:\n                    return AuthorityType.Adfs;\n                case Constants.DSTS:\n                    return AuthorityType.Dsts;\n                default:\n                    break;\n            }\n        }\n        return AuthorityType.Default;\n    }\n\n    // See above for AuthorityType\n    public get authorityType(): AuthorityType {\n        return this.getAuthorityType(this.canonicalAuthorityUrlComponents);\n    }\n\n    /**\n     * ProtocolMode enum representing the way endpoints are constructed.\n     */\n    public get protocolMode(): ProtocolMode {\n        return this.authorityOptions.protocolMode;\n    }\n\n    /**\n     * Returns authorityOptions which can be used to reinstantiate a new authority instance\n     */\n    public get options(): AuthorityOptions {\n        return this.authorityOptions;\n    }\n\n    /**\n     * A URL that is the authority set by the developer\n     */\n    public get canonicalAuthority(): string {\n        return this._canonicalAuthority.urlString;\n    }\n\n    /**\n     * Sets canonical authority.\n     */\n    public set canonicalAuthority(url: string) {\n        this._canonicalAuthority = new UrlString(url);\n        this._canonicalAuthority.validateAsUri();\n        this._canonicalAuthorityUrlComponents = null;\n    }\n\n    /**\n     * Get authority components.\n     */\n    public get canonicalAuthorityUrlComponents(): IUri {\n        if (!this._canonicalAuthorityUrlComponents) {\n            this._canonicalAuthorityUrlComponents =\n                this._canonicalAuthority.getUrlComponents();\n        }\n\n        return this._canonicalAuthorityUrlComponents;\n    }\n\n    /**\n     * Get hostname and port i.e. login.microsoftonline.com\n     */\n    public get hostnameAndPort(): string {\n        return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();\n    }\n\n    /**\n     * Get tenant for authority.\n     */\n    public get tenant(): string {\n        return this.canonicalAuthorityUrlComponents.PathSegments[0];\n    }\n\n    /**\n     * OAuth /authorize endpoint for requests\n     */\n    public get authorizationEndpoint(): string {\n        if (this.discoveryComplete()) {\n            return this.replacePath(this.metadata.authorization_endpoint);\n        } else {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.endpointResolutionError\n            );\n        }\n    }\n\n    /**\n     * OAuth /token endpoint for requests\n     */\n    public get tokenEndpoint(): string {\n        if (this.discoveryComplete()) {\n            return this.replacePath(this.metadata.token_endpoint);\n        } else {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.endpointResolutionError\n            );\n        }\n    }\n\n    public get deviceCodeEndpoint(): string {\n        if (this.discoveryComplete()) {\n            return this.replacePath(\n                this.metadata.token_endpoint.replace(\"/token\", \"/devicecode\")\n            );\n        } else {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.endpointResolutionError\n            );\n        }\n    }\n\n    /**\n     * OAuth logout endpoint for requests\n     */\n    public get endSessionEndpoint(): string {\n        if (this.discoveryComplete()) {\n            // ROPC policies may not have end_session_endpoint set\n            if (!this.metadata.end_session_endpoint) {\n                throw createClientAuthError(\n                    ClientAuthErrorCodes.endSessionEndpointNotSupported\n                );\n            }\n            return this.replacePath(this.metadata.end_session_endpoint);\n        } else {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.endpointResolutionError\n            );\n        }\n    }\n\n    /**\n     * OAuth issuer for requests\n     */\n    public get selfSignedJwtAudience(): string {\n        if (this.discoveryComplete()) {\n            return this.replacePath(this.metadata.issuer);\n        } else {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.endpointResolutionError\n            );\n        }\n    }\n\n    /**\n     * Jwks_uri for token signing keys\n     */\n    public get jwksUri(): string {\n        if (this.discoveryComplete()) {\n            return this.replacePath(this.metadata.jwks_uri);\n        } else {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.endpointResolutionError\n            );\n        }\n    }\n\n    /**\n     * Returns a flag indicating that tenant name can be replaced in authority {@link IUri}\n     * @param authorityUri {@link IUri}\n     * @private\n     */\n    private canReplaceTenant(authorityUri: IUri): boolean {\n        return (\n            authorityUri.PathSegments.length === 1 &&\n            !Authority.reservedTenantDomains.has(\n                authorityUri.PathSegments[0]\n            ) &&\n            this.getAuthorityType(authorityUri) === AuthorityType.Default &&\n            this.protocolMode === ProtocolMode.AAD\n        );\n    }\n\n    /**\n     * Replaces tenant in url path with current tenant. Defaults to common.\n     * @param urlString\n     */\n    private replaceTenant(urlString: string): string {\n        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);\n    }\n\n    /**\n     * Replaces path such as tenant or policy with the current tenant or policy.\n     * @param urlString\n     */\n    private replacePath(urlString: string): string {\n        let endpoint = urlString;\n        const cachedAuthorityUrl = new UrlString(\n            this.metadata.canonical_authority\n        );\n        const cachedAuthorityUrlComponents =\n            cachedAuthorityUrl.getUrlComponents();\n        const cachedAuthorityParts = cachedAuthorityUrlComponents.PathSegments;\n        const currentAuthorityParts =\n            this.canonicalAuthorityUrlComponents.PathSegments;\n\n        currentAuthorityParts.forEach((currentPart, index) => {\n            let cachedPart = cachedAuthorityParts[index];\n            if (\n                index === 0 &&\n                this.canReplaceTenant(cachedAuthorityUrlComponents)\n            ) {\n                const tenantId = new UrlString(\n                    this.metadata.authorization_endpoint\n                ).getUrlComponents().PathSegments[0];\n                /**\n                 * Check if AAD canonical authority contains tenant domain name, for example \"testdomain.onmicrosoft.com\",\n                 * by comparing its first path segment to the corresponding authorization endpoint path segment, which is\n                 * always resolved with tenant id by OIDC.\n                 */\n                if (cachedPart !== tenantId) {\n                    this.logger.verbose(\n                        `Replacing tenant domain name ${cachedPart} with id ${tenantId}`\n                    );\n                    cachedPart = tenantId;\n                }\n            }\n            if (currentPart !== cachedPart) {\n                endpoint = endpoint.replace(\n                    `/${cachedPart}/`,\n                    `/${currentPart}/`\n                );\n            }\n        });\n\n        return this.replaceTenant(endpoint);\n    }\n\n    /**\n     * The default open id configuration endpoint for any canonical authority.\n     */\n    protected get defaultOpenIdConfigurationEndpoint(): string {\n        const canonicalAuthorityHost = this.hostnameAndPort;\n        if (\n            this.canonicalAuthority.endsWith(\"v2.0/\") ||\n            this.authorityType === AuthorityType.Adfs ||\n            (this.protocolMode !== ProtocolMode.AAD &&\n                !this.isAliasOfKnownMicrosoftAuthority(canonicalAuthorityHost))\n        ) {\n            return `${this.canonicalAuthority}.well-known/openid-configuration`;\n        }\n        return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;\n    }\n\n    /**\n     * Boolean that returns whethr or not tenant discovery has been completed.\n     */\n    discoveryComplete(): boolean {\n        return !!this.metadata;\n    }\n\n    /**\n     * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network\n     * and the /authorize, /token and logout endpoints.\n     */\n    public async resolveEndpointsAsync(): Promise<void> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthorityResolveEndpointsAsync,\n            this.correlationId\n        );\n\n        const metadataEntity = this.getCurrentMetadataEntity();\n\n        const cloudDiscoverySource = await invokeAsync(\n            this.updateCloudDiscoveryMetadata.bind(this),\n            PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata,\n            this.logger,\n            this.performanceClient,\n            this.correlationId\n        )(metadataEntity);\n        this.canonicalAuthority = this.canonicalAuthority.replace(\n            this.hostnameAndPort,\n            metadataEntity.preferred_network\n        );\n        const endpointSource = await invokeAsync(\n            this.updateEndpointMetadata.bind(this),\n            PerformanceEvents.AuthorityUpdateEndpointMetadata,\n            this.logger,\n            this.performanceClient,\n            this.correlationId\n        )(metadataEntity);\n        this.updateCachedMetadata(metadataEntity, cloudDiscoverySource, {\n            source: endpointSource,\n        });\n    }\n\n    /**\n     * Returns metadata entity from cache if it exists, otherwiser returns a new metadata entity built\n     * from the configured canonical authority\n     * @returns\n     */\n    private getCurrentMetadataEntity(): AuthorityMetadataEntity {\n        let metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(\n            this.hostnameAndPort\n        );\n\n        if (!metadataEntity) {\n            metadataEntity = new AuthorityMetadataEntity();\n            metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n        }\n        return metadataEntity;\n    }\n\n    /**\n     * Updates cached metadata based on metadata source and sets the instance's metadata\n     * property to the same value\n     * @param metadataEntity\n     * @param cloudDiscoverySource\n     * @param endpointMetadataResult\n     */\n    private updateCachedMetadata(\n        metadataEntity: AuthorityMetadataEntity,\n        cloudDiscoverySource: AuthorityMetadataSource | null,\n        endpointMetadataResult: {\n            source: AuthorityMetadataSource;\n            metadata?: OpenIdConfigResponse;\n        } | null\n    ): void {\n        if (\n            cloudDiscoverySource !== AuthorityMetadataSource.CACHE &&\n            endpointMetadataResult?.source !== AuthorityMetadataSource.CACHE\n        ) {\n            // Reset the expiration time unless both values came from a successful cache lookup\n            metadataEntity.resetExpiresAt();\n            metadataEntity.updateCanonicalAuthority(this.canonicalAuthority);\n        }\n\n        const cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(\n            metadataEntity.preferred_cache\n        );\n        this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);\n        this.metadata = metadataEntity;\n    }\n\n    /**\n     * Update AuthorityMetadataEntity with new endpoints and return where the information came from\n     * @param metadataEntity\n     */\n    private async updateEndpointMetadata(\n        metadataEntity: AuthorityMetadataEntity\n    ): Promise<AuthorityMetadataSource> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthorityUpdateEndpointMetadata,\n            this.correlationId\n        );\n\n        const localMetadata =\n            this.updateEndpointMetadataFromLocalSources(metadataEntity);\n\n        // Further update may be required for hardcoded metadata if regional metadata is preferred\n        if (localMetadata) {\n            if (\n                localMetadata.source ===\n                AuthorityMetadataSource.HARDCODED_VALUES\n            ) {\n                // If the user prefers to use an azure region replace the global endpoints with regional information.\n                if (\n                    this.authorityOptions.azureRegionConfiguration?.azureRegion\n                ) {\n                    if (localMetadata.metadata) {\n                        const hardcodedMetadata = await invokeAsync(\n                            this.updateMetadataWithRegionalInformation.bind(\n                                this\n                            ),\n                            PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation,\n                            this.logger,\n                            this.performanceClient,\n                            this.correlationId\n                        )(localMetadata.metadata);\n                        metadataEntity.updateEndpointMetadata(\n                            hardcodedMetadata,\n                            false\n                        );\n                    }\n                }\n            }\n            return localMetadata.source;\n        }\n\n        // Get metadata from network if local sources aren't available\n        let metadata = await invokeAsync(\n            this.getEndpointMetadataFromNetwork.bind(this),\n            PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork,\n            this.logger,\n            this.performanceClient,\n            this.correlationId\n        )();\n        if (metadata) {\n            // If the user prefers to use an azure region replace the global endpoints with regional information.\n            if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {\n                metadata = await invokeAsync(\n                    this.updateMetadataWithRegionalInformation.bind(this),\n                    PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation,\n                    this.logger,\n                    this.performanceClient,\n                    this.correlationId\n                )(metadata);\n            }\n\n            metadataEntity.updateEndpointMetadata(metadata, true);\n            return AuthorityMetadataSource.NETWORK;\n        } else {\n            // Metadata could not be obtained from the config, cache, network or hardcoded values\n            throw createClientAuthError(\n                ClientAuthErrorCodes.openIdConfigError,\n                this.defaultOpenIdConfigurationEndpoint\n            );\n        }\n    }\n\n    /**\n     * Updates endpoint metadata from local sources and returns where the information was retrieved from and the metadata config\n     * response if the source is hardcoded metadata\n     * @param metadataEntity\n     * @returns\n     */\n    private updateEndpointMetadataFromLocalSources(\n        metadataEntity: AuthorityMetadataEntity\n    ): {\n        source: AuthorityMetadataSource;\n        metadata?: OpenIdConfigResponse;\n    } | null {\n        this.logger.verbose(\n            \"Attempting to get endpoint metadata from authority configuration\"\n        );\n        const configMetadata = this.getEndpointMetadataFromConfig();\n        if (configMetadata) {\n            this.logger.verbose(\n                \"Found endpoint metadata in authority configuration\"\n            );\n            metadataEntity.updateEndpointMetadata(configMetadata, false);\n            return {\n                source: AuthorityMetadataSource.CONFIG,\n            };\n        }\n\n        this.logger.verbose(\n            \"Did not find endpoint metadata in the config... Attempting to get endpoint metadata from the hardcoded values.\"\n        );\n\n        // skipAuthorityMetadataCache is used to bypass hardcoded authority metadata and force a network metadata cache lookup and network metadata request if no cached response is available.\n        if (this.authorityOptions.skipAuthorityMetadataCache) {\n            this.logger.verbose(\n                \"Skipping hardcoded metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get endpoint metadata from the network metadata cache.\"\n            );\n        } else {\n            const hardcodedMetadata =\n                this.getEndpointMetadataFromHardcodedValues();\n            if (hardcodedMetadata) {\n                metadataEntity.updateEndpointMetadata(hardcodedMetadata, false);\n                return {\n                    source: AuthorityMetadataSource.HARDCODED_VALUES,\n                    metadata: hardcodedMetadata,\n                };\n            } else {\n                this.logger.verbose(\n                    \"Did not find endpoint metadata in hardcoded values... Attempting to get endpoint metadata from the network metadata cache.\"\n                );\n            }\n        }\n\n        // Check cached metadata entity expiration status\n        const metadataEntityExpired = metadataEntity.isExpired();\n        if (\n            this.isAuthoritySameType(metadataEntity) &&\n            metadataEntity.endpointsFromNetwork &&\n            !metadataEntityExpired\n        ) {\n            // No need to update\n            this.logger.verbose(\"Found endpoint metadata in the cache.\");\n            return { source: AuthorityMetadataSource.CACHE };\n        } else if (metadataEntityExpired) {\n            this.logger.verbose(\"The metadata entity is expired.\");\n        }\n\n        return null;\n    }\n\n    /**\n     * Compares the number of url components after the domain to determine if the cached\n     * authority metadata can be used for the requested authority. Protects against same domain different\n     * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy\n     * @param metadataEntity\n     */\n    private isAuthoritySameType(\n        metadataEntity: AuthorityMetadataEntity\n    ): boolean {\n        const cachedAuthorityUrl = new UrlString(\n            metadataEntity.canonical_authority\n        );\n        const cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;\n\n        return (\n            cachedParts.length ===\n            this.canonicalAuthorityUrlComponents.PathSegments.length\n        );\n    }\n\n    /**\n     * Parse authorityMetadata config option\n     */\n    private getEndpointMetadataFromConfig(): OpenIdConfigResponse | null {\n        if (this.authorityOptions.authorityMetadata) {\n            try {\n                return JSON.parse(\n                    this.authorityOptions.authorityMetadata\n                ) as OpenIdConfigResponse;\n            } catch (e) {\n                throw createClientConfigurationError(\n                    ClientConfigurationErrorCodes.invalidAuthorityMetadata\n                );\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Gets OAuth endpoints from the given OpenID configuration endpoint.\n     *\n     * @param hasHardcodedMetadata boolean\n     */\n    private async getEndpointMetadataFromNetwork(): Promise<OpenIdConfigResponse | null> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork,\n            this.correlationId\n        );\n\n        const options: ImdsOptions = {};\n\n        /*\n         * TODO: Add a timeout if the authority exists in our library's\n         * hardcoded list of metadata\n         */\n\n        const openIdConfigurationEndpoint =\n            this.defaultOpenIdConfigurationEndpoint;\n        this.logger.verbose(\n            `Authority.getEndpointMetadataFromNetwork: attempting to retrieve OAuth endpoints from ${openIdConfigurationEndpoint}`\n        );\n\n        try {\n            const response =\n                await this.networkInterface.sendGetRequestAsync<OpenIdConfigResponse>(\n                    openIdConfigurationEndpoint,\n                    options\n                );\n            const isValidResponse = isOpenIdConfigResponse(response.body);\n            if (isValidResponse) {\n                return response.body;\n            } else {\n                this.logger.verbose(\n                    `Authority.getEndpointMetadataFromNetwork: could not parse response as OpenID configuration`\n                );\n                return null;\n            }\n        } catch (e) {\n            this.logger.verbose(\n                `Authority.getEndpointMetadataFromNetwork: ${e}`\n            );\n            return null;\n        }\n    }\n\n    /**\n     * Get OAuth endpoints for common authorities.\n     */\n    private getEndpointMetadataFromHardcodedValues(): OpenIdConfigResponse | null {\n        if (this.canonicalAuthority in EndpointMetadata) {\n            return EndpointMetadata[this.canonicalAuthority];\n        }\n\n        return null;\n    }\n\n    /**\n     * Update the retrieved metadata with regional information.\n     * User selected Azure region will be used if configured.\n     */\n    private async updateMetadataWithRegionalInformation(\n        metadata: OpenIdConfigResponse\n    ): Promise<OpenIdConfigResponse> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation,\n            this.correlationId\n        );\n\n        const userConfiguredAzureRegion =\n            this.authorityOptions.azureRegionConfiguration?.azureRegion;\n\n        if (userConfiguredAzureRegion) {\n            if (\n                userConfiguredAzureRegion !==\n                Constants.AZURE_REGION_AUTO_DISCOVER_FLAG\n            ) {\n                this.regionDiscoveryMetadata.region_outcome =\n                    RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;\n                this.regionDiscoveryMetadata.region_used =\n                    userConfiguredAzureRegion;\n                return Authority.replaceWithRegionalInformation(\n                    metadata,\n                    userConfiguredAzureRegion\n                );\n            }\n\n            const autodetectedRegionName = await invokeAsync(\n                this.regionDiscovery.detectRegion.bind(this.regionDiscovery),\n                PerformanceEvents.RegionDiscoveryDetectRegion,\n                this.logger,\n                this.performanceClient,\n                this.correlationId\n            )(\n                this.authorityOptions.azureRegionConfiguration\n                    ?.environmentRegion,\n                this.regionDiscoveryMetadata\n            );\n\n            if (autodetectedRegionName) {\n                this.regionDiscoveryMetadata.region_outcome =\n                    RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL;\n                this.regionDiscoveryMetadata.region_used =\n                    autodetectedRegionName;\n                return Authority.replaceWithRegionalInformation(\n                    metadata,\n                    autodetectedRegionName\n                );\n            }\n\n            this.regionDiscoveryMetadata.region_outcome =\n                RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;\n        }\n\n        return metadata;\n    }\n\n    /**\n     * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache\n     * and returns where the information was retrieved from\n     * @param metadataEntity\n     * @returns AuthorityMetadataSource\n     */\n    private async updateCloudDiscoveryMetadata(\n        metadataEntity: AuthorityMetadataEntity\n    ): Promise<AuthorityMetadataSource> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata,\n            this.correlationId\n        );\n        const localMetadataSource =\n            this.updateCloudDiscoveryMetadataFromLocalSources(metadataEntity);\n        if (localMetadataSource) {\n            return localMetadataSource;\n        }\n\n        // Fallback to network as metadata source\n        const metadata = await invokeAsync(\n            this.getCloudDiscoveryMetadataFromNetwork.bind(this),\n            PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork,\n            this.logger,\n            this.performanceClient,\n            this.correlationId\n        )();\n\n        if (metadata) {\n            metadataEntity.updateCloudDiscoveryMetadata(metadata, true);\n            return AuthorityMetadataSource.NETWORK;\n        }\n\n        // Metadata could not be obtained from the config, cache, network or hardcoded values\n        throw createClientConfigurationError(\n            ClientConfigurationErrorCodes.untrustedAuthority\n        );\n    }\n\n    private updateCloudDiscoveryMetadataFromLocalSources(\n        metadataEntity: AuthorityMetadataEntity\n    ): AuthorityMetadataSource | null {\n        this.logger.verbose(\n            \"Attempting to get cloud discovery metadata  from authority configuration\"\n        );\n        this.logger.verbosePii(\n            `Known Authorities: ${\n                this.authorityOptions.knownAuthorities ||\n                Constants.NOT_APPLICABLE\n            }`\n        );\n        this.logger.verbosePii(\n            `Authority Metadata: ${\n                this.authorityOptions.authorityMetadata ||\n                Constants.NOT_APPLICABLE\n            }`\n        );\n        this.logger.verbosePii(\n            `Canonical Authority: ${\n                metadataEntity.canonical_authority || Constants.NOT_APPLICABLE\n            }`\n        );\n        const metadata = this.getCloudDiscoveryMetadataFromConfig();\n        if (metadata) {\n            this.logger.verbose(\n                \"Found cloud discovery metadata in authority configuration\"\n            );\n            metadataEntity.updateCloudDiscoveryMetadata(metadata, false);\n            return AuthorityMetadataSource.CONFIG;\n        }\n\n        // If the cached metadata came from config but that config was not passed to this instance, we must go to hardcoded values\n        this.logger.verbose(\n            \"Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the hardcoded values.\"\n        );\n\n        if (this.options.skipAuthorityMetadataCache) {\n            this.logger.verbose(\n                \"Skipping hardcoded cloud discovery metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get cloud discovery metadata from the network metadata cache.\"\n            );\n        } else {\n            const hardcodedMetadata =\n                getCloudDiscoveryMetadataFromHardcodedValues(\n                    this.hostnameAndPort\n                );\n            if (hardcodedMetadata) {\n                this.logger.verbose(\n                    \"Found cloud discovery metadata from hardcoded values.\"\n                );\n                metadataEntity.updateCloudDiscoveryMetadata(\n                    hardcodedMetadata,\n                    false\n                );\n                return AuthorityMetadataSource.HARDCODED_VALUES;\n            }\n\n            this.logger.verbose(\n                \"Did not find cloud discovery metadata in hardcoded values... Attempting to get cloud discovery metadata from the network metadata cache.\"\n            );\n        }\n\n        const metadataEntityExpired = metadataEntity.isExpired();\n        if (\n            this.isAuthoritySameType(metadataEntity) &&\n            metadataEntity.aliasesFromNetwork &&\n            !metadataEntityExpired\n        ) {\n            this.logger.verbose(\"Found cloud discovery metadata in the cache.\");\n            // No need to update\n            return AuthorityMetadataSource.CACHE;\n        } else if (metadataEntityExpired) {\n            this.logger.verbose(\"The metadata entity is expired.\");\n        }\n\n        return null;\n    }\n\n    /**\n     * Parse cloudDiscoveryMetadata config or check knownAuthorities\n     */\n    private getCloudDiscoveryMetadataFromConfig(): CloudDiscoveryMetadata | null {\n        // CIAM does not support cloud discovery metadata\n        if (this.authorityType === AuthorityType.Ciam) {\n            this.logger.verbose(\n                \"CIAM authorities do not support cloud discovery metadata, generate the aliases from authority host.\"\n            );\n            return Authority.createCloudDiscoveryMetadataFromHost(\n                this.hostnameAndPort\n            );\n        }\n\n        // Check if network response was provided in config\n        if (this.authorityOptions.cloudDiscoveryMetadata) {\n            this.logger.verbose(\n                \"The cloud discovery metadata has been provided as a network response, in the config.\"\n            );\n            try {\n                this.logger.verbose(\n                    \"Attempting to parse the cloud discovery metadata.\"\n                );\n                const parsedResponse = JSON.parse(\n                    this.authorityOptions.cloudDiscoveryMetadata\n                ) as CloudInstanceDiscoveryResponse;\n                const metadata = getCloudDiscoveryMetadataFromNetworkResponse(\n                    parsedResponse.metadata,\n                    this.hostnameAndPort\n                );\n                this.logger.verbose(\"Parsed the cloud discovery metadata.\");\n                if (metadata) {\n                    this.logger.verbose(\n                        \"There is returnable metadata attached to the parsed cloud discovery metadata.\"\n                    );\n                    return metadata;\n                } else {\n                    this.logger.verbose(\n                        \"There is no metadata attached to the parsed cloud discovery metadata.\"\n                    );\n                }\n            } catch (e) {\n                this.logger.verbose(\n                    \"Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error.\"\n                );\n                throw createClientConfigurationError(\n                    ClientConfigurationErrorCodes.invalidCloudDiscoveryMetadata\n                );\n            }\n        }\n\n        // If cloudDiscoveryMetadata is empty or does not contain the host, check knownAuthorities\n        if (this.isInKnownAuthorities()) {\n            this.logger.verbose(\n                \"The host is included in knownAuthorities. Creating new cloud discovery metadata from the host.\"\n            );\n            return Authority.createCloudDiscoveryMetadataFromHost(\n                this.hostnameAndPort\n            );\n        }\n\n        return null;\n    }\n\n    /**\n     * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config\n     *\n     * @param hasHardcodedMetadata boolean\n     */\n    private async getCloudDiscoveryMetadataFromNetwork(): Promise<CloudDiscoveryMetadata | null> {\n        this.performanceClient?.addQueueMeasurement(\n            PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork,\n            this.correlationId\n        );\n        const instanceDiscoveryEndpoint = `${Constants.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;\n        const options: ImdsOptions = {};\n\n        /*\n         * TODO: Add a timeout if the authority exists in our library's\n         * hardcoded list of metadata\n         */\n\n        let match = null;\n        try {\n            const response = await this.networkInterface.sendGetRequestAsync<\n                | CloudInstanceDiscoveryResponse\n                | CloudInstanceDiscoveryErrorResponse\n            >(instanceDiscoveryEndpoint, options);\n            let typedResponseBody:\n                | CloudInstanceDiscoveryResponse\n                | CloudInstanceDiscoveryErrorResponse;\n            let metadata: Array<CloudDiscoveryMetadata>;\n            if (isCloudInstanceDiscoveryResponse(response.body)) {\n                typedResponseBody =\n                    response.body as CloudInstanceDiscoveryResponse;\n                metadata = typedResponseBody.metadata;\n\n                this.logger.verbosePii(\n                    `tenant_discovery_endpoint is: ${typedResponseBody.tenant_discovery_endpoint}`\n                );\n            } else if (isCloudInstanceDiscoveryErrorResponse(response.body)) {\n                this.logger.warning(\n                    `A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: ${response.status}`\n                );\n\n                typedResponseBody =\n                    response.body as CloudInstanceDiscoveryErrorResponse;\n                if (typedResponseBody.error === Constants.INVALID_INSTANCE) {\n                    this.logger.error(\n                        \"The CloudInstanceDiscoveryErrorResponse error is invalid_instance.\"\n                    );\n                    return null;\n                }\n\n                this.logger.warning(\n                    `The CloudInstanceDiscoveryErrorResponse error is ${typedResponseBody.error}`\n                );\n                this.logger.warning(\n                    `The CloudInstanceDiscoveryErrorResponse error description is ${typedResponseBody.error_description}`\n                );\n\n                this.logger.warning(\n                    \"Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []\"\n                );\n                metadata = [];\n            } else {\n                this.logger.error(\n                    \"AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse\"\n                );\n                return null;\n            }\n\n            this.logger.verbose(\n                \"Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request.\"\n            );\n            match = getCloudDiscoveryMetadataFromNetworkResponse(\n                metadata,\n                this.hostnameAndPort\n            );\n        } catch (error) {\n            if (error instanceof AuthError) {\n                this.logger.error(\n                    `There was a network error while attempting to get the cloud discovery instance metadata.\\nError: ${error.errorCode}\\nError Description: ${error.errorMessage}`\n                );\n            } else {\n                const typedError = error as Error;\n                this.logger.error(\n                    `A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.\\nError: ${typedError.name}\\nError Description: ${typedError.message}`\n                );\n            }\n\n            return null;\n        }\n\n        // Custom Domain scenario, host is trusted because Instance Discovery call succeeded\n        if (!match) {\n            this.logger.warning(\n                \"The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request.\"\n            );\n            this.logger.verbose(\n                \"Creating custom Authority for custom domain scenario.\"\n            );\n\n            match = Authority.createCloudDiscoveryMetadataFromHost(\n                this.hostnameAndPort\n            );\n        }\n        return match;\n    }\n\n    /**\n     * Helper function to determine if this host is included in the knownAuthorities config option\n     */\n    private isInKnownAuthorities(): boolean {\n        const matches = this.authorityOptions.knownAuthorities.filter(\n            (authority) => {\n                return (\n                    UrlString.getDomainFromUrl(authority).toLowerCase() ===\n                    this.hostnameAndPort\n                );\n            }\n        );\n\n        return matches.length > 0;\n    }\n\n    /**\n     * helper function to populate the authority based on azureCloudOptions\n     * @param authorityString\n     * @param azureCloudOptions\n     */\n    static generateAuthority(\n        authorityString: string,\n        azureCloudOptions?: AzureCloudOptions\n    ): string {\n        let authorityAzureCloudInstance;\n\n        if (\n            azureCloudOptions &&\n            azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None\n        ) {\n            const tenant = azureCloudOptions.tenant\n                ? azureCloudOptions.tenant\n                : Constants.DEFAULT_COMMON_TENANT;\n            authorityAzureCloudInstance = `${azureCloudOptions.azureCloudInstance}/${tenant}/`;\n        }\n\n        return authorityAzureCloudInstance\n            ? authorityAzureCloudInstance\n            : authorityString;\n    }\n\n    /**\n     * Creates cloud discovery metadata object from a given host\n     * @param host\n     */\n    static createCloudDiscoveryMetadataFromHost(\n        host: string\n    ): CloudDiscoveryMetadata {\n        return {\n            preferred_network: host,\n            preferred_cache: host,\n            aliases: [host],\n        };\n    }\n\n    /**\n     * helper function to generate environment from authority object\n     */\n    getPreferredCache(): string {\n        if (this.discoveryComplete()) {\n            return this.metadata.preferred_cache;\n        } else {\n            throw createClientAuthError(\n                ClientAuthErrorCodes.endpointResolutionError\n            );\n        }\n    }\n\n    /**\n     * Returns whether or not the provided host is an alias of this authority instance\n     * @param host\n     */\n    isAlias(host: string): boolean {\n        return this.metadata.aliases.indexOf(host) > -1;\n    }\n\n    /**\n     * Returns whether or not the provided host is an alias of a known Microsoft authority for purposes of endpoint discovery\n     * @param host\n     */\n    isAliasOfKnownMicrosoftAuthority(host: string): boolean {\n        return InstanceDiscoveryMetadataAliases.has(host);\n    }\n\n    /**\n     * Checks whether the provided host is that of a public cloud authority\n     *\n     * @param authority string\n     * @returns bool\n     */\n    static isPublicCloudAuthority(host: string): boolean {\n        return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;\n    }\n\n    /**\n     * Rebuild the authority string with the region\n     *\n     * @param host string\n     * @param region string\n     */\n    static buildRegionalAuthorityString(\n        host: string,\n        region: string,\n        queryString?: string\n    ): string {\n        // Create and validate a Url string object with the initial authority string\n        const authorityUrlInstance = new UrlString(host);\n        authorityUrlInstance.validateAsUri();\n\n        const authorityUrlParts = authorityUrlInstance.getUrlComponents();\n\n        let hostNameAndPort = `${region}.${authorityUrlParts.HostNameAndPort}`;\n\n        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {\n            hostNameAndPort = `${region}.${Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX}`;\n        }\n\n        // Include the query string portion of the url\n        const url = UrlString.constructAuthorityUriFromObject({\n            ...authorityUrlInstance.getUrlComponents(),\n            HostNameAndPort: hostNameAndPort,\n        }).urlString;\n\n        // Add the query string if a query string was provided\n        if (queryString) return `${url}?${queryString}`;\n\n        return url;\n    }\n\n    /**\n     * Replace the endpoints in the metadata object with their regional equivalents.\n     *\n     * @param metadata OpenIdConfigResponse\n     * @param azureRegion string\n     */\n    static replaceWithRegionalInformation(\n        metadata: OpenIdConfigResponse,\n        azureRegion: string\n    ): OpenIdConfigResponse {\n        const regionalMetadata = { ...metadata };\n        regionalMetadata.authorization_endpoint =\n            Authority.buildRegionalAuthorityString(\n                regionalMetadata.authorization_endpoint,\n                azureRegion\n            );\n\n        regionalMetadata.token_endpoint =\n            Authority.buildRegionalAuthorityString(\n                regionalMetadata.token_endpoint,\n                azureRegion\n            );\n\n        if (regionalMetadata.end_session_endpoint) {\n            regionalMetadata.end_session_endpoint =\n                Authority.buildRegionalAuthorityString(\n                    regionalMetadata.end_session_endpoint,\n                    azureRegion\n                );\n        }\n\n        return regionalMetadata;\n    }\n\n    /**\n     * Transform CIAM_AUTHORIY as per the below rules:\n     * If no path segments found and it is a CIAM authority (hostname ends with .ciamlogin.com), then transform it\n     *\n     * NOTE: The transformation path should go away once STS supports CIAM with the format: `tenantIdorDomain.ciamlogin.com`\n     * `ciamlogin.com` can also change in the future and we should accommodate the same\n     *\n     * @param authority\n     */\n    static transformCIAMAuthority(authority: string): string {\n        let ciamAuthority = authority;\n        const authorityUrl = new UrlString(authority);\n        const authorityUrlComponents = authorityUrl.getUrlComponents();\n\n        // check if transformation is needed\n        if (\n            authorityUrlComponents.PathSegments.length === 0 &&\n            authorityUrlComponents.HostNameAndPort.endsWith(\n                Constants.CIAM_AUTH_URL\n            )\n        ) {\n            const tenantIdOrDomain =\n                authorityUrlComponents.HostNameAndPort.split(\".\")[0];\n            ciamAuthority = `${ciamAuthority}${tenantIdOrDomain}${Constants.AAD_TENANT_DOMAIN_SUFFIX}`;\n        }\n\n        return ciamAuthority;\n    }\n}\n\nexport function formatAuthorityUri(authorityUri: string): string {\n    return authorityUri.endsWith(Constants.FORWARD_SLASH)\n        ? authorityUri\n        : `${authorityUri}${Constants.FORWARD_SLASH}`;\n}\n\nexport function buildStaticAuthorityOptions(\n    authOptions: Partial<AuthorityOptions>\n): StaticAuthorityOptions {\n    const rawCloudDiscoveryMetadata = authOptions.cloudDiscoveryMetadata;\n    let cloudDiscoveryMetadata: CloudInstanceDiscoveryResponse | undefined =\n        undefined;\n    if (rawCloudDiscoveryMetadata) {\n        try {\n            cloudDiscoveryMetadata = JSON.parse(rawCloudDiscoveryMetadata);\n        } catch (e) {\n            throw createClientConfigurationError(\n                ClientConfigurationErrorCodes.invalidCloudDiscoveryMetadata\n            );\n        }\n    }\n    return {\n        canonicalAuthority: authOptions.authority\n            ? formatAuthorityUri(authOptions.authority)\n            : undefined,\n        knownAuthorities: authOptions.knownAuthorities,\n        cloudDiscoveryMetadata: cloudDiscoveryMetadata,\n    };\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAKA;AACA;AAKA;AAKA;AAuDI;AAEA;;;;AAQ8B,MAAAA,SAAA;EAE9BC,YAAAC,SAAuB,EAAAC,gBAAA,EAAAC,YAAA,EAAAC,gBAAA,EAAAC,MAAA,EAAAC,iBAAA,EAAAC,aAAA;IAEvB,KAASC,kBAAkB,GAAoBP,SAAA;IAE/C,KAASQ,mBAAsB,CAAAC,aAAA,EAAa;IAE5C,IAAQ,CAAAR,gBAAO,GAAAA,gBAMZ;qBAGU,GAAQC,YACD;IA4BpB,KAAAC,gBAAA,GAAAA,gBAAA;;;;MAIGO,cAAA,EAAAC;IACH;IAqBW,KAAAP,MAAA,GAAiBA,MAAA;IAI5B,KAAAC,iBAAA,GAAAA,iBAAA;;IAEG,KAAAO,eAAA,OAAAC,eAAA,CAAAZ,gBAAA,OAAAG,MAAA,OAAAC,iBAAA,OAAAC,aAAA;;EAKH;;AAEG;;AAKH;;IAEG;IACQ,IAAAQ,YAAA,CAAAC,eAEV,CAAAC,QAAA,CAAAC,SAAA,CAAAC,aAAA;MAED,OAAAC,aAAA,CAAAC,IAAA;;IAEG,MAAAC,YAAA,GAAAP,YAAA,CAAAQ,YAAA;IACQ,IAAkBD,YAAA,CAAAE,MAAI;MAMjC,QAAAF,YAAA,IAAAG,WAAA;;UAEG,OAAAL,aAAA,CAAAM,IAAA;QACQ,KAAAR,SAAA,CAAAS,IAAA;UASX,OAAAP,aAAA,CAAAQ,IAAA;;IAOA;;EAEG;;EAKH,IAAAC,cAAA;;EAEG;;AAWH;;EAEG,IAAAC,aAAA;IACQ,YAAA1B,gBAQV,CAAA0B,YAAA;;EAcD;;AAEG;EACH,IAAWC,QAAA;IAgBX,YAAA3B,gBAAA;;EAEG;;AAWH;;IAEG,YAAAK,mBAAA,CAAAuB,SAAA;;EAWH;;;;IAIG,KAAAvB,mBAAA,OAAAwB,SAAA,CAAAC,GAAA;IACH,IAAQ,CAAgBzB,mBAAA,CAAAC,aAAA;IAWxB,KAAAyB,gCAAA;;;AAGG;AACH;EAIA,IAAAC,gCAAA;;8CAGG,KAAA3B,mBAAA,CAAA4B,gBAAA;IACH;IA2CA,YAAAF,gCAAA;;EAEG;AACH;AAaA;;IAEG,YAAAC,+BAAA,CAAApB,eAAA,CAAAS,WAAA;EACH;EAIA;;;EAGG,IAAAa,OAAA;IACU,YAAAF,+BAAsC,CAAAb,YAAA;EA+BnD;;;;EAIG,IAAAgB,sBAAA;IACH,IAAQ,IAAwB,CAAAC,iBAAA;MAYhC,YAAAC,WAAA,MAAAC,QAAA,CAAAC,sBAAA;;;;;EAMG;AACH;AAwBA;;;MAGG,YAAAF,WAAA,MAAAC,QAAA,CAAAE,cAAA;WAyEH;;;;;IAKG,SAAAJ,iBAAA;MACK,OAAsC,KAAAC,WAAA,MAAAC,QAAA,CAAAE,cAAA,CAAAC,OAAA;IA8D9C,O;;;;EAKG;AACH;AAcA;;IAEG,SAAAL,iBAAA;MACH;MAgBA,UAAAE,QAAA,CAAAI,oBAAA;;;;IAIG,OACyC;MA0C5C,MAAAC,qBAAA,CAAAC,uBAAA;;EAEG;EACH;AAQA;;;IAGG,SAAAR,iBAAA;MACW,OAAqC,KAAAC,WAAA,MAAAC,QAAA,CAAAO,MAAA;IAwDnD,O;;;;EAKG;;AAkCH;EA8EA,IAAAC,QAAA;;MAEG,YAAAT,WAAA,MAAAC,QAAA,CAAAS,QAAA;IACH,OA6DA;;;;EAIG;;AAsGH;;AAEG;EACHC,gBAA4BA,CAAArC,YAAA;IAa5B,OAAAA,YAAA,CAAAQ,YAAA,CAAAC,MAAA,U;EAIG;EACH;AAqBA;;;EAGG6B,cAAArB,SAAA;IACH,OAA2CA,SAAA,CAAAa,OAAA,uBACjC,OAAAP,MACe;EAQzB;;AAEG;AACH;AAUA;;;IAGG,MAAAgB,kBAAA,OAAArB,SAAA,MAAAS,QAAA,CAAAa,mBAAA;IACH,MAAQC,4BAAsB,GAAAF,kBAAA,CAAAjB,gBAAA;IAI9B,MAAAoB,oBAAA,GAAAD,4BAAA,CAAAjC,YAAA;;;MAGG,IAAAmC,UAAA,GAAAD,oBAAA,CAAAE,KAAA;MACH,IAAAA,KAAA,UAIA,KAAAP,gBAAA,CAAAI,4BAAA;;;;;AAKG;AACH;QAIA,IAAAE,UAAA,KAAAE,QAAA;;;;;MAKG,IAAAC,WAAA,KAAAH,UAAA;QACgCI,QAAA,GAAAA,QAAA,CAAAjB,OAC3B,KAAEa,UACN,GAAQ,MAAAG,WACG,IAAC;MA0BhB;;;;;AAKG;;EA6BH,IAAAE,mCAAA;;;;;IAQG,eAAAvD,kBAAA;EACH;EAmBH;AAED;AAMA"},"metadata":{},"sourceType":"module","externalDependencies":[]}