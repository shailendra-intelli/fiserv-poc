{"ast":null,"code":"/*! @azure/msal-browser v3.9.0 2024-02-07 */\n'use strict';\n\nimport { AuthToken, AccountEntity, CacheRecord, Authority, buildAccountToCache, CacheHelpers, ScopeSet, Constants } from '@azure/msal-common';\nimport { createBrowserAuthError } from '../error/BrowserAuthError.mjs';\nimport { base64Decode } from '../encode/Base64Decode.mjs';\nimport { createNewGuid } from '../crypto/BrowserCrypto.mjs';\nimport { unableToLoadToken } from '../error/BrowserAuthErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Token cache manager\n */\nclass TokenCache {\n  constructor(configuration, storage, logger, cryptoObj) {\n    this.isBrowserEnvironment = typeof window !== \"undefined\";\n    this.config = configuration;\n    this.storage = storage;\n    this.logger = logger;\n    this.cryptoObj = cryptoObj;\n  }\n  // Move getAllAccounts here and cache utility APIs\n  /**\n   * API to load tokens to msal-browser cache.\n   * @param request\n   * @param response\n   * @param options\n   * @returns `AuthenticationResult` for the response that was loaded.\n   */\n  loadExternalTokens(request, response, options) {\n    this.logger.info(\"TokenCache - loadExternalTokens called\");\n    if (!response.id_token) {\n      throw createBrowserAuthError(unableToLoadToken);\n    }\n    const idTokenClaims = AuthToken.extractTokenClaims(response.id_token, base64Decode);\n    let cacheRecord;\n    let authority;\n    let cacheRecordAccount;\n    if (request.account) {\n      cacheRecordAccount = AccountEntity.createFromAccountInfo(request.account);\n      cacheRecord = new CacheRecord(cacheRecordAccount, this.loadIdToken(response.id_token, cacheRecordAccount.homeAccountId, request.account.environment, request.account.tenantId), this.loadAccessToken(request, response, cacheRecordAccount.homeAccountId, request.account.environment, request.account.tenantId, options), this.loadRefreshToken(request, response, cacheRecordAccount.homeAccountId, request.account.environment));\n    } else if (request.authority) {\n      const authorityUrl = Authority.generateAuthority(request.authority, request.azureCloudOptions);\n      const authorityOptions = {\n        protocolMode: this.config.auth.protocolMode,\n        knownAuthorities: this.config.auth.knownAuthorities,\n        cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n        authorityMetadata: this.config.auth.authorityMetadata,\n        skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache\n      };\n      authority = new Authority(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.logger, request.correlationId || createNewGuid());\n      // \"clientInfo\" from options takes precedence over \"clientInfo\" in response\n      if (options.clientInfo) {\n        this.logger.trace(\"TokenCache - homeAccountId from options\");\n        cacheRecordAccount = this.loadAccount(idTokenClaims, authority, options.clientInfo);\n        cacheRecord = new CacheRecord(cacheRecordAccount, this.loadIdToken(response.id_token, cacheRecordAccount.homeAccountId, authority.hostnameAndPort, authority.tenant), this.loadAccessToken(request, response, cacheRecordAccount.homeAccountId, authority.hostnameAndPort, authority.tenant, options), this.loadRefreshToken(request, response, cacheRecordAccount.homeAccountId, authority.hostnameAndPort));\n      } else if (response.client_info) {\n        this.logger.trace(\"TokenCache - homeAccountId from response\");\n        cacheRecordAccount = this.loadAccount(idTokenClaims, authority, response.client_info);\n        cacheRecord = new CacheRecord(cacheRecordAccount, this.loadIdToken(response.id_token, cacheRecordAccount.homeAccountId, authority.hostnameAndPort, authority.tenant), this.loadAccessToken(request, response, cacheRecordAccount.homeAccountId, authority.hostnameAndPort, authority.tenant, options), this.loadRefreshToken(request, response, cacheRecordAccount.homeAccountId, authority.hostnameAndPort));\n      } else {\n        throw createBrowserAuthError(unableToLoadToken);\n      }\n    } else {\n      throw createBrowserAuthError(unableToLoadToken);\n    }\n    return this.generateAuthenticationResult(request, idTokenClaims, cacheRecord, cacheRecordAccount, authority);\n  }\n  /**\n   * Helper function to load account to msal-browser cache\n   * @param idToken\n   * @param environment\n   * @param clientInfo\n   * @param authorityType\n   * @param requestHomeAccountId\n   * @returns `AccountEntity`\n   */\n  loadAccount(idTokenClaims, authority, clientInfo, requestHomeAccountId) {\n    if (this.isBrowserEnvironment) {\n      this.logger.verbose(\"TokenCache - loading account\");\n      let homeAccountId;\n      if (requestHomeAccountId) {\n        homeAccountId = requestHomeAccountId;\n      } else if (authority.authorityType !== undefined && clientInfo) {\n        homeAccountId = AccountEntity.generateHomeAccountId(clientInfo, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);\n      }\n      if (!homeAccountId) {\n        throw createBrowserAuthError(unableToLoadToken);\n      }\n      const claimsTenantId = idTokenClaims.tid;\n      const cachedAccount = buildAccountToCache(this.storage, authority, homeAccountId, idTokenClaims, base64Decode, clientInfo, authority.hostnameAndPort, claimsTenantId, undefined,\n      // authCodePayload\n      undefined,\n      // nativeAccountId\n      this.logger);\n      this.storage.setAccount(cachedAccount);\n      return cachedAccount;\n    } else {\n      throw createBrowserAuthError(unableToLoadToken);\n    }\n  }\n  /**\n   * Helper function to load id tokens to msal-browser cache\n   * @param idToken\n   * @param homeAccountId\n   * @param environment\n   * @param tenantId\n   * @returns `IdTokenEntity`\n   */\n  loadIdToken(idToken, homeAccountId, environment, tenantId) {\n    const idTokenEntity = CacheHelpers.createIdTokenEntity(homeAccountId, environment, idToken, this.config.auth.clientId, tenantId);\n    if (this.isBrowserEnvironment) {\n      this.logger.verbose(\"TokenCache - loading id token\");\n      this.storage.setIdTokenCredential(idTokenEntity);\n      return idTokenEntity;\n    } else {\n      throw createBrowserAuthError(unableToLoadToken);\n    }\n  }\n  /**\n   * Helper function to load access tokens to msal-browser cache\n   * @param request\n   * @param response\n   * @param homeAccountId\n   * @param environment\n   * @param tenantId\n   * @returns `AccessTokenEntity`\n   */\n  loadAccessToken(request, response, homeAccountId, environment, tenantId, options) {\n    if (!response.access_token) {\n      this.logger.verbose(\"TokenCache - No access token provided for caching\");\n      return null;\n    }\n    if (!response.expires_in) {\n      throw createBrowserAuthError(unableToLoadToken);\n    }\n    if (!options.extendedExpiresOn) {\n      throw createBrowserAuthError(unableToLoadToken);\n    }\n    const scopes = new ScopeSet(request.scopes).printScopes();\n    const expiresOn = options.expiresOn || response.expires_in + new Date().getTime() / 1000;\n    const extendedExpiresOn = options.extendedExpiresOn;\n    const accessTokenEntity = CacheHelpers.createAccessTokenEntity(homeAccountId, environment, response.access_token, this.config.auth.clientId, tenantId, scopes, expiresOn, extendedExpiresOn, base64Decode);\n    if (this.isBrowserEnvironment) {\n      this.logger.verbose(\"TokenCache - loading access token\");\n      this.storage.setAccessTokenCredential(accessTokenEntity);\n      return accessTokenEntity;\n    } else {\n      throw createBrowserAuthError(unableToLoadToken);\n    }\n  }\n  /**\n   * Helper function to load refresh tokens to msal-browser cache\n   * @param request\n   * @param response\n   * @param homeAccountId\n   * @param environment\n   * @returns `RefreshTokenEntity`\n   */\n  loadRefreshToken(request, response, homeAccountId, environment) {\n    if (!response.refresh_token) {\n      this.logger.verbose(\"TokenCache - No refresh token provided for caching\");\n      return null;\n    }\n    const refreshTokenEntity = CacheHelpers.createRefreshTokenEntity(homeAccountId, environment, response.refresh_token, this.config.auth.clientId);\n    if (this.isBrowserEnvironment) {\n      this.logger.verbose(\"TokenCache - loading refresh token\");\n      this.storage.setRefreshTokenCredential(refreshTokenEntity);\n      return refreshTokenEntity;\n    } else {\n      throw createBrowserAuthError(unableToLoadToken);\n    }\n  }\n  /**\n   * Helper function to generate an `AuthenticationResult` for the result.\n   * @param request\n   * @param idTokenObj\n   * @param cacheRecord\n   * @param authority\n   * @returns `AuthenticationResult`\n   */\n  generateAuthenticationResult(request, idTokenClaims, cacheRecord, accountEntity, authority) {\n    let accessToken = Constants.EMPTY_STRING;\n    let responseScopes = [];\n    let expiresOn = null;\n    let extExpiresOn;\n    if (cacheRecord?.accessToken) {\n      accessToken = cacheRecord.accessToken.secret;\n      responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\n      expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\n      extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\n    }\n    const uid = idTokenClaims.oid || idTokenClaims.sub || Constants.EMPTY_STRING;\n    const tid = idTokenClaims.tid || Constants.EMPTY_STRING;\n    return {\n      authority: authority ? authority.canonicalAuthority : Constants.EMPTY_STRING,\n      uniqueId: uid,\n      tenantId: tid,\n      scopes: responseScopes,\n      account: accountEntity.getAccountInfo(),\n      idToken: cacheRecord.idToken?.secret || \"\",\n      idTokenClaims: idTokenClaims || {},\n      accessToken: accessToken,\n      fromCache: true,\n      expiresOn: expiresOn,\n      correlationId: request.correlationId || Constants.EMPTY_STRING,\n      requestId: Constants.EMPTY_STRING,\n      extExpiresOn: extExpiresOn,\n      familyId: Constants.EMPTY_STRING,\n      tokenType: cacheRecord?.accessToken?.tokenType || Constants.EMPTY_STRING,\n      state: Constants.EMPTY_STRING,\n      cloudGraphHostName: accountEntity.cloudGraphHostName || Constants.EMPTY_STRING,\n      msGraphHost: accountEntity.msGraphHost || Constants.EMPTY_STRING,\n      code: undefined,\n      fromNativeBroker: false\n    };\n  }\n}\nexport { TokenCache };","map":{"version":3,"names":["TokenCache","constructor","configuration","storage","logger","cryptoObj","isBrowserEnvironment","window","config","loadExternalTokens","request","response","options","info","id_token","createBrowserAuthError","unableToLoadToken","idTokenClaims","AuthToken","extractTokenClaims","base64Decode","cacheRecord","authority","cacheRecordAccount","account","AccountEntity","createFromAccountInfo","CacheRecord","loadIdToken","homeAccountId","environment","tenantId","loadAccessToken","loadRefreshToken","authorityUrl","Authority","generateAuthority","azureCloudOptions","authorityOptions","protocolMode","auth","knownAuthorities","cloudDiscoveryMetadata","authorityMetadata","skipAuthorityMetadataCache","system","networkClient","correlationId","createNewGuid","clientInfo","trace","loadAccount","hostnameAndPort","tenant","client_info","generateAuthenticationResult","requestHomeAccountId","verbose","authorityType","undefined","generateHomeAccountId","claimsTenantId","tid","cachedAccount","buildAccountToCache","setAccount","idToken","idTokenEntity","CacheHelpers","createIdTokenEntity","clientId","setIdTokenCredential","access_token","expires_in","extendedExpiresOn","scopes","ScopeSet","printScopes","expiresOn","Date","getTime","accessTokenEntity","createAccessTokenEntity","setAccessTokenCredential","refresh_token","refreshTokenEntity","createRefreshTokenEntity","setRefreshTokenCredential","accountEntity","accessToken","Constants","EMPTY_STRING","responseScopes","extExpiresOn","secret","fromString","target","asArray","Number","uid","oid","sub","canonicalAuthority","uniqueId","getAccountInfo","fromCache","requestId","familyId","tokenType","state","cloudGraphHostName","msGraphHost","code","fromNativeBroker"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-browser\\src\\cache\\TokenCache.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    AccessTokenEntity,\n    ICrypto,\n    IdTokenEntity,\n    Logger,\n    ScopeSet,\n    Authority,\n    AuthorityOptions,\n    ExternalTokenResponse,\n    AccountEntity,\n    AuthToken,\n    RefreshTokenEntity,\n    Constants,\n    CacheRecord,\n    TokenClaims,\n    CacheHelpers,\n    buildAccountToCache,\n} from \"@azure/msal-common\";\nimport { BrowserConfiguration } from \"../config/Configuration\";\nimport { SilentRequest } from \"../request/SilentRequest\";\nimport { BrowserCacheManager } from \"./BrowserCacheManager\";\nimport { ITokenCache } from \"./ITokenCache\";\nimport {\n    createBrowserAuthError,\n    BrowserAuthErrorCodes,\n} from \"../error/BrowserAuthError\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\nimport { base64Decode } from \"../encode/Base64Decode\";\nimport * as BrowserCrypto from \"../crypto/BrowserCrypto\";\n\nexport type LoadTokenOptions = {\n    clientInfo?: string;\n    expiresOn?: number;\n    extendedExpiresOn?: number;\n};\n\n/**\n * Token cache manager\n */\nexport class TokenCache implements ITokenCache {\n    // Flag to indicate if in browser environment\n    public isBrowserEnvironment: boolean;\n    // Input configuration by developer/user\n    protected config: BrowserConfiguration;\n    // Browser cache storage\n    private storage: BrowserCacheManager;\n    // Logger\n    private logger: Logger;\n    // Crypto class\n    private cryptoObj: ICrypto;\n\n    constructor(\n        configuration: BrowserConfiguration,\n        storage: BrowserCacheManager,\n        logger: Logger,\n        cryptoObj: ICrypto\n    ) {\n        this.isBrowserEnvironment = typeof window !== \"undefined\";\n        this.config = configuration;\n        this.storage = storage;\n        this.logger = logger;\n        this.cryptoObj = cryptoObj;\n    }\n\n    // Move getAllAccounts here and cache utility APIs\n\n    /**\n     * API to load tokens to msal-browser cache.\n     * @param request\n     * @param response\n     * @param options\n     * @returns `AuthenticationResult` for the response that was loaded.\n     */\n    loadExternalTokens(\n        request: SilentRequest,\n        response: ExternalTokenResponse,\n        options: LoadTokenOptions\n    ): AuthenticationResult {\n        this.logger.info(\"TokenCache - loadExternalTokens called\");\n\n        if (!response.id_token) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.unableToLoadToken\n            );\n        }\n\n        const idTokenClaims = AuthToken.extractTokenClaims(\n            response.id_token,\n            base64Decode\n        );\n\n        let cacheRecord: CacheRecord;\n        let authority: Authority | undefined;\n        let cacheRecordAccount: AccountEntity;\n\n        if (request.account) {\n            cacheRecordAccount = AccountEntity.createFromAccountInfo(\n                request.account\n            );\n            cacheRecord = new CacheRecord(\n                cacheRecordAccount,\n                this.loadIdToken(\n                    response.id_token,\n                    cacheRecordAccount.homeAccountId,\n                    request.account.environment,\n                    request.account.tenantId\n                ),\n                this.loadAccessToken(\n                    request,\n                    response,\n                    cacheRecordAccount.homeAccountId,\n                    request.account.environment,\n                    request.account.tenantId,\n                    options\n                ),\n                this.loadRefreshToken(\n                    request,\n                    response,\n                    cacheRecordAccount.homeAccountId,\n                    request.account.environment\n                )\n            );\n        } else if (request.authority) {\n            const authorityUrl = Authority.generateAuthority(\n                request.authority,\n                request.azureCloudOptions\n            );\n            const authorityOptions: AuthorityOptions = {\n                protocolMode: this.config.auth.protocolMode,\n                knownAuthorities: this.config.auth.knownAuthorities,\n                cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n                authorityMetadata: this.config.auth.authorityMetadata,\n                skipAuthorityMetadataCache:\n                    this.config.auth.skipAuthorityMetadataCache,\n            };\n            authority = new Authority(\n                authorityUrl,\n                this.config.system.networkClient,\n                this.storage,\n                authorityOptions,\n                this.logger,\n                request.correlationId || BrowserCrypto.createNewGuid()\n            );\n\n            // \"clientInfo\" from options takes precedence over \"clientInfo\" in response\n            if (options.clientInfo) {\n                this.logger.trace(\"TokenCache - homeAccountId from options\");\n                cacheRecordAccount = this.loadAccount(\n                    idTokenClaims,\n                    authority,\n                    options.clientInfo\n                );\n                cacheRecord = new CacheRecord(\n                    cacheRecordAccount,\n                    this.loadIdToken(\n                        response.id_token,\n                        cacheRecordAccount.homeAccountId,\n                        authority.hostnameAndPort,\n                        authority.tenant\n                    ),\n                    this.loadAccessToken(\n                        request,\n                        response,\n                        cacheRecordAccount.homeAccountId,\n                        authority.hostnameAndPort,\n                        authority.tenant,\n                        options\n                    ),\n                    this.loadRefreshToken(\n                        request,\n                        response,\n                        cacheRecordAccount.homeAccountId,\n                        authority.hostnameAndPort\n                    )\n                );\n            } else if (response.client_info) {\n                this.logger.trace(\"TokenCache - homeAccountId from response\");\n                cacheRecordAccount = this.loadAccount(\n                    idTokenClaims,\n                    authority,\n                    response.client_info\n                );\n                cacheRecord = new CacheRecord(\n                    cacheRecordAccount,\n                    this.loadIdToken(\n                        response.id_token,\n                        cacheRecordAccount.homeAccountId,\n                        authority.hostnameAndPort,\n                        authority.tenant\n                    ),\n                    this.loadAccessToken(\n                        request,\n                        response,\n                        cacheRecordAccount.homeAccountId,\n                        authority.hostnameAndPort,\n                        authority.tenant,\n                        options\n                    ),\n                    this.loadRefreshToken(\n                        request,\n                        response,\n                        cacheRecordAccount.homeAccountId,\n                        authority.hostnameAndPort\n                    )\n                );\n            } else {\n                throw createBrowserAuthError(\n                    BrowserAuthErrorCodes.unableToLoadToken\n                );\n            }\n        } else {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.unableToLoadToken\n            );\n        }\n\n        return this.generateAuthenticationResult(\n            request,\n            idTokenClaims,\n            cacheRecord,\n            cacheRecordAccount,\n            authority\n        );\n    }\n\n    /**\n     * Helper function to load account to msal-browser cache\n     * @param idToken\n     * @param environment\n     * @param clientInfo\n     * @param authorityType\n     * @param requestHomeAccountId\n     * @returns `AccountEntity`\n     */\n    private loadAccount(\n        idTokenClaims: TokenClaims,\n        authority: Authority,\n        clientInfo?: string,\n        requestHomeAccountId?: string\n    ): AccountEntity {\n        if (this.isBrowserEnvironment) {\n            this.logger.verbose(\"TokenCache - loading account\");\n            let homeAccountId;\n            if (requestHomeAccountId) {\n                homeAccountId = requestHomeAccountId;\n            } else if (authority.authorityType !== undefined && clientInfo) {\n                homeAccountId = AccountEntity.generateHomeAccountId(\n                    clientInfo,\n                    authority.authorityType,\n                    this.logger,\n                    this.cryptoObj,\n                    idTokenClaims\n                );\n            }\n\n            if (!homeAccountId) {\n                throw createBrowserAuthError(\n                    BrowserAuthErrorCodes.unableToLoadToken\n                );\n            }\n            const claimsTenantId = idTokenClaims.tid;\n\n            const cachedAccount = buildAccountToCache(\n                this.storage,\n                authority,\n                homeAccountId,\n                idTokenClaims,\n                base64Decode,\n                clientInfo,\n                authority.hostnameAndPort,\n                claimsTenantId,\n                undefined, // authCodePayload\n                undefined, // nativeAccountId\n                this.logger\n            );\n\n            this.storage.setAccount(cachedAccount);\n            return cachedAccount;\n        } else {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.unableToLoadToken\n            );\n        }\n    }\n\n    /**\n     * Helper function to load id tokens to msal-browser cache\n     * @param idToken\n     * @param homeAccountId\n     * @param environment\n     * @param tenantId\n     * @returns `IdTokenEntity`\n     */\n    private loadIdToken(\n        idToken: string,\n        homeAccountId: string,\n        environment: string,\n        tenantId: string\n    ): IdTokenEntity {\n        const idTokenEntity = CacheHelpers.createIdTokenEntity(\n            homeAccountId,\n            environment,\n            idToken,\n            this.config.auth.clientId,\n            tenantId\n        );\n\n        if (this.isBrowserEnvironment) {\n            this.logger.verbose(\"TokenCache - loading id token\");\n            this.storage.setIdTokenCredential(idTokenEntity);\n            return idTokenEntity;\n        } else {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.unableToLoadToken\n            );\n        }\n    }\n\n    /**\n     * Helper function to load access tokens to msal-browser cache\n     * @param request\n     * @param response\n     * @param homeAccountId\n     * @param environment\n     * @param tenantId\n     * @returns `AccessTokenEntity`\n     */\n    private loadAccessToken(\n        request: SilentRequest,\n        response: ExternalTokenResponse,\n        homeAccountId: string,\n        environment: string,\n        tenantId: string,\n        options: LoadTokenOptions\n    ): AccessTokenEntity | null {\n        if (!response.access_token) {\n            this.logger.verbose(\n                \"TokenCache - No access token provided for caching\"\n            );\n            return null;\n        }\n\n        if (!response.expires_in) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.unableToLoadToken\n            );\n        }\n\n        if (!options.extendedExpiresOn) {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.unableToLoadToken\n            );\n        }\n\n        const scopes = new ScopeSet(request.scopes).printScopes();\n        const expiresOn =\n            options.expiresOn ||\n            response.expires_in + new Date().getTime() / 1000;\n        const extendedExpiresOn = options.extendedExpiresOn;\n\n        const accessTokenEntity = CacheHelpers.createAccessTokenEntity(\n            homeAccountId,\n            environment,\n            response.access_token,\n            this.config.auth.clientId,\n            tenantId,\n            scopes,\n            expiresOn,\n            extendedExpiresOn,\n            base64Decode\n        );\n\n        if (this.isBrowserEnvironment) {\n            this.logger.verbose(\"TokenCache - loading access token\");\n            this.storage.setAccessTokenCredential(accessTokenEntity);\n            return accessTokenEntity;\n        } else {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.unableToLoadToken\n            );\n        }\n    }\n\n    /**\n     * Helper function to load refresh tokens to msal-browser cache\n     * @param request\n     * @param response\n     * @param homeAccountId\n     * @param environment\n     * @returns `RefreshTokenEntity`\n     */\n    private loadRefreshToken(\n        request: SilentRequest,\n        response: ExternalTokenResponse,\n        homeAccountId: string,\n        environment: string\n    ): RefreshTokenEntity | null {\n        if (!response.refresh_token) {\n            this.logger.verbose(\n                \"TokenCache - No refresh token provided for caching\"\n            );\n            return null;\n        }\n\n        const refreshTokenEntity = CacheHelpers.createRefreshTokenEntity(\n            homeAccountId,\n            environment,\n            response.refresh_token,\n            this.config.auth.clientId\n        );\n\n        if (this.isBrowserEnvironment) {\n            this.logger.verbose(\"TokenCache - loading refresh token\");\n            this.storage.setRefreshTokenCredential(refreshTokenEntity);\n            return refreshTokenEntity;\n        } else {\n            throw createBrowserAuthError(\n                BrowserAuthErrorCodes.unableToLoadToken\n            );\n        }\n    }\n\n    /**\n     * Helper function to generate an `AuthenticationResult` for the result.\n     * @param request\n     * @param idTokenObj\n     * @param cacheRecord\n     * @param authority\n     * @returns `AuthenticationResult`\n     */\n    private generateAuthenticationResult(\n        request: SilentRequest,\n        idTokenClaims: TokenClaims,\n        cacheRecord: CacheRecord,\n        accountEntity: AccountEntity,\n        authority?: Authority\n    ): AuthenticationResult {\n        let accessToken: string = Constants.EMPTY_STRING;\n        let responseScopes: Array<string> = [];\n        let expiresOn: Date | null = null;\n        let extExpiresOn: Date | undefined;\n\n        if (cacheRecord?.accessToken) {\n            accessToken = cacheRecord.accessToken.secret;\n            responseScopes = ScopeSet.fromString(\n                cacheRecord.accessToken.target\n            ).asArray();\n            expiresOn = new Date(\n                Number(cacheRecord.accessToken.expiresOn) * 1000\n            );\n            extExpiresOn = new Date(\n                Number(cacheRecord.accessToken.extendedExpiresOn) * 1000\n            );\n        }\n\n        const uid =\n            idTokenClaims.oid || idTokenClaims.sub || Constants.EMPTY_STRING;\n        const tid = idTokenClaims.tid || Constants.EMPTY_STRING;\n\n        return {\n            authority: authority\n                ? authority.canonicalAuthority\n                : Constants.EMPTY_STRING,\n            uniqueId: uid,\n            tenantId: tid,\n            scopes: responseScopes,\n            account: accountEntity.getAccountInfo(),\n            idToken: cacheRecord.idToken?.secret || \"\",\n            idTokenClaims: idTokenClaims || {},\n            accessToken: accessToken,\n            fromCache: true,\n            expiresOn: expiresOn,\n            correlationId: request.correlationId || Constants.EMPTY_STRING,\n            requestId: Constants.EMPTY_STRING,\n            extExpiresOn: extExpiresOn,\n            familyId: Constants.EMPTY_STRING,\n            tokenType:\n                cacheRecord?.accessToken?.tokenType || Constants.EMPTY_STRING,\n            state: Constants.EMPTY_STRING,\n            cloudGraphHostName:\n                accountEntity.cloudGraphHostName || Constants.EMPTY_STRING,\n            msGraphHost: accountEntity.msGraphHost || Constants.EMPTY_STRING,\n            code: undefined,\n            fromNativeBroker: false,\n        };\n    }\n}\n"],"mappings":";;;;;;;;;AAAA;;;AAGG;AAsCH;;AAEG;MACUA,UAAU;EAYnBC,YACIC,aAAmC,EACnCC,OAA4B,EAC5BC,MAAc,EACdC,SAAkB;IAElB,IAAI,CAACC,oBAAoB,GAAG,OAAOC,MAAM,KAAK,WAAW;IACzD,IAAI,CAACC,MAAM,GAAGN,aAAa;IAC3B,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,SAAS,GAAGA,SAAS;;;EAK9B;;;;;;AAMG;EACHI,kBAAkBA,CACdC,OAAsB,EACtBC,QAA+B,EAC/BC,OAAyB;IAEzB,IAAI,CAACR,MAAM,CAACS,IAAI,CAAC,wCAAwC,CAAC;IAE1D,IAAI,CAACF,QAAQ,CAACG,QAAQ,EAAE;MACpB,MAAMC,sBAAsB,CACxBC,iBAAuC,CAC1C;IACJ;IAED,MAAMC,aAAa,GAAGC,SAAS,CAACC,kBAAkB,CAC9CR,QAAQ,CAACG,QAAQ,EACjBM,YAAY,CACf;IAED,IAAIC,WAAwB;IAC5B,IAAIC,SAAgC;IACpC,IAAIC,kBAAiC;IAErC,IAAIb,OAAO,CAACc,OAAO,EAAE;MACjBD,kBAAkB,GAAGE,aAAa,CAACC,qBAAqB,CACpDhB,OAAO,CAACc,OAAO,CAClB;MACDH,WAAW,GAAG,IAAIM,WAAW,CACzBJ,kBAAkB,EAClB,IAAI,CAACK,WAAW,CACZjB,QAAQ,CAACG,QAAQ,EACjBS,kBAAkB,CAACM,aAAa,EAChCnB,OAAO,CAACc,OAAO,CAACM,WAAW,EAC3BpB,OAAO,CAACc,OAAO,CAACO,QAAQ,CAC3B,EACD,IAAI,CAACC,eAAe,CAChBtB,OAAO,EACPC,QAAQ,EACRY,kBAAkB,CAACM,aAAa,EAChCnB,OAAO,CAACc,OAAO,CAACM,WAAW,EAC3BpB,OAAO,CAACc,OAAO,CAACO,QAAQ,EACxBnB,OAAO,CACV,EACD,IAAI,CAACqB,gBAAgB,CACjBvB,OAAO,EACPC,QAAQ,EACRY,kBAAkB,CAACM,aAAa,EAChCnB,OAAO,CAACc,OAAO,CAACM,WAAW,CAC9B,CACJ;IACJ,OAAM,IAAIpB,OAAO,CAACY,SAAS,EAAE;MAC1B,MAAMY,YAAY,GAAGC,SAAS,CAACC,iBAAiB,CAC5C1B,OAAO,CAACY,SAAS,EACjBZ,OAAO,CAAC2B,iBAAiB,CAC5B;MACD,MAAMC,gBAAgB,GAAqB;QACvCC,YAAY,EAAE,IAAI,CAAC/B,MAAM,CAACgC,IAAI,CAACD,YAAY;QAC3CE,gBAAgB,EAAE,IAAI,CAACjC,MAAM,CAACgC,IAAI,CAACC,gBAAgB;QACnDC,sBAAsB,EAAE,IAAI,CAAClC,MAAM,CAACgC,IAAI,CAACE,sBAAsB;QAC/DC,iBAAiB,EAAE,IAAI,CAACnC,MAAM,CAACgC,IAAI,CAACG,iBAAiB;QACrDC,0BAA0B,EACtB,IAAI,CAACpC,MAAM,CAACgC,IAAI,CAACI;OACxB;MACDtB,SAAS,GAAG,IAAIa,SAAS,CACrBD,YAAY,EACZ,IAAI,CAAC1B,MAAM,CAACqC,MAAM,CAACC,aAAa,EAChC,IAAI,CAAC3C,OAAO,EACZmC,gBAAgB,EAChB,IAAI,CAAClC,MAAM,EACXM,OAAO,CAACqC,aAAa,IAAIC,aAA2B,EAAE,CACzD;;MAGD,IAAIpC,OAAO,CAACqC,UAAU,EAAE;QACpB,IAAI,CAAC7C,MAAM,CAAC8C,KAAK,CAAC,yCAAyC,CAAC;QAC5D3B,kBAAkB,GAAG,IAAI,CAAC4B,WAAW,CACjClC,aAAa,EACbK,SAAS,EACTV,OAAO,CAACqC,UAAU,CACrB;QACD5B,WAAW,GAAG,IAAIM,WAAW,CACzBJ,kBAAkB,EAClB,IAAI,CAACK,WAAW,CACZjB,QAAQ,CAACG,QAAQ,EACjBS,kBAAkB,CAACM,aAAa,EAChCP,SAAS,CAAC8B,eAAe,EACzB9B,SAAS,CAAC+B,MAAM,CACnB,EACD,IAAI,CAACrB,eAAe,CAChBtB,OAAO,EACPC,QAAQ,EACRY,kBAAkB,CAACM,aAAa,EAChCP,SAAS,CAAC8B,eAAe,EACzB9B,SAAS,CAAC+B,MAAM,EAChBzC,OAAO,CACV,EACD,IAAI,CAACqB,gBAAgB,CACjBvB,OAAO,EACPC,QAAQ,EACRY,kBAAkB,CAACM,aAAa,EAChCP,SAAS,CAAC8B,eAAe,CAC5B,CACJ;MACJ,OAAM,IAAIzC,QAAQ,CAAC2C,WAAW,EAAE;QAC7B,IAAI,CAAClD,MAAM,CAAC8C,KAAK,CAAC,0CAA0C,CAAC;QAC7D3B,kBAAkB,GAAG,IAAI,CAAC4B,WAAW,CACjClC,aAAa,EACbK,SAAS,EACTX,QAAQ,CAAC2C,WAAW,CACvB;QACDjC,WAAW,GAAG,IAAIM,WAAW,CACzBJ,kBAAkB,EAClB,IAAI,CAACK,WAAW,CACZjB,QAAQ,CAACG,QAAQ,EACjBS,kBAAkB,CAACM,aAAa,EAChCP,SAAS,CAAC8B,eAAe,EACzB9B,SAAS,CAAC+B,MAAM,CACnB,EACD,IAAI,CAACrB,eAAe,CAChBtB,OAAO,EACPC,QAAQ,EACRY,kBAAkB,CAACM,aAAa,EAChCP,SAAS,CAAC8B,eAAe,EACzB9B,SAAS,CAAC+B,MAAM,EAChBzC,OAAO,CACV,EACD,IAAI,CAACqB,gBAAgB,CACjBvB,OAAO,EACPC,QAAQ,EACRY,kBAAkB,CAACM,aAAa,EAChCP,SAAS,CAAC8B,eAAe,CAC5B,CACJ;MACJ,OAAM;QACH,MAAMrC,sBAAsB,CACxBC,iBAAuC,CAC1C;MACJ;IACJ,OAAM;MACH,MAAMD,sBAAsB,CACxBC,iBAAuC,CAC1C;IACJ;IAED,OAAO,IAAI,CAACuC,4BAA4B,CACpC7C,OAAO,EACPO,aAAa,EACbI,WAAW,EACXE,kBAAkB,EAClBD,SAAS,CACZ;;EAGL;;;;;;;;AAQG;EACK6B,WAAWA,CACflC,aAA0B,EAC1BK,SAAoB,EACpB2B,UAAmB,EACnBO,oBAA6B;IAE7B,IAAI,IAAI,CAAClD,oBAAoB,EAAE;MAC3B,IAAI,CAACF,MAAM,CAACqD,OAAO,CAAC,8BAA8B,CAAC;MACnD,IAAI5B,aAAa;MACjB,IAAI2B,oBAAoB,EAAE;QACtB3B,aAAa,GAAG2B,oBAAoB;MACvC,OAAM,IAAIlC,SAAS,CAACoC,aAAa,KAAKC,SAAS,IAAIV,UAAU,EAAE;QAC5DpB,aAAa,GAAGJ,aAAa,CAACmC,qBAAqB,CAC/CX,UAAU,EACV3B,SAAS,CAACoC,aAAa,EACvB,IAAI,CAACtD,MAAM,EACX,IAAI,CAACC,SAAS,EACdY,aAAa,CAChB;MACJ;MAED,IAAI,CAACY,aAAa,EAAE;QAChB,MAAMd,sBAAsB,CACxBC,iBAAuC,CAC1C;MACJ;MACD,MAAM6C,cAAc,GAAG5C,aAAa,CAAC6C,GAAG;MAExC,MAAMC,aAAa,GAAGC,mBAAmB,CACrC,IAAI,CAAC7D,OAAO,EACZmB,SAAS,EACTO,aAAa,EACbZ,aAAa,EACbG,YAAY,EACZ6B,UAAU,EACV3B,SAAS,CAAC8B,eAAe,EACzBS,cAAc,EACdF,SAAS;MAAA;MACTA,SAAS;MAAA;MACT,IAAI,CAACvD,MAAM,CACd;MAED,IAAI,CAACD,OAAO,CAAC8D,UAAU,CAACF,aAAa,CAAC;MACtC,OAAOA,aAAa;IACvB,OAAM;MACH,MAAMhD,sBAAsB,CACxBC,iBAAuC,CAC1C;IACJ;;EAGL;;;;;;;AAOG;EACKY,WAAWA,CACfsC,OAAe,EACfrC,aAAqB,EACrBC,WAAmB,EACnBC,QAAgB;IAEhB,MAAMoC,aAAa,GAAGC,YAAY,CAACC,mBAAmB,CAClDxC,aAAa,EACbC,WAAW,EACXoC,OAAO,EACP,IAAI,CAAC1D,MAAM,CAACgC,IAAI,CAAC8B,QAAQ,EACzBvC,QAAQ,CACX;IAED,IAAI,IAAI,CAACzB,oBAAoB,EAAE;MAC3B,IAAI,CAACF,MAAM,CAACqD,OAAO,CAAC,+BAA+B,CAAC;MACpD,IAAI,CAACtD,OAAO,CAACoE,oBAAoB,CAACJ,aAAa,CAAC;MAChD,OAAOA,aAAa;IACvB,OAAM;MACH,MAAMpD,sBAAsB,CACxBC,iBAAuC,CAC1C;IACJ;;EAGL;;;;;;;;AAQG;EACKgB,eAAeA,CACnBtB,OAAsB,EACtBC,QAA+B,EAC/BkB,aAAqB,EACrBC,WAAmB,EACnBC,QAAgB,EAChBnB,OAAyB;IAEzB,IAAI,CAACD,QAAQ,CAAC6D,YAAY,EAAE;MACxB,IAAI,CAACpE,MAAM,CAACqD,OAAO,CACf,mDAAmD,CACtD;MACD,OAAO,IAAI;IACd;IAED,IAAI,CAAC9C,QAAQ,CAAC8D,UAAU,EAAE;MACtB,MAAM1D,sBAAsB,CACxBC,iBAAuC,CAC1C;IACJ;IAED,IAAI,CAACJ,OAAO,CAAC8D,iBAAiB,EAAE;MAC5B,MAAM3D,sBAAsB,CACxBC,iBAAuC,CAC1C;IACJ;IAED,MAAM2D,MAAM,GAAG,IAAIC,QAAQ,CAAClE,OAAO,CAACiE,MAAM,CAAC,CAACE,WAAW,EAAE;IACzD,MAAMC,SAAS,GACXlE,OAAO,CAACkE,SAAS,IACjBnE,QAAQ,CAAC8D,UAAU,GAAG,IAAIM,IAAI,EAAE,CAACC,OAAO,EAAE,GAAG,IAAI;IACrD,MAAMN,iBAAiB,GAAG9D,OAAO,CAAC8D,iBAAiB;IAEnD,MAAMO,iBAAiB,GAAGb,YAAY,CAACc,uBAAuB,CAC1DrD,aAAa,EACbC,WAAW,EACXnB,QAAQ,CAAC6D,YAAY,EACrB,IAAI,CAAChE,MAAM,CAACgC,IAAI,CAAC8B,QAAQ,EACzBvC,QAAQ,EACR4C,MAAM,EACNG,SAAS,EACTJ,iBAAiB,EACjBtD,YAAY,CACf;IAED,IAAI,IAAI,CAACd,oBAAoB,EAAE;MAC3B,IAAI,CAACF,MAAM,CAACqD,OAAO,CAAC,mCAAmC,CAAC;MACxD,IAAI,CAACtD,OAAO,CAACgF,wBAAwB,CAACF,iBAAiB,CAAC;MACxD,OAAOA,iBAAiB;IAC3B,OAAM;MACH,MAAMlE,sBAAsB,CACxBC,iBAAuC,CAC1C;IACJ;;EAGL;;;;;;;AAOG;EACKiB,gBAAgBA,CACpBvB,OAAsB,EACtBC,QAA+B,EAC/BkB,aAAqB,EACrBC,WAAmB;IAEnB,IAAI,CAACnB,QAAQ,CAACyE,aAAa,EAAE;MACzB,IAAI,CAAChF,MAAM,CAACqD,OAAO,CACf,oDAAoD,CACvD;MACD,OAAO,IAAI;IACd;IAED,MAAM4B,kBAAkB,GAAGjB,YAAY,CAACkB,wBAAwB,CAC5DzD,aAAa,EACbC,WAAW,EACXnB,QAAQ,CAACyE,aAAa,EACtB,IAAI,CAAC5E,MAAM,CAACgC,IAAI,CAAC8B,QAAQ,CAC5B;IAED,IAAI,IAAI,CAAChE,oBAAoB,EAAE;MAC3B,IAAI,CAACF,MAAM,CAACqD,OAAO,CAAC,oCAAoC,CAAC;MACzD,IAAI,CAACtD,OAAO,CAACoF,yBAAyB,CAACF,kBAAkB,CAAC;MAC1D,OAAOA,kBAAkB;IAC5B,OAAM;MACH,MAAMtE,sBAAsB,CACxBC,iBAAuC,CAC1C;IACJ;;EAGL;;;;;;;AAOG;EACKuC,4BAA4BA,CAChC7C,OAAsB,EACtBO,aAA0B,EAC1BI,WAAwB,EACxBmE,aAA4B,EAC5BlE,SAAqB;IAErB,IAAImE,WAAW,GAAWC,SAAS,CAACC,YAAY;IAChD,IAAIC,cAAc,GAAkB,EAAE;IACtC,IAAId,SAAS,GAAgB,IAAI;IACjC,IAAIe,YAA8B;IAElC,IAAIxE,WAAW,EAAEoE,WAAW,EAAE;MAC1BA,WAAW,GAAGpE,WAAW,CAACoE,WAAW,CAACK,MAAM;MAC5CF,cAAc,GAAGhB,QAAQ,CAACmB,UAAU,CAChC1E,WAAW,CAACoE,WAAW,CAACO,MAAM,CACjC,CAACC,OAAO,EAAE;MACXnB,SAAS,GAAG,IAAIC,IAAI,CAChBmB,MAAM,CAAC7E,WAAW,CAACoE,WAAW,CAACX,SAAS,CAAC,GAAG,IAAI,CACnD;MACDe,YAAY,GAAG,IAAId,IAAI,CACnBmB,MAAM,CAAC7E,WAAW,CAACoE,WAAW,CAACf,iBAAiB,CAAC,GAAG,IAAI,CAC3D;IACJ;IAED,MAAMyB,GAAG,GACLlF,aAAa,CAACmF,GAAG,IAAInF,aAAa,CAACoF,GAAG,IAAIX,SAAS,CAACC,YAAY;IACpE,MAAM7B,GAAG,GAAG7C,aAAa,CAAC6C,GAAG,IAAI4B,SAAS,CAACC,YAAY;IAEvD,OAAO;MACHrE,SAAS,EAAEA,SAAS,GACdA,SAAS,CAACgF,kBAAkB,GAC5BZ,SAAS,CAACC,YAAY;MAC5BY,QAAQ,EAAEJ,GAAG;MACbpE,QAAQ,EAAE+B,GAAG;MACba,MAAM,EAAEiB,cAAc;MACtBpE,OAAO,EAAEgE,aAAa,CAACgB,cAAc,EAAE;MACvCtC,OAAO,EAAE7C,WAAW,CAAC6C,OAAO,EAAE4B,MAAM,IAAI,EAAE;MAC1C7E,aAAa,EAAEA,aAAa,IAAI,EAAE;MAClCwE,WAAW,EAAEA,WAAW;MACxBgB,SAAS,EAAE,IAAI;MACf3B,SAAS,EAAEA,SAAS;MACpB/B,aAAa,EAAErC,OAAO,CAACqC,aAAa,IAAI2C,SAAS,CAACC,YAAY;MAC9De,SAAS,EAAEhB,SAAS,CAACC,YAAY;MACjCE,YAAY,EAAEA,YAAY;MAC1Bc,QAAQ,EAAEjB,SAAS,CAACC,YAAY;MAChCiB,SAAS,EACLvF,WAAW,EAAEoE,WAAW,EAAEmB,SAAS,IAAIlB,SAAS,CAACC,YAAY;MACjEkB,KAAK,EAAEnB,SAAS,CAACC,YAAY;MAC7BmB,kBAAkB,EACdtB,aAAa,CAACsB,kBAAkB,IAAIpB,SAAS,CAACC,YAAY;MAC9DoB,WAAW,EAAEvB,aAAa,CAACuB,WAAW,IAAIrB,SAAS,CAACC,YAAY;MAChEqB,IAAI,EAAErD,SAAS;MACfsD,gBAAgB,EAAE;KACrB;;AAER"},"metadata":{},"sourceType":"module","externalDependencies":[]}