{"ast":null,"code":"/*! @azure/msal-common v14.4.0 2023-11-07 */\n'use strict';\n\nimport { createClientConfigurationError } from '../error/ClientConfigurationError.mjs';\nimport { StringUtils } from '../utils/StringUtils.mjs';\nimport { AADAuthorityConstants, Constants } from '../utils/Constants.mjs';\nimport { getDeserializedResponse } from '../utils/UrlUtils.mjs';\nimport { urlEmptyError, urlParseError, authorityUriInsecure } from '../error/ClientConfigurationErrorCodes.mjs';\n\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n/**\n * Url object class which can perform various transformations on url strings.\n */\nclass UrlString {\n  get urlString() {\n    return this._urlString;\n  }\n  constructor(url) {\n    this._urlString = url;\n    if (!this._urlString) {\n      // Throws error if url is empty\n      throw createClientConfigurationError(urlEmptyError);\n    }\n    if (!url.includes(\"#\")) {\n      this._urlString = UrlString.canonicalizeUri(url);\n    }\n  }\n  /**\n   * Ensure urls are lower case and end with a / character.\n   * @param url\n   */\n  static canonicalizeUri(url) {\n    if (url) {\n      let lowerCaseUrl = url.toLowerCase();\n      if (StringUtils.endsWith(lowerCaseUrl, \"?\")) {\n        lowerCaseUrl = lowerCaseUrl.slice(0, -1);\n      } else if (StringUtils.endsWith(lowerCaseUrl, \"?/\")) {\n        lowerCaseUrl = lowerCaseUrl.slice(0, -2);\n      }\n      if (!StringUtils.endsWith(lowerCaseUrl, \"/\")) {\n        lowerCaseUrl += \"/\";\n      }\n      return lowerCaseUrl;\n    }\n    return url;\n  }\n  /**\n   * Throws if urlString passed is not a valid authority URI string.\n   */\n  validateAsUri() {\n    // Attempts to parse url for uri components\n    let components;\n    try {\n      components = this.getUrlComponents();\n    } catch (e) {\n      throw createClientConfigurationError(urlParseError);\n    }\n    // Throw error if URI or path segments are not parseable.\n    if (!components.HostNameAndPort || !components.PathSegments) {\n      throw createClientConfigurationError(urlParseError);\n    }\n    // Throw error if uri is insecure.\n    if (!components.Protocol || components.Protocol.toLowerCase() !== \"https:\") {\n      throw createClientConfigurationError(authorityUriInsecure);\n    }\n  }\n  /**\n   * Given a url and a query string return the url with provided query string appended\n   * @param url\n   * @param queryString\n   */\n  static appendQueryString(url, queryString) {\n    if (!queryString) {\n      return url;\n    }\n    return url.indexOf(\"?\") < 0 ? `${url}?${queryString}` : `${url}&${queryString}`;\n  }\n  /**\n   * Returns a url with the hash removed\n   * @param url\n   */\n  static removeHashFromUrl(url) {\n    return UrlString.canonicalizeUri(url.split(\"#\")[0]);\n  }\n  /**\n   * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d\n   * @param href The url\n   * @param tenantId The tenant id to replace\n   */\n  replaceTenantPath(tenantId) {\n    const urlObject = this.getUrlComponents();\n    const pathArray = urlObject.PathSegments;\n    if (tenantId && pathArray.length !== 0 && (pathArray[0] === AADAuthorityConstants.COMMON || pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)) {\n      pathArray[0] = tenantId;\n    }\n    return UrlString.constructAuthorityUriFromObject(urlObject);\n  }\n  /**\n   * Parses out the components from a url string.\n   * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.\n   */\n  getUrlComponents() {\n    // https://gist.github.com/curtisz/11139b2cfcaef4a261e0\n    const regEx = RegExp(\"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\");\n    // If url string does not match regEx, we throw an error\n    const match = this.urlString.match(regEx);\n    if (!match) {\n      throw createClientConfigurationError(urlParseError);\n    }\n    // Url component object\n    const urlComponents = {\n      Protocol: match[1],\n      HostNameAndPort: match[4],\n      AbsolutePath: match[5],\n      QueryString: match[7]\n    };\n    let pathSegments = urlComponents.AbsolutePath.split(\"/\");\n    pathSegments = pathSegments.filter(val => val && val.length > 0); // remove empty elements\n    urlComponents.PathSegments = pathSegments;\n    if (urlComponents.QueryString && urlComponents.QueryString.endsWith(\"/\")) {\n      urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);\n    }\n    return urlComponents;\n  }\n  static getDomainFromUrl(url) {\n    const regEx = RegExp(\"^([^:/?#]+://)?([^/?#]*)\");\n    const match = url.match(regEx);\n    if (!match) {\n      throw createClientConfigurationError(urlParseError);\n    }\n    return match[2];\n  }\n  static getAbsoluteUrl(relativeUrl, baseUrl) {\n    if (relativeUrl[0] === Constants.FORWARD_SLASH) {\n      const url = new UrlString(baseUrl);\n      const baseComponents = url.getUrlComponents();\n      return baseComponents.Protocol + \"//\" + baseComponents.HostNameAndPort + relativeUrl;\n    }\n    return relativeUrl;\n  }\n  static constructAuthorityUriFromObject(urlObject) {\n    return new UrlString(urlObject.Protocol + \"//\" + urlObject.HostNameAndPort + \"/\" + urlObject.PathSegments.join(\"/\"));\n  }\n  /**\n   * Check if the hash of the URL string contains known properties\n   * @deprecated This API will be removed in a future version\n   */\n  static hashContainsKnownProperties(response) {\n    return !!getDeserializedResponse(response);\n  }\n}\nexport { UrlString };","map":{"version":3,"names":["UrlString","urlString","_urlString","constructor","url","includes","canonicalizeUri","StringUtils","endsWith","lowerCaseUrl","slice"],"sources":["D:\\react-typescript\\intelli-gui\\node_modules\\@azure\\msal-common\\src\\url\\UrlString.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    createClientConfigurationError,\n    ClientConfigurationErrorCodes,\n} from \"../error/ClientConfigurationError\";\nimport { StringUtils } from \"../utils/StringUtils\";\nimport { IUri } from \"./IUri\";\nimport { AADAuthorityConstants, Constants } from \"../utils/Constants\";\nimport * as UrlUtils from \"../utils/UrlUtils\";\n\n/**\n * Url object class which can perform various transformations on url strings.\n */\nexport class UrlString {\n    // internal url string field\n    private _urlString: string;\n    public get urlString(): string {\n        return this._urlString;\n    }\n\n    constructor(url: string) {\n        this._urlString = url;\n        if (!this._urlString) {\n            // Throws error if url is empty\n            throw createClientConfigurationError(\n                ClientConfigurationErrorCodes.urlEmptyError\n            );\n        }\n\n        if (!url.includes(\"#\")) {\n            this._urlString = UrlString.canonicalizeUri(url);\n        }\n    }\n\n    /**\n     * Ensure urls are lower case and end with a / character.\n     * @param url\n     */\n    static canonicalizeUri(url: string): string {\n        if (url) {\n            let lowerCaseUrl = url.toLowerCase();\n\n            if (StringUtils.endsWith(lowerCaseUrl, \"?\")) {\n                lowerCaseUrl = lowerCaseUrl.slice(0, -1);\n            } else if (StringUtils.endsWith(lowerCaseUrl, \"?/\")) {\n                lowerCaseUrl = lowerCaseUrl.slice(0, -2);\n            }\n\n            if (!StringUtils.endsWith(lowerCaseUrl, \"/\")) {\n                lowerCaseUrl += \"/\";\n            }\n\n            return lowerCaseUrl;\n        }\n\n        return url;\n    }\n\n    /**\n     * Throws if urlString passed is not a valid authority URI string.\n     */\n    validateAsUri(): void {\n        // Attempts to parse url for uri components\n        let components;\n        try {\n            components = this.getUrlComponents();\n        } catch (e) {\n            throw createClientConfigurationError(\n                ClientConfigurationErrorCodes.urlParseError\n            );\n        }\n\n        // Throw error if URI or path segments are not parseable.\n        if (!components.HostNameAndPort || !components.PathSegments) {\n            throw createClientConfigurationError(\n                ClientConfigurationErrorCodes.urlParseError\n            );\n        }\n\n        // Throw error if uri is insecure.\n        if (\n            !components.Protocol ||\n            components.Protocol.toLowerCase() !== \"https:\"\n        ) {\n            throw createClientConfigurationError(\n                ClientConfigurationErrorCodes.authorityUriInsecure\n            );\n        }\n    }\n\n    /**\n     * Given a url and a query string return the url with provided query string appended\n     * @param url\n     * @param queryString\n     */\n    static appendQueryString(url: string, queryString: string): string {\n        if (!queryString) {\n            return url;\n        }\n\n        return url.indexOf(\"?\") < 0\n            ? `${url}?${queryString}`\n            : `${url}&${queryString}`;\n    }\n\n    /**\n     * Returns a url with the hash removed\n     * @param url\n     */\n    static removeHashFromUrl(url: string): string {\n        return UrlString.canonicalizeUri(url.split(\"#\")[0]);\n    }\n\n    /**\n     * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d\n     * @param href The url\n     * @param tenantId The tenant id to replace\n     */\n    replaceTenantPath(tenantId: string): UrlString {\n        const urlObject = this.getUrlComponents();\n        const pathArray = urlObject.PathSegments;\n        if (\n            tenantId &&\n            pathArray.length !== 0 &&\n            (pathArray[0] === AADAuthorityConstants.COMMON ||\n                pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)\n        ) {\n            pathArray[0] = tenantId;\n        }\n        return UrlString.constructAuthorityUriFromObject(urlObject);\n    }\n\n    /**\n     * Parses out the components from a url string.\n     * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.\n     */\n    getUrlComponents(): IUri {\n        // https://gist.github.com/curtisz/11139b2cfcaef4a261e0\n        const regEx = RegExp(\n            \"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?\"\n        );\n\n        // If url string does not match regEx, we throw an error\n        const match = this.urlString.match(regEx);\n        if (!match) {\n            throw createClientConfigurationError(\n                ClientConfigurationErrorCodes.urlParseError\n            );\n        }\n\n        // Url component object\n        const urlComponents = {\n            Protocol: match[1],\n            HostNameAndPort: match[4],\n            AbsolutePath: match[5],\n            QueryString: match[7],\n        } as IUri;\n\n        let pathSegments = urlComponents.AbsolutePath.split(\"/\");\n        pathSegments = pathSegments.filter((val) => val && val.length > 0); // remove empty elements\n        urlComponents.PathSegments = pathSegments;\n\n        if (\n            urlComponents.QueryString &&\n            urlComponents.QueryString.endsWith(\"/\")\n        ) {\n            urlComponents.QueryString = urlComponents.QueryString.substring(\n                0,\n                urlComponents.QueryString.length - 1\n            );\n        }\n        return urlComponents;\n    }\n\n    static getDomainFromUrl(url: string): string {\n        const regEx = RegExp(\"^([^:/?#]+://)?([^/?#]*)\");\n\n        const match = url.match(regEx);\n\n        if (!match) {\n            throw createClientConfigurationError(\n                ClientConfigurationErrorCodes.urlParseError\n            );\n        }\n\n        return match[2];\n    }\n\n    static getAbsoluteUrl(relativeUrl: string, baseUrl: string): string {\n        if (relativeUrl[0] === Constants.FORWARD_SLASH) {\n            const url = new UrlString(baseUrl);\n            const baseComponents = url.getUrlComponents();\n\n            return (\n                baseComponents.Protocol +\n                \"//\" +\n                baseComponents.HostNameAndPort +\n                relativeUrl\n            );\n        }\n\n        return relativeUrl;\n    }\n\n    static constructAuthorityUriFromObject(urlObject: IUri): UrlString {\n        return new UrlString(\n            urlObject.Protocol +\n                \"//\" +\n                urlObject.HostNameAndPort +\n                \"/\" +\n                urlObject.PathSegments.join(\"/\")\n        );\n    }\n\n    /**\n     * Check if the hash of the URL string contains known properties\n     * @deprecated This API will be removed in a future version\n     */\n    static hashContainsKnownProperties(response: string): boolean {\n        return !!UrlUtils.getDeserializedResponse(response);\n    }\n}\n"],"mappings":";;;;;;;;;AAUA;AAIA;;AAEG;AAsBC;;;AAGG,MAAAA,SAAA;EACH,IAAAC,SAAsBA,CAAA;IAoBtB,YAAAC,UAAA;;EAEGC,YAAAC,GAAA;IACH,KAAAF,UAAqB,GAAAE,GAAA;IA6BrB,UAAAF,UAAA;;;;IAIG,KAAAE,GAAA,CAAAC,QAAA;MACqB,KAAAH,UAAA,GAAIF,SAAQ,CAAAM,eAAe,CAAMF,GAAA;IAUzD;;;AAGG;AACH;AAIA;;;;MAIG,IAAAG,WAAA,CAAAC,QAAA,CAAAC,YAAA;QACHA,YAAkB,GAAUA,YAAkB,CAAAC,KAAA;MAc9C,O;;MAGG;MACH,KAAAH,WAAwB,CAAAC,QAAA,CAAAC,YAAA;QAsCDA,YAAC,IAAK;;MA8BS,OAAAA,YAAA;IAUtC;;;EAGG;AACH;AAGH"},"metadata":{},"sourceType":"module","externalDependencies":[]}